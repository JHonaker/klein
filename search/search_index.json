{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Klein Do you need to do any of the following? Quickly? Really quickly even? Projecting points onto lines, lines to planes, points to planes? Measuring distances and angles between points, lines, and planes? Rotate or translate points, lines, and planes? Perform smooth rigid body transforms? Interpolate them smoothly? Construct lines from points? Planes from points? Planes from a line and a point? Intersect planes to form lines? Intersect a planes and lines to form points? If so, then Klein is the library for you! Feature Summary Klein is an implementation of \\(\\mathbf{P}(\\mathbb{R}^*_{3, 0, 1})\\) , aka 3D Projective Geometric Algebra. It is designed for applications that demand high-throughput (animation libraries, kinematic solvers, etc). In contrast to other GA libraries, Klein does not attempt to generalize the metric or dimensionality of the space. In exchange for this loss of generality, Klein implements the algebraic operations using the full weight of SSE (Streaming SIMD Extensions) for maximum throughput. Klein's performance is fully competitive with state of the art kinematic and math libraries built with traditional vector and quaternion formulations. Tip Knowledge of Geometric Algebra is NOT required to benefit from the library , but familiarity can ease the learning curve of the API somewhat, as the operators in Geometric Algebra map cleanly to geometric operations. Geometric computing library suitable for use with realtime graphics and animation applications Header-only core libary with an optional lightweight symbolic computer algebra system SSE3 or SSE4.1-optimized implementations Tested on Linux, MacOS, and Windows Requires no third-party dependencies Permissively licensed Frequently tested compilers GCC 9.2.1 on Linux Clang 9.0.1 on Linux Visual Studio 2019 on Windows 10 Xcode 11.3 on MacOS Supported entities Points Directions Lines Ideal lines Planes Rotors Translators Motors Supported operations Geometric product (used to compose group actions) Exterior product (used to meet entities) Regressive product (used to join entities) Conjugation (aka \"sandwich\") operators (defined via the call operator on planes, rotors, translators, and motors) Inner product (used for metric measurements and to project entities) Standard arithmetic operations Motor logarithm to compute the motor axis Line exponentiation to generate motors Rotor logarithm to compute the rotor axis (also referred to as a branch ) Branch exponentiation to generate rotors The spherical interpolation operation \"slerp\" can be implemented easily in terms of the rotor or motor logarithm, depending on what is needed.","title":"Home"},{"location":"#klein","text":"Do you need to do any of the following? Quickly? Really quickly even? Projecting points onto lines, lines to planes, points to planes? Measuring distances and angles between points, lines, and planes? Rotate or translate points, lines, and planes? Perform smooth rigid body transforms? Interpolate them smoothly? Construct lines from points? Planes from points? Planes from a line and a point? Intersect planes to form lines? Intersect a planes and lines to form points? If so, then Klein is the library for you!","title":"Klein"},{"location":"#feature-summary","text":"Klein is an implementation of \\(\\mathbf{P}(\\mathbb{R}^*_{3, 0, 1})\\) , aka 3D Projective Geometric Algebra. It is designed for applications that demand high-throughput (animation libraries, kinematic solvers, etc). In contrast to other GA libraries, Klein does not attempt to generalize the metric or dimensionality of the space. In exchange for this loss of generality, Klein implements the algebraic operations using the full weight of SSE (Streaming SIMD Extensions) for maximum throughput. Klein's performance is fully competitive with state of the art kinematic and math libraries built with traditional vector and quaternion formulations. Tip Knowledge of Geometric Algebra is NOT required to benefit from the library , but familiarity can ease the learning curve of the API somewhat, as the operators in Geometric Algebra map cleanly to geometric operations. Geometric computing library suitable for use with realtime graphics and animation applications Header-only core libary with an optional lightweight symbolic computer algebra system SSE3 or SSE4.1-optimized implementations Tested on Linux, MacOS, and Windows Requires no third-party dependencies Permissively licensed","title":"Feature Summary"},{"location":"#frequently-tested-compilers","text":"GCC 9.2.1 on Linux Clang 9.0.1 on Linux Visual Studio 2019 on Windows 10 Xcode 11.3 on MacOS","title":"Frequently tested compilers"},{"location":"#supported-entities","text":"Points Directions Lines Ideal lines Planes Rotors Translators Motors","title":"Supported entities"},{"location":"#supported-operations","text":"Geometric product (used to compose group actions) Exterior product (used to meet entities) Regressive product (used to join entities) Conjugation (aka \"sandwich\") operators (defined via the call operator on planes, rotors, translators, and motors) Inner product (used for metric measurements and to project entities) Standard arithmetic operations Motor logarithm to compute the motor axis Line exponentiation to generate motors Rotor logarithm to compute the rotor axis (also referred to as a branch ) Branch exponentiation to generate rotors The spherical interpolation operation \"slerp\" can be implemented easily in terms of the rotor or motor logarithm, depending on what is needed.","title":"Supported operations"},{"location":"discord/","text":"The Klein discord is very new but anyone is welcome to drop in and offer feedback, ask for help, or discuss topics ranging from graphics programming, math (geometric algebra or otherwise), physics, and more.","title":"Discord"},{"location":"geometry-potpourri/","text":"In this workbook, we're going to walk through a number of common geometric tasks such as finding intersections, computing distances, performing rotations, etc. For each task, we'll showcase not only the Klein code that would produce the desired result, but also show mathematically how it can be computed by hand. Pen and paper is not only encouraged, it is likely a requirement to get the most out of this workbook. Lack of rigor ahead! In this article, I make very little effort to explain why an operation is defined a certain way or explain some of the deeper underlying mathematics. This article was written because it's often helpful to see how computation is done first, and perform some calculations by hande as well gain some intuition before taking a closer look at the theory. Multivectors Info Klein API: kln::entity In this section, we look at all the various operations and elements that show up in \\(\\PGA\\) . A common question that people run into when getting exposed to GA for the first time is, \"why are their so many operations?\" The best answer is that, well, geometry has a lot of operations! More than can be captured easily with just the dot product and cross product you're likely familiar with. This section just gets you acquainted with the mechanics of \\(\\PGA\\) , but to glean more geometric intuition, all the sections afteward will focus on concrete examples (plane distance to point, meeting to points to make a line, projecting a line onto a plane, rotating a point about a line, reflecting a point through a plane, etc). You'll find that for a bit of upfront complexity presented here, what's gained is a satisfying degree of uniformity in all the geometry that comes later. PGA Basis and Geometric Product Info Klein API: operator* Written as two elements adjacent to each other ( \\(ab\\) ). Let's get used to some basis elements and operations first. In \\(\\mathbf{P}(\\mathbb{R}^*_{3, 0, 1})\\) (also known as PGA), we have four grade-1 vector basis elements, \\(\\ee_0\\) , \\(\\ee_1\\) , \\(\\ee_2\\) , and \\(\\ee_3\\) . Let's define the square of these vectors in the following manner. The first element squares to \\(0\\) ( \\(\\ee_0 \\ee_0 = 0\\) ) while the latter 3 elements square to \\(1\\) ( \\(\\ee_1\\ee_1 = \\ee_2\\ee_2 = \\ee_3\\ee_3 = 1\\) ). As we now immediately have a means to create \\(1\\) , we can generate all the numbers this way, so let's declare \\(1\\) as our grade-0 basis element. Grade? Very non-mathematically, the \"grade\" of an element is the number of subscripts it possesses. Soon, you should get a good feel of what grades result from what operations, and what information the grades present in a multivector quantity conveys. When we write elements adjacent to one another as in \\(\\ee_1\\ee_1\\) , the operation being represented here is the geometric product . In code, the geometric product is expressed as the multiplication ( * ) operator. So far, we've written down what the geometric product does when the elements multiply against themselves. Next, we need to describe what happens when we take the geometric product between different elements. Mixed products of the basis vectors produce the basis bivectors, which can themselves be used in linear combinations to produce general bivectors. Bivectors that can be written as the product of two vectors may be referred to as blades or simple bivectors . The products between basis vectors are all blades by definition. As shorthand, we combine subscripts as shown below: \\[ \\begin{aligned} \\ee_1\\ee_0 &= \\ee_{10} \\\\ \\ee_1\\ee_2 &= \\ee_{12} \\\\ \\ee_3\\ee_0 &= \\ee_{30} \\\\ &\\dots \\end{aligned} \\] At the moment, we would have \\(4\\times 3 = 12\\) basis bivectors if defined this way, but we impose a relation on them that relates basis bivectors that contain the same subscripts. Namely, the product of two vectors is minus the product of the two vectors with the order interchanged. \\[ \\begin{aligned} \\ee_{01} &= -\\ee_{10} \\\\ \\ee_{02} &= -\\ee_{20} \\\\ \\ee_{03} &= -\\ee_{30} \\\\ \\ee_{12} &= -\\ee_{21} \\\\ \\ee_{31} &= -\\ee_{13} \\\\ \\ee_{23} &= -\\ee_{32} \\tag{1} \\end{aligned} \\] For reasons that will become clear in a future writeup, we'll select the blades on the left hand side of \\((1)\\) to be the canonical 2-blades in PGA. There is some choice index order selection as will be explained later, but the order here is used to match existing literature and so that computations later are made more convenient. Now that we know we can swap the order of the multiplication by basis vectors by introducing a sign, we can compute things like \\(\\ee_{01}\\ee_0\\) . \\[ \\begin{aligned} \\ee_{01}\\ee_0 &= \\ee_0\\ee_1\\ee_0 \\\\ &= -\\ee_0\\ee_0\\ee_1 \\\\ &= 0 \\end{aligned} \\] Another example (that doesn't vanish): \\[ \\begin{aligned} \\ee_{20}\\ee_2 &= \\ee_2\\ee_0\\ee_2 \\\\ &= -\\ee_2\\ee_2\\ee_0 \\\\ &= -\\ee_0 \\end{aligned} \\] The same algorithm can be used to produce the 4 trivectors: \\[ \\begin{aligned} \\ee_{123} &= \\ee_{12}\\ee_3 = -\\ee_{132} = \\ee_{312} \\\\ \\ee_{021} &= \\ee_{02}\\ee_1 = -\\ee_{201} = \\ee_{210} \\\\ \\ee_{013} &= \\ee_{01}\\ee_3 = -\\ee_{031} = \\ee_{301} \\\\ \\ee_{032} &= \\ee_{03}\\ee_2 = -\\ee_{302} = \\ee_{320} \\end{aligned} \\] Not all permutations were listed, but just a few so you can gain familiarity with swapping indices and introducing signs or removing them as ncessary. The last element we haven't touched on is the pseudoscalar \\(\\ee_{0123}\\) . The pseudoscalar is so named because while it does not have grade zero, it is uniquely identified within its grade to within a permutation of its indices (compared to, say, the grade-2 elements of which there are six distinct members). Note that there is no way in which we can introduce an element with grade higher than this, and so our \\(16\\) algebra elements (1 scalar, 4 vector, 6 bivector, 4 trivector, and 1 pseudoscalar) are fully described. Linear combinations can be made from all of these elements to produce a general multivector. To take the geometric product between general multivectors, we leverage the fact that the geometric product obeys the distributive law. \\[ \\begin{aligned} (4\\ee_1 - 2\\ee_{32})(3\\ee_{012} + \\ee_{10}) &= 4\\ee_1(3\\ee_{012} + \\ee_{10}) - 2\\ee_{32}(3\\ee_{012} + \\ee_{10}) \\\\ &= 12\\ee_1\\ee_{012} + 4\\ee_1\\ee_{10} - 6\\ee_{32}\\ee_{012} - 2\\ee_{32}\\ee_{10} \\\\ &= -12\\ee_{02} + 4\\ee_0 - 6\\ee_{301} - 2\\ee_{3210} \\\\ &= 4\\ee_0 - 12\\ee_{02} - 6\\ee_{013} - 2\\ee_{0123} \\end{aligned} \\] In the last step, we simply took the time to sort the resulting terms by grade and also performed swaps as necessary to write terms with the canonical subscript ordering. Exercises Write down two vectors whose product is \\(-\\ee_{01} + 2\\ee_{13}\\) . The geometric product is neither commutative, nor anticommutative. Find examples that demonstrate this fact. Not every bivector can be written down as the product of two vectors. Find an example that demonstrates this fact. The Symmetric Inner Product Info Klein API: operator| Written as \\(a \\cdot b\\) . The symmetric inner product (inner product for short) is a bilinear binary operation like the geometric product except it is always grade decreasing such that the final grade is the absolute value of the difference of the operand grades. If the grade of the element resulting from a geometric product would have been greater than this difference, the inner product extinguishes it to zero. In other words, all indices must contract for the inner product to produce a non-zero value (note that if the degenerate element contracts, a zero is produced anyways). Before, we saw that the geometric product can decrease the grade in the event that indices match (which contracts the result to \\(1\\) or \\(0\\) depending). The easy way to perform a symmetric product is to perform the geometric product as normal but discard terms produced that produce the undesired grade. For example, \\(\\ee_1\\cdot \\ee_1 = 1\\) but \\(\\ee_1\\cdot \\ee_2 = 0\\) . For a more nuanced example, \\(\\ee_{12}\\cdot\\ee_{02}\\) is also \\(0\\) because the \\(1\\) index did not contract. Note that we write the symmetric inner product as \\(\\cdot\\) in equation form, but in code, it is expressed via the pipe ( | ) operator. As with the geometric product, the symmetric inner product obeys the distributive law. Here's an example mirroring an example above but using the inner product instead of the geometric product: \\[ \\begin{aligned} (4\\ee_1 - 2\\ee_{32})\\cdot (3\\ee_{012} + \\ee_{10}) &= 4\\ee_1\\cdot(3\\ee_{012} + \\ee_{10}) - 2\\ee_{32}\\cdot (3\\ee_{012} + \\ee_{10}) \\\\ &= -12 \\ee_{02} + 4\\ee_0 \\\\ &= 4\\ee_0 - 12\\ee_{02} \\end{aligned} \\] In addition, because of our \"rule\" that the inner product can only decrease grade, the inner product between any quantity and a scalar quantity must be zero. Exercises Can the symmetric inner product ever produce the pseudoscalar? Why or why not? Explain why \\(\\ee_0 \\cdot \\ee_{012}\\) is \\(0\\) and not \\(\\ee_{12}\\) . The symmetric inner product not always commutative! Provide a counterexample for the inner product between other grades. When is it commutative? The Exterior Product Info Klein API: operator^ Written as \\(a\\wedge b\\) . The exterior product (also known as the wedge product or the outer product) is similar to the geometric product except it always extinguishes results upon contraction. Thus, the result of an exterior product either has grade equal to the sum of the grades of its operands, or it is exactly zero. The exterior product is represented in equations with a \\(\\wedge\\) symbol, and in code, is represented with a caret ( ^ ) operator. The exterior product obeys the laws of distributivity as with the other products, so let's return to our familiar example: \\[ \\begin{aligned} (4\\ee_1 - 2\\ee_{32})\\wedge (3\\ee_{012} + \\ee_{10}) &= 4\\ee_1\\wedge(3\\ee_{012} + \\ee_{10}) - 2\\ee_{32}\\wedge (3\\ee_{012} + \\ee_{10}) \\\\ &= -2\\ee_{3210} \\\\ &= -2\\ee_{0123} \\end{aligned} \\] Exercises The geometric product between vectors (grade-1) is the sum of the inner product and the exterior product. Prove this by explicitly expanding out the geometric product between two general vectors. The geometric product is not generally the sum of the inner product and the exterior product. Why is that? The exterior product isn't generally anti-commutative! Find counterexamples demonstrating this fact. The Poincar\u00e9 Dual Map Info Klein API: operator! Written as \\(\\JJ(a)\\) . To perform the regressive product in the next section, we need a map that is grade-reversing . That is, we need a map that takes multivectors \\(v\\) to multivectors \\(v^*\\) such that the grade of \\(v\\) is equal to \\(4\\) minus the grade of \\(v^*\\) (and vice versa). For example, vectors should be mapped to trivectors, bivectors to bivectors, and the scalar to the pseudoscalar. In addition, this map needs to be an involution (two application of the map is the identity). Here, a map is provided but note that several such maps are possible. The nice property of the map provided here is that the application of the map is just a coordinate tuple reversal without any sign changes. The mechanism for how this basis was chosen is elegant but will be the subject of a different article. By convention, the dual map is written as \\(\\JJ\\) in expressions. \\[ \\begin{aligned} \\JJ(1) = \\ee_{0123}&,\\quad \\JJ(\\ee_{0123}) = 1 \\\\ \\JJ(\\ee_0) = \\ee_{123}&,\\quad \\JJ(\\ee_{123}) = \\ee_0 \\\\ \\JJ(\\ee_1) = \\ee_{032}&,\\quad \\JJ(\\ee_{032}) = \\ee_1 \\\\ \\JJ(\\ee_2) = \\ee_{013}&,\\quad \\JJ(\\ee_{013}) = \\ee_2 \\\\ \\JJ(\\ee_3) = \\ee_{021}&,\\quad \\JJ(\\ee_{021}) = \\ee_3 \\\\ \\JJ(\\ee_{01}) = \\ee_{23}&,\\quad \\JJ(\\ee_{23}) = \\ee_{01} \\\\ \\JJ(\\ee_{02}) = \\ee_{31}&,\\quad \\JJ(\\ee_{31}) = \\ee_{02} \\\\ \\JJ(\\ee_{03}) = \\ee_{12}&,\\quad \\JJ(\\ee_{12}) = \\ee_{03} \\end{aligned} \\] Exercises Double check that all elements in the algebra are accounted for above. The dual map is a unary operator that can be distributed across each term in a multivector sum. For example, \\(\\JJ(\\ee_1 + 2\\ee_{02}) = \\ee_{032} + 2\\ee_{31}\\) . Verify that the map is still an involution (that is, two applications of \\(\\JJ\\) should map back to the original argument). Regressive Product Info Klein API: operator& Written as \\(a\\vee b\\) . The regressive product (written as \\(\\vee\\) and expressed as the & operator in code) is defined in terms of the dual map and the exterior product like so: \\[ a \\vee b = \\JJ(\\JJ(a)\\wedge\\JJ(b)) \\] Here's a worked example of the regressive product, again using a familiar operands: \\[ \\begin{aligned} (4\\ee_1 - 2\\ee_{32})\\vee (3\\ee_{012} + \\ee_{10}) &= \\JJ(\\JJ(4\\ee_1 - 2\\ee_{32})\\wedge \\JJ(3\\ee_{012} + \\ee_{10})) \\\\ &= \\JJ((4\\ee_{032} + 2\\ee_{01}) \\wedge (-3\\ee_3 - \\ee_{23})) \\\\ &= \\JJ(-6\\ee_{013} - 2\\ee_{0123}) \\\\ &= -2 - 6\\ee_2 \\end{aligned} \\] If you're working out the example above yourself and finding some disagreement in the signs, remember that to use the dual map given above, the indices must match exactly. Thus, in this example, the dual \\(\\JJ(3\\ee_{012})\\) is \\(-\\JJ(3\\ee_{021}) = -3\\ee_3\\) . Exercises If the exterior product is zero, will the regressive product be zero? Why or why not? By the same token, if the regressive product is zero, will the exterior product be zero? Construction Planes Info kln::plane A plane \\(p\\) is the manifestation of a reflection . It is often helpful not to think of a plane as a \"set of points\" in PGA as will be evident when we look at rotations and translations later. Let's look at some simple examples first. Planes through the origin The plane represented implicitly by \\(x = 0\\) appears in PGA simply as the vector \\(\\ee_1\\) . Similarly, the planes \\(y = 0\\) and \\(3z = 0\\) correspond to \\(\\ee_2\\) and \\(3\\ee_3\\) respectively. It's easy to see that planes like \\(x + 3y - z = 0\\) can be represented by taking linear combinations of \\(\\ee_1\\) , \\(\\ee_2\\) and \\(\\ee_3\\) . In this case, the plane we just created would be represented as \\(\\ee_1 + 3\\ee_2 - \\ee_3\\) . // Plane x = 0 kln :: plane p1 { 1.f , 0.f , 0.f , 0.f }; // Plane y = 0 kln :: plane p2 { 0.f , 1.f , 0.f , 0.f }; // Plane 3z = 0 kln :: plane p3 { 0.f , 0.f , 3.f , 0.f }; // Plane x + 3y - z = 0 kln :: plane p4 { 1.f , 3.f , - 1.f , 0.f }; // Equivalent to p4 kln :: plane p5 = p1 + 3.f * p2 - p3 / 3.f ; Planes away from the origin To shift a plane from the origin, we can add a multiple of the degenerate vector \\(\\ee_0\\) . This vector is different from the other vectors in a very important way as we will see soon. The plane \\(2x + 1 = 0\\) is represented as \\(\\ee_0 + 2\\ee_1\\) . // Plane 2x + 1 = 0 kln :: plane p6 { 2.f , 0.f , 0.f , 1.f }; Other planes like to the one above can be constructed similarly. Angles between planes The angle between planes is given by the inner product which produces the cosine of the angle between them as you would expect. The planes must be normalized first for this to work, and the norm of a plane \\(p\\) can be calculated as \\(\\sqrt{p\\cdot p}\\) . Suppose we have two planes \\(p_1 = 3\\ee_0 + \\ee_1 + \\ee_3\\) and \\(p_2 = \\ee_0 + \\ee_3\\) . The first plane we recognize as \\(x + z - 3 = 0\\) , a plane parallel to the y-axis that passes through the points \\((0, y, 3)\\) and \\((3, y, 0)\\) for any value of \\(y\\) . The second plane the plane \\(z + 1 = 0\\) which is parallel to the \\(xy\\) -plane and intercepts the \\(z\\) -axis one unit below the origin. We expect the angle between these planes to be \\(\\frac{\\pi}{4}\\) radians, so let's quickly verify this with the inner product. First though, we must normalize them by dividing by the norm. This gives: \\[ \\begin{aligned} p_1 &= \\frac{3\\sqrt{2}}{2}\\ee_0 + \\frac{\\sqrt{2}}{2}\\ee_1 + \\frac{\\sqrt{2}}{2}\\ee_3 \\\\ p_2 &= \\ee_0 + \\ee_3 \\end{aligned} \\] Remember that when computing the norm, because \\(\\ee_0^2 = 0\\) , the \\(\\ee_0\\) component does not participate in the computaiton. The angle between them is then computed as: \\[ \\begin{aligned} p_1 \\cdot p_2 &= \\left(\\frac{3\\sqrt{2}}{2}\\ee_0 + \\frac{\\sqrt{2}}{2}\\ee_1 + \\frac{\\sqrt{2}}{2}\\ee_3\\right) \\cdot (\\ee_0 + \\ee_3) \\\\ &= \\frac{\\sqrt{2}}{2}\\ee_3\\cdot\\ee_3 \\\\ &= \\frac{\\sqrt{2}}{2} \\end{aligned} \\] indicating that the angle between \\(p_1\\) and \\(p_2\\) is \\(\\cos^{-1}{\\frac{\\sqrt{2}}{2}} = \\frac{\\pi}{4}\\) radians. The Klein code to compute the angle between planes is shown below: float plane_angle_rad ( kln :: plane p1 , kln :: plane p2 ) { p1 . normalize (); // Normalizes p1 in place p2 . normalize (); // Normalizes p2 in place return std :: acos (( p1 | p2 ). scalar ()); } Exercises The angle calculation above is a great example to demonstrate why the degenerate element \\(\\ee_0\\) is so important. Consider what would have happened if instead \\(\\ee_0 \\cdot \\ee_0 \\neq 0\\) . Now, suppose we made the \"choice\" of representing planes with trivector coordinates instead of vector coordinates. Repeat the above calculation using the duals of each plane. Does the computation still work? Lines Info kln::line Intersecting planes to create lines The \"meet\" operation in \\(\\PGA\\) is defined in terms of the exterior product ( \\(\\wedge\\) ). Given two planes, \\(p_1 = 3\\ee_0 + \\ee_1 + \\ee_3\\) and \\(p_2 = \\ee_0 + \\ee_3\\) , we can compute the exterior product like so: \\[ \\begin{aligned} p_1\\wedge p_2 &= (3\\ee_0 + \\ee_1 + \\ee_3) \\wedge (\\ee_0 + \\ee_3) \\\\ &= 3\\ee_{03} + \\ee_{10} + \\ee_{13} + \\ee_{30} \\\\ &= -\\ee_{01} + 2\\ee_{03} - \\ee_{31} \\end{aligned} \\] How can we verify that this is correct? Well, let's first try to calculate the equation of this line using more traditional means. In classical Euclidean geometry, the six degrees of freedom of a line are often represented using Pl\u00fccker coordinates. Let's express our planes using the implicit equation form: \\[ \\begin{aligned} 0 &= 3 + x + z \\\\ 0 &= 1 + z \\end{aligned} \\] The Pl\u00fccker displacement is determined by the cross product of the plane normals, which in this case is the cross product \\((\\mathbf{i} + \\mathbf{k})\\times\\mathbf{k} = \\mathbf{i}\\times\\mathbf{k} = -\\mathbf{j}\\) . Meanwhile, the Pl\u00fccker moment of the line is given as \\(3\\mathbf{k} - (\\mathbf{i} + \\mathbf{k}) = -\\mathbf{i} + 2\\mathbf{k}\\) . Putting it together, the Pl\u00fccker coordinate tuple of our line is \\((d_1:d_2:d_3:m_1:m_2:m_3) = (0: -1: 0:-1:0:2)\\) , in exact accordance with the calculation above. Observe that the coordinates associated with \\(\\ee_{21}\\) , \\(\\ee_{13}\\) , and \\(\\ee_{32}\\) capture the information about the orientation of the line, while the coordinates associated with \\(\\ee_{01}\\) , \\(\\ee_{02}\\) , and \\(\\ee_{03}\\) work in tandem to impart a translational element as well. What happens if the planes are parallel? Let's try our meet between planes \\(-2\\ee_0 + 2\\ee_1\\) and \\(\\ee_1\\) to see what happens. \\[ (-2\\ee_0 + 2\\ee_1) \\wedge \\ee_1 = -2\\ee_{01} \\] We ended up with a bivector all the same! Quantities that have no direction components like the above are referred to as ideal lines , also known as lines at infinity . What's important about concepts like lines and points at infinity is that their existence allows our algebra to have closure without needing to introduce vague notions of \\(\\infty\\) . Another way to word this is to say that planes always intersect, even when parallel, and the algebra does not need to make any special exceptions for them. Furthermore, these entities at infinity have uses! We'll see later that rotations about ideal lines can be used to generate translations. The code that produces the line above is the following snippet: // plane 1: 3 + x + z = 0; kln :: plane p1 { 1.f , 0.f , 1.f , 3.f }; // plane 2: 1 + z = 0; kln :: plane p2 { 0.f , 0.f , 1.f , 1.f }; // line intersection of planes 1 and 2 kln :: line intersection = p1 ^ p2 ; Exercises Match up the Pl\u00fccker coordinates above with the coefficients of the meet operation above. Do you see how the element indices matter in determining the sign? Lines at infinity have 3 degrees of freedom. Is there an analogous plane at infinity? How many degrees of freedom does it have? What happens when you evaluate \\(p_2\\wedge p_1\\) instead of \\(p_1\\wedge p_2\\) ? Is the change justified? Points Info kln::point Meet a line and a plane With the same meet operation ( \\(\\wedge\\) ) we used to intersect two planes to construct a line, we can intersect a line and a plane to construct a point. Let's use the line \\(\\ell = -\\ee_{01} + 2\\ee_{03} - \\ee_{31}\\) from the previous example and the plane \\(\\ee_1 + \\ee_2\\) . \\[ \\begin{aligned} (-\\ee_{01} + 2\\ee_{03} - \\ee_{31}) \\wedge (\\ee_1 + \\ee_2) &= -\\ee_{012} + 2\\ee_{031} + 2\\ee_{032} - \\ee_{312}\\\\ &= -\\ee_{123} + 2\\ee_{032} + 2\\ee_{031} + \\ee_{021} \\\\ &\\rightarrow \\;\\; \\ee_{123} - 2\\ee_{032} + 2\\ee_{013} - \\ee_{021} \\end{aligned} \\] In the last step, we divided the expression by \\(-1\\) so that the weight of \\(\\ee_{123}\\) is exactly one. For points, this weight is the homogeneous coordinate, and when it is unity, there is a direct association between the point's Cartesian coordinates and the other trivector weights. For \\(\\PGA\\) , given a normalized point with \\(\\ee_{123}\\) weight \\(1\\) , the \\(x\\) coordinate is the weight of the \\(\\ee_{032}\\) trivector, the \\(y\\) coordinate is the weight of the \\(\\ee_{013}\\) trivector, and the \\(z\\) coordinate is the weight of the \\(\\ee_{021}\\) trivector. Projective equivalence In projective geometry, all geometric entities (planes, lines, points) exhibit a property known as projective equivalence. For any such entity \\(X\\) , the entity \\(aX\\) represents the same entity for any non-zero real scalar \\(a\\) . To compare weights from one entity to another meaningfully however, we tend to use this projective equivalence to keep things normalized in the same way. For example, it doesn't make sense to compare the \\(\\ee_{021}\\) weight (the \\(z\\) -coordinate) between two points unless they are both normalized in the same manner. In this case, the trivector is associated with the point at \\((-2, 2, -1)\\) . How can we verify that this point is the intersection we're seeking? Let's represent our plane and line as a system of equations. Recalling that \\(\\ell\\) was constructed as the intersection from two planes from before, this means that we can form the following system of three equations: \\[ \\begin{aligned} 0 &= 3 + x + z \\\\ 0 &= 1 + z \\\\ 0 &= x + y \\end{aligned} \\] Subtracting the second equation from the first yields \\(x = -2\\) . Substituting in the third equation yields \\(y = 2\\) . Finally, the second equation immediately gives \\(z = -1\\) . In code, the intersection of the plane and the line to construct a point can be done as follows: kln :: line l ( - 1.f , 0.f , 2.f , 0.f , - 1.f , 0.f ); kln :: plane p { 0.f , 1.f , 1.f , 0.f }; kln :: point intersection = l ^ p ; Exercises As mentioned previously, the exterior product is only anticommutative in certain situations. This isn't one of them! In fact, it would be somewhat concerning if the point intersection depended on the order \\(\\ell \\wedge p\\) vs \\(p \\wedge \\ell\\) . Evaluate \\(p \\wedge \\ell\\) for the above example and verify that you get the same result. Seeing points as trivectors might feel a bit confusing at first. This isn't so much an exercise, but a request for you, the reader, to reserve any doubts that the representation makes sense until we look at the geometric product in view of symmetric actions. Here, we met a line and a plane to get the point of intersection point. Three planes can be met with the same operator \\(\\wedge\\) to produce the intersection point as well. Can you see why? Joins In the constructions above, we used the exterior product to meet entities to elegantly construct intersections. The \\(\\wedge\\) operator is a grade-increasing operation that allowed us to go from planes to lines to points. What about going the other direction? Well, there's a handy tool for that! Earlier, we learned about the Regressive Product , defined in terms of the exterior product on the duals of the operands. As a result, it should be evident that the regressive product is a grade decreasing operation that allows us to join entities to go in the other direction, from points to lines to planes. Sure enough, this works exactly as you'd expect. Two points can be joined to construct a line, and a line and a point (or equivalently three points) can be joined to create a plane. Here's a code snippet doing exactly this. kln :: point p1 { x1 , y1 , z1 }; kln :: point p2 { x2 , y2 , z2 }; kln :: line p1_to_p2 = p1 & p2 ; kln :: point p3 { x3 , y3 , z3 }; /// Equivalent to p1 & p2 & p3; kln :: plane p1_p2_p3 = p1_to_p2 & p3 ; Exercises Try to perform the computation above by hand given sufficiently simple initialization values of the three points. Do the results agree with what you expect? Explain why the Poincar\u00e9 dual map we introduced earlier needed to be an involution for our join to work so conveniently. Projection, Rejection, Containment A common question is how to compute whether a point lies on a line or plane, or whether a line lies on a plane. When examining the implicit forms of lines and planes, the answer is obvious. For example, given a plane \\(0 = ax + by + cz + d\\) , points that lie on the plane are simply coordinate tuples that satisfy the implicit equation. In GA, coordinates are \"substituted\" in this manner, and we need a way to express projection/rejection/containment in terms of the algebraic operations available to us. The key is to use the symmetric inner product to perform metric \"measurements\". Let's consider the various cases separately. Point to plane Let's consider a point \\(P = \\ee_{123} + 2\\ee_{032} + \\ee_{013}\\) and a plane \\(p = 3\\ee_0 + \\ee_1\\) . The inner product between them is computed as: \\[ \\begin{aligned} P \\cdot p &= (\\ee_{123} + 2\\ee_{032} + \\ee_{013}) \\cdot (3\\ee_0 + \\ee_1) \\\\ &= \\ee_{23} - \\ee_{03} \\end{aligned} \\] This is the line perpendicular to the plane through the point. A way to intuitively see why this is so is to observe the fact that the inner product contracts indices, leaving only the parts that are not in common between the two. As a result, not only does the inner product produce a bivector, each corresponding term in the bivector produced contains indices not present in the plane. Can we now compute the distance between the point and the plane? The answer is no . Notice how in the above expression, the weight of \\(\\ee_0\\) of the plane didn't participate in the calculation at all. This means that translating the plane towards or away from the origin doesn't effect its inner product with a point, indicating that the line cannot be used to compute the distance between a point and a plane. Note that whether or not the plane was normalized made no difference. Before continuing, let's quickly see what would have happened if we computed \\(p \\cdot P\\) instead of \\(P \\cdot p\\) . \\[ \\begin{aligned} p \\cdot P &= (3\\ee_0 + \\ee_1) \\cdot (\\ee_{123} + 2\\ee_{032} + \\ee_{013}) \\\\ &= \\ee_{23} - \\ee_{03} \\end{aligned} \\] Conveniently, the results match! Exercises Can you justify the equality between \\(p\\cdot P\\) and \\(P \\cdot p\\) ? In the example above, the line produced by the inner product has a translational component. Where did that component come from? Can you see how the translational component of the produced line changes when we shift the position of the point? To compute the distance from the point to the plane, we need to use an operator that doesn't annihilate the translational component of the plane. The answer is to use the either the join ( \\(\\vee\\) ) or meet ( \\(\\wedge\\) ) operator to construct the metric-free quantity from which we can extract the distance by inspecting the magnitudes. Let's compute both to see what we come up with: \\[ \\begin{aligned} P \\wedge p &= (\\ee_{123} + 2\\ee_{032} + \\ee_{013}) \\wedge (3\\ee_0 + \\ee_1) \\\\ &= -3\\ee_{0123} - 2\\ee_{0123} \\\\ &= -5\\ee_{0123} \\end{aligned} \\] \\[ \\begin{aligned} P \\vee p &= (\\ee_{123} + 2\\ee_{032} + \\ee_{013}) \\vee (3\\ee_0 + \\ee_1) \\\\ &= \\JJ\\left((\\ee_0 + 2\\ee_1 + \\ee_2) \\wedge (3\\ee_{123} + \\ee_{032})\\right) \\\\ &= \\JJ\\left(3\\ee_{0123} + 2\\ee_{0123}\\right) \\\\ &= \\JJ\\left(5 \\ee_{0123}\\right) \\\\ &= 5 \\end{aligned} \\] The ideal norm (norm computed with only elements containing subscript \\(0\\) ) of the meet matches the norm of the join which encodes the distance from the point to the plane. As an equation, we'd express the ideal norm as \\(||P\\wedge p||_\\infty\\) . Let's check if this is right! The plane \\(p\\) corresponds to \\(0 = x + 3\\) and the point \\(P\\) corresponds to the coordinate tuple \\((2, 1, 0)\\) . The point-to-plane distance formula tells us that the distance between \\(P\\) and \\(p\\) is, in fact, \\(5\\) , in agreement with our point-plane meet and join calculation. To understand why this works, pay attention to which terms survived the meet and the join. The point's homogeneous component paired with the plane's translational component, and all the plane's direction components paired with the point's positional components. Geometrically, we've projected the point onto the normal direction of the plane and subsequently taken the norm which included the plane's translation from the origin. To compute this distance in Klein, given a point P and plane p , we'd simply do std::abs((p ^ P).e0123()) . Alternatively, we could do std::abs((p & P).scalar()) . Of course, you must normalize the plane with p.normalize() for this computation to work. Exercises The above computation worked because the plane \\(p\\) was normalized such that \\(p^2 = 1\\) . Change the normalization factor or change \\(p\\) itself and verify that normalization is required for the distance measure above to work. Considering the meet and join operators, does it make sense that the meet and join of a point and plane produced the pseudoscalar and scalar respectively? What about the line perpendicular to the plane through the point \\(P\\cdot p\\) ? It can't be used to measure the distance to the plane as we pointed out before, but it can be used to project the point to the plane. The succinct formula for this projection is \\((p \\cdot P)P\\) . \\[ \\begin{aligned} (p\\cdot P)P &= (\\ee_{23} - \\ee_{03})(3\\ee_0 + \\ee_1) \\\\ &= 3\\ee_{023} + \\ee_{123} - \\ee_{031} \\\\ &= \\ee_{123} - 3\\ee_{032} + \\ee_{013} \\end{aligned} \\] which corresponds to the point \\((-3, 1, 0)\\) . That this point lies on the plane is immediate. Also, this point is \\(5\\) units away from \\(P\\) and the line between them is parallel to the \\(x\\) axis, indicating that we have indeed projected the point to the plane. Klein code that computes this projection is shown below: kln :: plane p { 1 , 0 , 0 , 3 }; kln :: point P { 2 , 0 , 1 }; kln :: point P_on_p {( p | P ) * p }; // Equivalent to (P|p) * p Line to plane Another potential projection we should consider is projecting a line to a plane. Without proof, the equation projecting \\(\\ell\\) onto \\(p\\) is \\((p\\cdot \\ell)p\\) . Before trying this out, let's check the dimensionality first. The expression \\(p\\cdot\\ell\\) will produce a vector quantity, but the geometric product of two vectors doesn't necessarily produce a bivector (there could be scalar components). The \"trick\" is to realize that because the inner product contracts all subscripts, the vector produced by \\(p\\cdot \\ell\\) will be completely orthogonal to both \\(\\ell\\) and \\(p\\) , so we are justified in claiming that the final result \\((p\\cdot \\ell)p\\) is a bivector, meaning that this formula does, in fact, produce a line. Let's consider the line \\(\\ell = \\ee_{32} + \\ee_{13}\\) (you should recognize this line as a line through the origin between the \\(x\\) and \\(y\\) axes). The projection onto the plane \\(p = 3\\ee_0 + \\ee_1\\) should clearly be the \\(y\\) axis shifted \\(3\\) units so let's verify that this is the case: \\[ \\begin{aligned} (p \\cdot \\ell)p &= \\left((3\\ee_0 + \\ee_1)\\cdot(\\ee_{32} + \\ee_{13})\\right) p \\\\ &= \\ee_{3}(3\\ee_0 + \\ee_1) \\\\ &= -3\\ee_{03} - \\ee_{13} \\end{aligned} \\] At first glance, this doesn't seem like the line that we want, but we must remember that projectively, the lines \\(3\\ee_{03} + \\ee_{13}\\) and \\(-3\\ee_{03} - \\ee_{13}\\) are projectively equivalent. In Klein, we can produce this projection as follows: kln :: plane p { 1 , 0 , 0 , 3 }; kln :: branch l { 1 , 1 , 0 }; // A branch is a line through the origin // This calculation works the same with `kln::line l{0, 0, 0, 1, 1, 0}` but // is more efficient using a branch since a branch uses half the storage. kln :: line l_on_p {( p | l ) * p }; Exercies Repeat the projection above using \\((\\ell \\cdot p)p\\) instead of \\((p\\cdot \\ell)p\\) . You should find that you get a negated result that remains projectively equivalent. Point to line With the point and a line, two reasonable questions to ask are, as with the plane, how to compute the distance to the line, and how to project the point onto the line. Before continuing, guess what the formulae should be! Guess! Then click to reveal spoilers If you thought the distance between the point and the line is \\(||P\\vee \\ell||\\) and the projection is \\((P\\cdot \\ell)\\ell\\) , you'd be right! The uniformity between this equation and all the others we've seen should be quite satisfying. Note that the point must be normalized so that the weight of \\(\\ee_{123} = 1\\) and the line must be normalized so that the square norm of the directional components is unity for these formulae to work. In Klein, given a point P and line l , the projection is kln::point P_on_l{(P|l) * l} as you would expect. The projection is somewhat straightforward, but perhaps the distance formula may take some additional processing. First, let's consider the join \\(P\\vee\\ell\\) . What type of quantity does this produce? Well, from the section detailing the regressive product above, we know that his is a plane containing both the point and the line. It turns out that the norm of this plane will encode the distance between the point and the line. Let's see how this works for the line \\(\\ell = \\ee_{02} + \\ee_{23}\\) and point \\(P = \\ee_{123} + \\ee_{013} + \\ee_{021}\\) (we expect the distance to be \\(1\\) ). \\[ \\begin{aligned} ||P\\vee \\ell|| &= ||(\\ee_{123} + \\ee_{013} + \\ee_{021})\\vee (\\ee_{02} + \\ee_{23})|| \\\\ &= ||\\JJ\\left((\\ee_0 + \\ee_2 + \\ee_3)\\wedge(\\ee_{31} + \\ee_{01})\\right)|| \\\\ &= ||\\JJ\\left(-\\ee_{013} -\\ee_{021} + \\ee_{123} + \\ee_{013}\\right)|| \\\\ &= ||\\JJ\\left(-\\ee_{021} + \\ee_{123}\\right)|| \\\\ &= ||-\\ee_3 + \\ee_0|| \\\\ &= 1 \\end{aligned} \\] If you have trouble remembering how lines are defined, remember that terms containing a \\(0\\) in the subscript are translational components (the moment of the line) and the remaining terms determine the line's direction. The line \\(\\ee_{02} + \\ee_{23}\\) can be decomposed as the meet of two planes \\(\\ee_0 - \\ee_3\\) and \\(\\ee_2\\) so we can intuit that the line is the \\(x\\) axis shifted a unit in the \\(+z\\) direction. The norm of a point is just the homogeneous coordinate. Code computing the distance between a point and a line looks like: kln :: line l { 0 , 1 , 0 , 1 , 0 , 0 }; kln :: point p { 0 , 1 , 1 }; float distance = kln :: plane { l & p }. norm (); For completeness, we can project the point on the line with the following snippet: kln :: line l { 0 , 1 , 0 , 1 , 0 , 0 }; kln :: point p { 0 , 1 , 1 }; // Note that for this calculation to work, if the line l and point p were // not normalized, we would need to invoke l.normalize() and p.normalize() // first before proceeding. kln :: point p_on_l {( p | l ) * p }; Exercises The weight of \\(\\ee_{013}\\) in the point above should correspond directly with its distance from the line. Verify that this is so. Try shifting the point in a different direction (say along \\(x\\) ). Does the distance stay unaffected as you'd expect? What about shifting the point in the \\(z\\) direction? Reflections So far, we've seen how the exterior product and regressive product can be used to construct planes, lines, and points. We also saw how the symmetric inner product can be used to measure angles between planes. Furthermore, we used the ideal norm in conjunction with the exterior and regressive products to compute distances between entities. Already, \\(\\PGA\\) has yielded many fruitful results which has consequently led to a compact and elegant API. However, we haven't yet encountered a primary usage of the geometric product, and this is where we'll fully appreciate the decision of using the representation we have. Reflection through a plane A reflection of an entity \\(X\\) through a plane \\(p\\) is given by \\(pXp\\) . This is true regardless of whether \\(X\\) is another plane, a line, or a point! ARTICLE CURRENTLY BEING DRAFTED","title":"Geometry Potpourri"},{"location":"geometry-potpourri/#multivectors","text":"Info Klein API: kln::entity In this section, we look at all the various operations and elements that show up in \\(\\PGA\\) . A common question that people run into when getting exposed to GA for the first time is, \"why are their so many operations?\" The best answer is that, well, geometry has a lot of operations! More than can be captured easily with just the dot product and cross product you're likely familiar with. This section just gets you acquainted with the mechanics of \\(\\PGA\\) , but to glean more geometric intuition, all the sections afteward will focus on concrete examples (plane distance to point, meeting to points to make a line, projecting a line onto a plane, rotating a point about a line, reflecting a point through a plane, etc). You'll find that for a bit of upfront complexity presented here, what's gained is a satisfying degree of uniformity in all the geometry that comes later.","title":"Multivectors"},{"location":"geometry-potpourri/#pga-basis-and-geometric-product","text":"Info Klein API: operator* Written as two elements adjacent to each other ( \\(ab\\) ). Let's get used to some basis elements and operations first. In \\(\\mathbf{P}(\\mathbb{R}^*_{3, 0, 1})\\) (also known as PGA), we have four grade-1 vector basis elements, \\(\\ee_0\\) , \\(\\ee_1\\) , \\(\\ee_2\\) , and \\(\\ee_3\\) . Let's define the square of these vectors in the following manner. The first element squares to \\(0\\) ( \\(\\ee_0 \\ee_0 = 0\\) ) while the latter 3 elements square to \\(1\\) ( \\(\\ee_1\\ee_1 = \\ee_2\\ee_2 = \\ee_3\\ee_3 = 1\\) ). As we now immediately have a means to create \\(1\\) , we can generate all the numbers this way, so let's declare \\(1\\) as our grade-0 basis element. Grade? Very non-mathematically, the \"grade\" of an element is the number of subscripts it possesses. Soon, you should get a good feel of what grades result from what operations, and what information the grades present in a multivector quantity conveys. When we write elements adjacent to one another as in \\(\\ee_1\\ee_1\\) , the operation being represented here is the geometric product . In code, the geometric product is expressed as the multiplication ( * ) operator. So far, we've written down what the geometric product does when the elements multiply against themselves. Next, we need to describe what happens when we take the geometric product between different elements. Mixed products of the basis vectors produce the basis bivectors, which can themselves be used in linear combinations to produce general bivectors. Bivectors that can be written as the product of two vectors may be referred to as blades or simple bivectors . The products between basis vectors are all blades by definition. As shorthand, we combine subscripts as shown below: \\[ \\begin{aligned} \\ee_1\\ee_0 &= \\ee_{10} \\\\ \\ee_1\\ee_2 &= \\ee_{12} \\\\ \\ee_3\\ee_0 &= \\ee_{30} \\\\ &\\dots \\end{aligned} \\] At the moment, we would have \\(4\\times 3 = 12\\) basis bivectors if defined this way, but we impose a relation on them that relates basis bivectors that contain the same subscripts. Namely, the product of two vectors is minus the product of the two vectors with the order interchanged. \\[ \\begin{aligned} \\ee_{01} &= -\\ee_{10} \\\\ \\ee_{02} &= -\\ee_{20} \\\\ \\ee_{03} &= -\\ee_{30} \\\\ \\ee_{12} &= -\\ee_{21} \\\\ \\ee_{31} &= -\\ee_{13} \\\\ \\ee_{23} &= -\\ee_{32} \\tag{1} \\end{aligned} \\] For reasons that will become clear in a future writeup, we'll select the blades on the left hand side of \\((1)\\) to be the canonical 2-blades in PGA. There is some choice index order selection as will be explained later, but the order here is used to match existing literature and so that computations later are made more convenient. Now that we know we can swap the order of the multiplication by basis vectors by introducing a sign, we can compute things like \\(\\ee_{01}\\ee_0\\) . \\[ \\begin{aligned} \\ee_{01}\\ee_0 &= \\ee_0\\ee_1\\ee_0 \\\\ &= -\\ee_0\\ee_0\\ee_1 \\\\ &= 0 \\end{aligned} \\] Another example (that doesn't vanish): \\[ \\begin{aligned} \\ee_{20}\\ee_2 &= \\ee_2\\ee_0\\ee_2 \\\\ &= -\\ee_2\\ee_2\\ee_0 \\\\ &= -\\ee_0 \\end{aligned} \\] The same algorithm can be used to produce the 4 trivectors: \\[ \\begin{aligned} \\ee_{123} &= \\ee_{12}\\ee_3 = -\\ee_{132} = \\ee_{312} \\\\ \\ee_{021} &= \\ee_{02}\\ee_1 = -\\ee_{201} = \\ee_{210} \\\\ \\ee_{013} &= \\ee_{01}\\ee_3 = -\\ee_{031} = \\ee_{301} \\\\ \\ee_{032} &= \\ee_{03}\\ee_2 = -\\ee_{302} = \\ee_{320} \\end{aligned} \\] Not all permutations were listed, but just a few so you can gain familiarity with swapping indices and introducing signs or removing them as ncessary. The last element we haven't touched on is the pseudoscalar \\(\\ee_{0123}\\) . The pseudoscalar is so named because while it does not have grade zero, it is uniquely identified within its grade to within a permutation of its indices (compared to, say, the grade-2 elements of which there are six distinct members). Note that there is no way in which we can introduce an element with grade higher than this, and so our \\(16\\) algebra elements (1 scalar, 4 vector, 6 bivector, 4 trivector, and 1 pseudoscalar) are fully described. Linear combinations can be made from all of these elements to produce a general multivector. To take the geometric product between general multivectors, we leverage the fact that the geometric product obeys the distributive law. \\[ \\begin{aligned} (4\\ee_1 - 2\\ee_{32})(3\\ee_{012} + \\ee_{10}) &= 4\\ee_1(3\\ee_{012} + \\ee_{10}) - 2\\ee_{32}(3\\ee_{012} + \\ee_{10}) \\\\ &= 12\\ee_1\\ee_{012} + 4\\ee_1\\ee_{10} - 6\\ee_{32}\\ee_{012} - 2\\ee_{32}\\ee_{10} \\\\ &= -12\\ee_{02} + 4\\ee_0 - 6\\ee_{301} - 2\\ee_{3210} \\\\ &= 4\\ee_0 - 12\\ee_{02} - 6\\ee_{013} - 2\\ee_{0123} \\end{aligned} \\] In the last step, we simply took the time to sort the resulting terms by grade and also performed swaps as necessary to write terms with the canonical subscript ordering. Exercises Write down two vectors whose product is \\(-\\ee_{01} + 2\\ee_{13}\\) . The geometric product is neither commutative, nor anticommutative. Find examples that demonstrate this fact. Not every bivector can be written down as the product of two vectors. Find an example that demonstrates this fact.","title":"PGA Basis and Geometric Product"},{"location":"geometry-potpourri/#the-symmetric-inner-product","text":"Info Klein API: operator| Written as \\(a \\cdot b\\) . The symmetric inner product (inner product for short) is a bilinear binary operation like the geometric product except it is always grade decreasing such that the final grade is the absolute value of the difference of the operand grades. If the grade of the element resulting from a geometric product would have been greater than this difference, the inner product extinguishes it to zero. In other words, all indices must contract for the inner product to produce a non-zero value (note that if the degenerate element contracts, a zero is produced anyways). Before, we saw that the geometric product can decrease the grade in the event that indices match (which contracts the result to \\(1\\) or \\(0\\) depending). The easy way to perform a symmetric product is to perform the geometric product as normal but discard terms produced that produce the undesired grade. For example, \\(\\ee_1\\cdot \\ee_1 = 1\\) but \\(\\ee_1\\cdot \\ee_2 = 0\\) . For a more nuanced example, \\(\\ee_{12}\\cdot\\ee_{02}\\) is also \\(0\\) because the \\(1\\) index did not contract. Note that we write the symmetric inner product as \\(\\cdot\\) in equation form, but in code, it is expressed via the pipe ( | ) operator. As with the geometric product, the symmetric inner product obeys the distributive law. Here's an example mirroring an example above but using the inner product instead of the geometric product: \\[ \\begin{aligned} (4\\ee_1 - 2\\ee_{32})\\cdot (3\\ee_{012} + \\ee_{10}) &= 4\\ee_1\\cdot(3\\ee_{012} + \\ee_{10}) - 2\\ee_{32}\\cdot (3\\ee_{012} + \\ee_{10}) \\\\ &= -12 \\ee_{02} + 4\\ee_0 \\\\ &= 4\\ee_0 - 12\\ee_{02} \\end{aligned} \\] In addition, because of our \"rule\" that the inner product can only decrease grade, the inner product between any quantity and a scalar quantity must be zero. Exercises Can the symmetric inner product ever produce the pseudoscalar? Why or why not? Explain why \\(\\ee_0 \\cdot \\ee_{012}\\) is \\(0\\) and not \\(\\ee_{12}\\) . The symmetric inner product not always commutative! Provide a counterexample for the inner product between other grades. When is it commutative?","title":"The Symmetric Inner Product"},{"location":"geometry-potpourri/#the-exterior-product","text":"Info Klein API: operator^ Written as \\(a\\wedge b\\) . The exterior product (also known as the wedge product or the outer product) is similar to the geometric product except it always extinguishes results upon contraction. Thus, the result of an exterior product either has grade equal to the sum of the grades of its operands, or it is exactly zero. The exterior product is represented in equations with a \\(\\wedge\\) symbol, and in code, is represented with a caret ( ^ ) operator. The exterior product obeys the laws of distributivity as with the other products, so let's return to our familiar example: \\[ \\begin{aligned} (4\\ee_1 - 2\\ee_{32})\\wedge (3\\ee_{012} + \\ee_{10}) &= 4\\ee_1\\wedge(3\\ee_{012} + \\ee_{10}) - 2\\ee_{32}\\wedge (3\\ee_{012} + \\ee_{10}) \\\\ &= -2\\ee_{3210} \\\\ &= -2\\ee_{0123} \\end{aligned} \\] Exercises The geometric product between vectors (grade-1) is the sum of the inner product and the exterior product. Prove this by explicitly expanding out the geometric product between two general vectors. The geometric product is not generally the sum of the inner product and the exterior product. Why is that? The exterior product isn't generally anti-commutative! Find counterexamples demonstrating this fact.","title":"The Exterior Product"},{"location":"geometry-potpourri/#the-poincare-dual-map","text":"Info Klein API: operator! Written as \\(\\JJ(a)\\) . To perform the regressive product in the next section, we need a map that is grade-reversing . That is, we need a map that takes multivectors \\(v\\) to multivectors \\(v^*\\) such that the grade of \\(v\\) is equal to \\(4\\) minus the grade of \\(v^*\\) (and vice versa). For example, vectors should be mapped to trivectors, bivectors to bivectors, and the scalar to the pseudoscalar. In addition, this map needs to be an involution (two application of the map is the identity). Here, a map is provided but note that several such maps are possible. The nice property of the map provided here is that the application of the map is just a coordinate tuple reversal without any sign changes. The mechanism for how this basis was chosen is elegant but will be the subject of a different article. By convention, the dual map is written as \\(\\JJ\\) in expressions. \\[ \\begin{aligned} \\JJ(1) = \\ee_{0123}&,\\quad \\JJ(\\ee_{0123}) = 1 \\\\ \\JJ(\\ee_0) = \\ee_{123}&,\\quad \\JJ(\\ee_{123}) = \\ee_0 \\\\ \\JJ(\\ee_1) = \\ee_{032}&,\\quad \\JJ(\\ee_{032}) = \\ee_1 \\\\ \\JJ(\\ee_2) = \\ee_{013}&,\\quad \\JJ(\\ee_{013}) = \\ee_2 \\\\ \\JJ(\\ee_3) = \\ee_{021}&,\\quad \\JJ(\\ee_{021}) = \\ee_3 \\\\ \\JJ(\\ee_{01}) = \\ee_{23}&,\\quad \\JJ(\\ee_{23}) = \\ee_{01} \\\\ \\JJ(\\ee_{02}) = \\ee_{31}&,\\quad \\JJ(\\ee_{31}) = \\ee_{02} \\\\ \\JJ(\\ee_{03}) = \\ee_{12}&,\\quad \\JJ(\\ee_{12}) = \\ee_{03} \\end{aligned} \\] Exercises Double check that all elements in the algebra are accounted for above. The dual map is a unary operator that can be distributed across each term in a multivector sum. For example, \\(\\JJ(\\ee_1 + 2\\ee_{02}) = \\ee_{032} + 2\\ee_{31}\\) . Verify that the map is still an involution (that is, two applications of \\(\\JJ\\) should map back to the original argument).","title":"The Poincar\u00e9 Dual Map"},{"location":"geometry-potpourri/#regressive-product","text":"Info Klein API: operator& Written as \\(a\\vee b\\) . The regressive product (written as \\(\\vee\\) and expressed as the & operator in code) is defined in terms of the dual map and the exterior product like so: \\[ a \\vee b = \\JJ(\\JJ(a)\\wedge\\JJ(b)) \\] Here's a worked example of the regressive product, again using a familiar operands: \\[ \\begin{aligned} (4\\ee_1 - 2\\ee_{32})\\vee (3\\ee_{012} + \\ee_{10}) &= \\JJ(\\JJ(4\\ee_1 - 2\\ee_{32})\\wedge \\JJ(3\\ee_{012} + \\ee_{10})) \\\\ &= \\JJ((4\\ee_{032} + 2\\ee_{01}) \\wedge (-3\\ee_3 - \\ee_{23})) \\\\ &= \\JJ(-6\\ee_{013} - 2\\ee_{0123}) \\\\ &= -2 - 6\\ee_2 \\end{aligned} \\] If you're working out the example above yourself and finding some disagreement in the signs, remember that to use the dual map given above, the indices must match exactly. Thus, in this example, the dual \\(\\JJ(3\\ee_{012})\\) is \\(-\\JJ(3\\ee_{021}) = -3\\ee_3\\) . Exercises If the exterior product is zero, will the regressive product be zero? Why or why not? By the same token, if the regressive product is zero, will the exterior product be zero?","title":"Regressive Product"},{"location":"geometry-potpourri/#construction","text":"","title":"Construction"},{"location":"geometry-potpourri/#planes","text":"Info kln::plane A plane \\(p\\) is the manifestation of a reflection . It is often helpful not to think of a plane as a \"set of points\" in PGA as will be evident when we look at rotations and translations later. Let's look at some simple examples first.","title":"Planes"},{"location":"geometry-potpourri/#planes-through-the-origin","text":"The plane represented implicitly by \\(x = 0\\) appears in PGA simply as the vector \\(\\ee_1\\) . Similarly, the planes \\(y = 0\\) and \\(3z = 0\\) correspond to \\(\\ee_2\\) and \\(3\\ee_3\\) respectively. It's easy to see that planes like \\(x + 3y - z = 0\\) can be represented by taking linear combinations of \\(\\ee_1\\) , \\(\\ee_2\\) and \\(\\ee_3\\) . In this case, the plane we just created would be represented as \\(\\ee_1 + 3\\ee_2 - \\ee_3\\) . // Plane x = 0 kln :: plane p1 { 1.f , 0.f , 0.f , 0.f }; // Plane y = 0 kln :: plane p2 { 0.f , 1.f , 0.f , 0.f }; // Plane 3z = 0 kln :: plane p3 { 0.f , 0.f , 3.f , 0.f }; // Plane x + 3y - z = 0 kln :: plane p4 { 1.f , 3.f , - 1.f , 0.f }; // Equivalent to p4 kln :: plane p5 = p1 + 3.f * p2 - p3 / 3.f ;","title":"Planes through the origin"},{"location":"geometry-potpourri/#planes-away-from-the-origin","text":"To shift a plane from the origin, we can add a multiple of the degenerate vector \\(\\ee_0\\) . This vector is different from the other vectors in a very important way as we will see soon. The plane \\(2x + 1 = 0\\) is represented as \\(\\ee_0 + 2\\ee_1\\) . // Plane 2x + 1 = 0 kln :: plane p6 { 2.f , 0.f , 0.f , 1.f }; Other planes like to the one above can be constructed similarly.","title":"Planes away from the origin"},{"location":"geometry-potpourri/#angles-between-planes","text":"The angle between planes is given by the inner product which produces the cosine of the angle between them as you would expect. The planes must be normalized first for this to work, and the norm of a plane \\(p\\) can be calculated as \\(\\sqrt{p\\cdot p}\\) . Suppose we have two planes \\(p_1 = 3\\ee_0 + \\ee_1 + \\ee_3\\) and \\(p_2 = \\ee_0 + \\ee_3\\) . The first plane we recognize as \\(x + z - 3 = 0\\) , a plane parallel to the y-axis that passes through the points \\((0, y, 3)\\) and \\((3, y, 0)\\) for any value of \\(y\\) . The second plane the plane \\(z + 1 = 0\\) which is parallel to the \\(xy\\) -plane and intercepts the \\(z\\) -axis one unit below the origin. We expect the angle between these planes to be \\(\\frac{\\pi}{4}\\) radians, so let's quickly verify this with the inner product. First though, we must normalize them by dividing by the norm. This gives: \\[ \\begin{aligned} p_1 &= \\frac{3\\sqrt{2}}{2}\\ee_0 + \\frac{\\sqrt{2}}{2}\\ee_1 + \\frac{\\sqrt{2}}{2}\\ee_3 \\\\ p_2 &= \\ee_0 + \\ee_3 \\end{aligned} \\] Remember that when computing the norm, because \\(\\ee_0^2 = 0\\) , the \\(\\ee_0\\) component does not participate in the computaiton. The angle between them is then computed as: \\[ \\begin{aligned} p_1 \\cdot p_2 &= \\left(\\frac{3\\sqrt{2}}{2}\\ee_0 + \\frac{\\sqrt{2}}{2}\\ee_1 + \\frac{\\sqrt{2}}{2}\\ee_3\\right) \\cdot (\\ee_0 + \\ee_3) \\\\ &= \\frac{\\sqrt{2}}{2}\\ee_3\\cdot\\ee_3 \\\\ &= \\frac{\\sqrt{2}}{2} \\end{aligned} \\] indicating that the angle between \\(p_1\\) and \\(p_2\\) is \\(\\cos^{-1}{\\frac{\\sqrt{2}}{2}} = \\frac{\\pi}{4}\\) radians. The Klein code to compute the angle between planes is shown below: float plane_angle_rad ( kln :: plane p1 , kln :: plane p2 ) { p1 . normalize (); // Normalizes p1 in place p2 . normalize (); // Normalizes p2 in place return std :: acos (( p1 | p2 ). scalar ()); } Exercises The angle calculation above is a great example to demonstrate why the degenerate element \\(\\ee_0\\) is so important. Consider what would have happened if instead \\(\\ee_0 \\cdot \\ee_0 \\neq 0\\) . Now, suppose we made the \"choice\" of representing planes with trivector coordinates instead of vector coordinates. Repeat the above calculation using the duals of each plane. Does the computation still work?","title":"Angles between planes"},{"location":"geometry-potpourri/#lines","text":"Info kln::line","title":"Lines"},{"location":"geometry-potpourri/#intersecting-planes-to-create-lines","text":"The \"meet\" operation in \\(\\PGA\\) is defined in terms of the exterior product ( \\(\\wedge\\) ). Given two planes, \\(p_1 = 3\\ee_0 + \\ee_1 + \\ee_3\\) and \\(p_2 = \\ee_0 + \\ee_3\\) , we can compute the exterior product like so: \\[ \\begin{aligned} p_1\\wedge p_2 &= (3\\ee_0 + \\ee_1 + \\ee_3) \\wedge (\\ee_0 + \\ee_3) \\\\ &= 3\\ee_{03} + \\ee_{10} + \\ee_{13} + \\ee_{30} \\\\ &= -\\ee_{01} + 2\\ee_{03} - \\ee_{31} \\end{aligned} \\] How can we verify that this is correct? Well, let's first try to calculate the equation of this line using more traditional means. In classical Euclidean geometry, the six degrees of freedom of a line are often represented using Pl\u00fccker coordinates. Let's express our planes using the implicit equation form: \\[ \\begin{aligned} 0 &= 3 + x + z \\\\ 0 &= 1 + z \\end{aligned} \\] The Pl\u00fccker displacement is determined by the cross product of the plane normals, which in this case is the cross product \\((\\mathbf{i} + \\mathbf{k})\\times\\mathbf{k} = \\mathbf{i}\\times\\mathbf{k} = -\\mathbf{j}\\) . Meanwhile, the Pl\u00fccker moment of the line is given as \\(3\\mathbf{k} - (\\mathbf{i} + \\mathbf{k}) = -\\mathbf{i} + 2\\mathbf{k}\\) . Putting it together, the Pl\u00fccker coordinate tuple of our line is \\((d_1:d_2:d_3:m_1:m_2:m_3) = (0: -1: 0:-1:0:2)\\) , in exact accordance with the calculation above. Observe that the coordinates associated with \\(\\ee_{21}\\) , \\(\\ee_{13}\\) , and \\(\\ee_{32}\\) capture the information about the orientation of the line, while the coordinates associated with \\(\\ee_{01}\\) , \\(\\ee_{02}\\) , and \\(\\ee_{03}\\) work in tandem to impart a translational element as well. What happens if the planes are parallel? Let's try our meet between planes \\(-2\\ee_0 + 2\\ee_1\\) and \\(\\ee_1\\) to see what happens. \\[ (-2\\ee_0 + 2\\ee_1) \\wedge \\ee_1 = -2\\ee_{01} \\] We ended up with a bivector all the same! Quantities that have no direction components like the above are referred to as ideal lines , also known as lines at infinity . What's important about concepts like lines and points at infinity is that their existence allows our algebra to have closure without needing to introduce vague notions of \\(\\infty\\) . Another way to word this is to say that planes always intersect, even when parallel, and the algebra does not need to make any special exceptions for them. Furthermore, these entities at infinity have uses! We'll see later that rotations about ideal lines can be used to generate translations. The code that produces the line above is the following snippet: // plane 1: 3 + x + z = 0; kln :: plane p1 { 1.f , 0.f , 1.f , 3.f }; // plane 2: 1 + z = 0; kln :: plane p2 { 0.f , 0.f , 1.f , 1.f }; // line intersection of planes 1 and 2 kln :: line intersection = p1 ^ p2 ; Exercises Match up the Pl\u00fccker coordinates above with the coefficients of the meet operation above. Do you see how the element indices matter in determining the sign? Lines at infinity have 3 degrees of freedom. Is there an analogous plane at infinity? How many degrees of freedom does it have? What happens when you evaluate \\(p_2\\wedge p_1\\) instead of \\(p_1\\wedge p_2\\) ? Is the change justified?","title":"Intersecting planes to create lines"},{"location":"geometry-potpourri/#points","text":"Info kln::point","title":"Points"},{"location":"geometry-potpourri/#meet-a-line-and-a-plane","text":"With the same meet operation ( \\(\\wedge\\) ) we used to intersect two planes to construct a line, we can intersect a line and a plane to construct a point. Let's use the line \\(\\ell = -\\ee_{01} + 2\\ee_{03} - \\ee_{31}\\) from the previous example and the plane \\(\\ee_1 + \\ee_2\\) . \\[ \\begin{aligned} (-\\ee_{01} + 2\\ee_{03} - \\ee_{31}) \\wedge (\\ee_1 + \\ee_2) &= -\\ee_{012} + 2\\ee_{031} + 2\\ee_{032} - \\ee_{312}\\\\ &= -\\ee_{123} + 2\\ee_{032} + 2\\ee_{031} + \\ee_{021} \\\\ &\\rightarrow \\;\\; \\ee_{123} - 2\\ee_{032} + 2\\ee_{013} - \\ee_{021} \\end{aligned} \\] In the last step, we divided the expression by \\(-1\\) so that the weight of \\(\\ee_{123}\\) is exactly one. For points, this weight is the homogeneous coordinate, and when it is unity, there is a direct association between the point's Cartesian coordinates and the other trivector weights. For \\(\\PGA\\) , given a normalized point with \\(\\ee_{123}\\) weight \\(1\\) , the \\(x\\) coordinate is the weight of the \\(\\ee_{032}\\) trivector, the \\(y\\) coordinate is the weight of the \\(\\ee_{013}\\) trivector, and the \\(z\\) coordinate is the weight of the \\(\\ee_{021}\\) trivector. Projective equivalence In projective geometry, all geometric entities (planes, lines, points) exhibit a property known as projective equivalence. For any such entity \\(X\\) , the entity \\(aX\\) represents the same entity for any non-zero real scalar \\(a\\) . To compare weights from one entity to another meaningfully however, we tend to use this projective equivalence to keep things normalized in the same way. For example, it doesn't make sense to compare the \\(\\ee_{021}\\) weight (the \\(z\\) -coordinate) between two points unless they are both normalized in the same manner. In this case, the trivector is associated with the point at \\((-2, 2, -1)\\) . How can we verify that this point is the intersection we're seeking? Let's represent our plane and line as a system of equations. Recalling that \\(\\ell\\) was constructed as the intersection from two planes from before, this means that we can form the following system of three equations: \\[ \\begin{aligned} 0 &= 3 + x + z \\\\ 0 &= 1 + z \\\\ 0 &= x + y \\end{aligned} \\] Subtracting the second equation from the first yields \\(x = -2\\) . Substituting in the third equation yields \\(y = 2\\) . Finally, the second equation immediately gives \\(z = -1\\) . In code, the intersection of the plane and the line to construct a point can be done as follows: kln :: line l ( - 1.f , 0.f , 2.f , 0.f , - 1.f , 0.f ); kln :: plane p { 0.f , 1.f , 1.f , 0.f }; kln :: point intersection = l ^ p ; Exercises As mentioned previously, the exterior product is only anticommutative in certain situations. This isn't one of them! In fact, it would be somewhat concerning if the point intersection depended on the order \\(\\ell \\wedge p\\) vs \\(p \\wedge \\ell\\) . Evaluate \\(p \\wedge \\ell\\) for the above example and verify that you get the same result. Seeing points as trivectors might feel a bit confusing at first. This isn't so much an exercise, but a request for you, the reader, to reserve any doubts that the representation makes sense until we look at the geometric product in view of symmetric actions. Here, we met a line and a plane to get the point of intersection point. Three planes can be met with the same operator \\(\\wedge\\) to produce the intersection point as well. Can you see why?","title":"Meet a line and a plane"},{"location":"geometry-potpourri/#joins","text":"In the constructions above, we used the exterior product to meet entities to elegantly construct intersections. The \\(\\wedge\\) operator is a grade-increasing operation that allowed us to go from planes to lines to points. What about going the other direction? Well, there's a handy tool for that! Earlier, we learned about the Regressive Product , defined in terms of the exterior product on the duals of the operands. As a result, it should be evident that the regressive product is a grade decreasing operation that allows us to join entities to go in the other direction, from points to lines to planes. Sure enough, this works exactly as you'd expect. Two points can be joined to construct a line, and a line and a point (or equivalently three points) can be joined to create a plane. Here's a code snippet doing exactly this. kln :: point p1 { x1 , y1 , z1 }; kln :: point p2 { x2 , y2 , z2 }; kln :: line p1_to_p2 = p1 & p2 ; kln :: point p3 { x3 , y3 , z3 }; /// Equivalent to p1 & p2 & p3; kln :: plane p1_p2_p3 = p1_to_p2 & p3 ; Exercises Try to perform the computation above by hand given sufficiently simple initialization values of the three points. Do the results agree with what you expect? Explain why the Poincar\u00e9 dual map we introduced earlier needed to be an involution for our join to work so conveniently.","title":"Joins"},{"location":"geometry-potpourri/#projection-rejection-containment","text":"A common question is how to compute whether a point lies on a line or plane, or whether a line lies on a plane. When examining the implicit forms of lines and planes, the answer is obvious. For example, given a plane \\(0 = ax + by + cz + d\\) , points that lie on the plane are simply coordinate tuples that satisfy the implicit equation. In GA, coordinates are \"substituted\" in this manner, and we need a way to express projection/rejection/containment in terms of the algebraic operations available to us. The key is to use the symmetric inner product to perform metric \"measurements\". Let's consider the various cases separately.","title":"Projection, Rejection, Containment"},{"location":"geometry-potpourri/#point-to-plane","text":"Let's consider a point \\(P = \\ee_{123} + 2\\ee_{032} + \\ee_{013}\\) and a plane \\(p = 3\\ee_0 + \\ee_1\\) . The inner product between them is computed as: \\[ \\begin{aligned} P \\cdot p &= (\\ee_{123} + 2\\ee_{032} + \\ee_{013}) \\cdot (3\\ee_0 + \\ee_1) \\\\ &= \\ee_{23} - \\ee_{03} \\end{aligned} \\] This is the line perpendicular to the plane through the point. A way to intuitively see why this is so is to observe the fact that the inner product contracts indices, leaving only the parts that are not in common between the two. As a result, not only does the inner product produce a bivector, each corresponding term in the bivector produced contains indices not present in the plane. Can we now compute the distance between the point and the plane? The answer is no . Notice how in the above expression, the weight of \\(\\ee_0\\) of the plane didn't participate in the calculation at all. This means that translating the plane towards or away from the origin doesn't effect its inner product with a point, indicating that the line cannot be used to compute the distance between a point and a plane. Note that whether or not the plane was normalized made no difference. Before continuing, let's quickly see what would have happened if we computed \\(p \\cdot P\\) instead of \\(P \\cdot p\\) . \\[ \\begin{aligned} p \\cdot P &= (3\\ee_0 + \\ee_1) \\cdot (\\ee_{123} + 2\\ee_{032} + \\ee_{013}) \\\\ &= \\ee_{23} - \\ee_{03} \\end{aligned} \\] Conveniently, the results match! Exercises Can you justify the equality between \\(p\\cdot P\\) and \\(P \\cdot p\\) ? In the example above, the line produced by the inner product has a translational component. Where did that component come from? Can you see how the translational component of the produced line changes when we shift the position of the point? To compute the distance from the point to the plane, we need to use an operator that doesn't annihilate the translational component of the plane. The answer is to use the either the join ( \\(\\vee\\) ) or meet ( \\(\\wedge\\) ) operator to construct the metric-free quantity from which we can extract the distance by inspecting the magnitudes. Let's compute both to see what we come up with: \\[ \\begin{aligned} P \\wedge p &= (\\ee_{123} + 2\\ee_{032} + \\ee_{013}) \\wedge (3\\ee_0 + \\ee_1) \\\\ &= -3\\ee_{0123} - 2\\ee_{0123} \\\\ &= -5\\ee_{0123} \\end{aligned} \\] \\[ \\begin{aligned} P \\vee p &= (\\ee_{123} + 2\\ee_{032} + \\ee_{013}) \\vee (3\\ee_0 + \\ee_1) \\\\ &= \\JJ\\left((\\ee_0 + 2\\ee_1 + \\ee_2) \\wedge (3\\ee_{123} + \\ee_{032})\\right) \\\\ &= \\JJ\\left(3\\ee_{0123} + 2\\ee_{0123}\\right) \\\\ &= \\JJ\\left(5 \\ee_{0123}\\right) \\\\ &= 5 \\end{aligned} \\] The ideal norm (norm computed with only elements containing subscript \\(0\\) ) of the meet matches the norm of the join which encodes the distance from the point to the plane. As an equation, we'd express the ideal norm as \\(||P\\wedge p||_\\infty\\) . Let's check if this is right! The plane \\(p\\) corresponds to \\(0 = x + 3\\) and the point \\(P\\) corresponds to the coordinate tuple \\((2, 1, 0)\\) . The point-to-plane distance formula tells us that the distance between \\(P\\) and \\(p\\) is, in fact, \\(5\\) , in agreement with our point-plane meet and join calculation. To understand why this works, pay attention to which terms survived the meet and the join. The point's homogeneous component paired with the plane's translational component, and all the plane's direction components paired with the point's positional components. Geometrically, we've projected the point onto the normal direction of the plane and subsequently taken the norm which included the plane's translation from the origin. To compute this distance in Klein, given a point P and plane p , we'd simply do std::abs((p ^ P).e0123()) . Alternatively, we could do std::abs((p & P).scalar()) . Of course, you must normalize the plane with p.normalize() for this computation to work. Exercises The above computation worked because the plane \\(p\\) was normalized such that \\(p^2 = 1\\) . Change the normalization factor or change \\(p\\) itself and verify that normalization is required for the distance measure above to work. Considering the meet and join operators, does it make sense that the meet and join of a point and plane produced the pseudoscalar and scalar respectively? What about the line perpendicular to the plane through the point \\(P\\cdot p\\) ? It can't be used to measure the distance to the plane as we pointed out before, but it can be used to project the point to the plane. The succinct formula for this projection is \\((p \\cdot P)P\\) . \\[ \\begin{aligned} (p\\cdot P)P &= (\\ee_{23} - \\ee_{03})(3\\ee_0 + \\ee_1) \\\\ &= 3\\ee_{023} + \\ee_{123} - \\ee_{031} \\\\ &= \\ee_{123} - 3\\ee_{032} + \\ee_{013} \\end{aligned} \\] which corresponds to the point \\((-3, 1, 0)\\) . That this point lies on the plane is immediate. Also, this point is \\(5\\) units away from \\(P\\) and the line between them is parallel to the \\(x\\) axis, indicating that we have indeed projected the point to the plane. Klein code that computes this projection is shown below: kln :: plane p { 1 , 0 , 0 , 3 }; kln :: point P { 2 , 0 , 1 }; kln :: point P_on_p {( p | P ) * p }; // Equivalent to (P|p) * p","title":"Point to plane"},{"location":"geometry-potpourri/#line-to-plane","text":"Another potential projection we should consider is projecting a line to a plane. Without proof, the equation projecting \\(\\ell\\) onto \\(p\\) is \\((p\\cdot \\ell)p\\) . Before trying this out, let's check the dimensionality first. The expression \\(p\\cdot\\ell\\) will produce a vector quantity, but the geometric product of two vectors doesn't necessarily produce a bivector (there could be scalar components). The \"trick\" is to realize that because the inner product contracts all subscripts, the vector produced by \\(p\\cdot \\ell\\) will be completely orthogonal to both \\(\\ell\\) and \\(p\\) , so we are justified in claiming that the final result \\((p\\cdot \\ell)p\\) is a bivector, meaning that this formula does, in fact, produce a line. Let's consider the line \\(\\ell = \\ee_{32} + \\ee_{13}\\) (you should recognize this line as a line through the origin between the \\(x\\) and \\(y\\) axes). The projection onto the plane \\(p = 3\\ee_0 + \\ee_1\\) should clearly be the \\(y\\) axis shifted \\(3\\) units so let's verify that this is the case: \\[ \\begin{aligned} (p \\cdot \\ell)p &= \\left((3\\ee_0 + \\ee_1)\\cdot(\\ee_{32} + \\ee_{13})\\right) p \\\\ &= \\ee_{3}(3\\ee_0 + \\ee_1) \\\\ &= -3\\ee_{03} - \\ee_{13} \\end{aligned} \\] At first glance, this doesn't seem like the line that we want, but we must remember that projectively, the lines \\(3\\ee_{03} + \\ee_{13}\\) and \\(-3\\ee_{03} - \\ee_{13}\\) are projectively equivalent. In Klein, we can produce this projection as follows: kln :: plane p { 1 , 0 , 0 , 3 }; kln :: branch l { 1 , 1 , 0 }; // A branch is a line through the origin // This calculation works the same with `kln::line l{0, 0, 0, 1, 1, 0}` but // is more efficient using a branch since a branch uses half the storage. kln :: line l_on_p {( p | l ) * p }; Exercies Repeat the projection above using \\((\\ell \\cdot p)p\\) instead of \\((p\\cdot \\ell)p\\) . You should find that you get a negated result that remains projectively equivalent.","title":"Line to plane"},{"location":"geometry-potpourri/#point-to-line","text":"With the point and a line, two reasonable questions to ask are, as with the plane, how to compute the distance to the line, and how to project the point onto the line. Before continuing, guess what the formulae should be! Guess! Then click to reveal spoilers If you thought the distance between the point and the line is \\(||P\\vee \\ell||\\) and the projection is \\((P\\cdot \\ell)\\ell\\) , you'd be right! The uniformity between this equation and all the others we've seen should be quite satisfying. Note that the point must be normalized so that the weight of \\(\\ee_{123} = 1\\) and the line must be normalized so that the square norm of the directional components is unity for these formulae to work. In Klein, given a point P and line l , the projection is kln::point P_on_l{(P|l) * l} as you would expect. The projection is somewhat straightforward, but perhaps the distance formula may take some additional processing. First, let's consider the join \\(P\\vee\\ell\\) . What type of quantity does this produce? Well, from the section detailing the regressive product above, we know that his is a plane containing both the point and the line. It turns out that the norm of this plane will encode the distance between the point and the line. Let's see how this works for the line \\(\\ell = \\ee_{02} + \\ee_{23}\\) and point \\(P = \\ee_{123} + \\ee_{013} + \\ee_{021}\\) (we expect the distance to be \\(1\\) ). \\[ \\begin{aligned} ||P\\vee \\ell|| &= ||(\\ee_{123} + \\ee_{013} + \\ee_{021})\\vee (\\ee_{02} + \\ee_{23})|| \\\\ &= ||\\JJ\\left((\\ee_0 + \\ee_2 + \\ee_3)\\wedge(\\ee_{31} + \\ee_{01})\\right)|| \\\\ &= ||\\JJ\\left(-\\ee_{013} -\\ee_{021} + \\ee_{123} + \\ee_{013}\\right)|| \\\\ &= ||\\JJ\\left(-\\ee_{021} + \\ee_{123}\\right)|| \\\\ &= ||-\\ee_3 + \\ee_0|| \\\\ &= 1 \\end{aligned} \\] If you have trouble remembering how lines are defined, remember that terms containing a \\(0\\) in the subscript are translational components (the moment of the line) and the remaining terms determine the line's direction. The line \\(\\ee_{02} + \\ee_{23}\\) can be decomposed as the meet of two planes \\(\\ee_0 - \\ee_3\\) and \\(\\ee_2\\) so we can intuit that the line is the \\(x\\) axis shifted a unit in the \\(+z\\) direction. The norm of a point is just the homogeneous coordinate. Code computing the distance between a point and a line looks like: kln :: line l { 0 , 1 , 0 , 1 , 0 , 0 }; kln :: point p { 0 , 1 , 1 }; float distance = kln :: plane { l & p }. norm (); For completeness, we can project the point on the line with the following snippet: kln :: line l { 0 , 1 , 0 , 1 , 0 , 0 }; kln :: point p { 0 , 1 , 1 }; // Note that for this calculation to work, if the line l and point p were // not normalized, we would need to invoke l.normalize() and p.normalize() // first before proceeding. kln :: point p_on_l {( p | l ) * p }; Exercises The weight of \\(\\ee_{013}\\) in the point above should correspond directly with its distance from the line. Verify that this is so. Try shifting the point in a different direction (say along \\(x\\) ). Does the distance stay unaffected as you'd expect? What about shifting the point in the \\(z\\) direction?","title":"Point to line"},{"location":"geometry-potpourri/#reflections","text":"So far, we've seen how the exterior product and regressive product can be used to construct planes, lines, and points. We also saw how the symmetric inner product can be used to measure angles between planes. Furthermore, we used the ideal norm in conjunction with the exterior and regressive products to compute distances between entities. Already, \\(\\PGA\\) has yielded many fruitful results which has consequently led to a compact and elegant API. However, we haven't yet encountered a primary usage of the geometric product, and this is where we'll fully appreciate the decision of using the representation we have.","title":"Reflections"},{"location":"geometry-potpourri/#reflection-through-a-plane","text":"A reflection of an entity \\(X\\) through a plane \\(p\\) is given by \\(pXp\\) . This is true regardless of whether \\(X\\) is another plane, a line, or a point! ARTICLE CURRENTLY BEING DRAFTED","title":"Reflection through a plane"},{"location":"gpu/","text":"GPU support is currently provided by a single glsl file . This file can be pasted at the start of a shader to provide limited functionality supported by the full C++ Klein library. The kln_plane , kln_line , kln_point , kln_rotor , and kln_motor entity structs defined in this shader header are byte-for-byte identical to their C++ counterparts. Currently, the following functions are supported: Function Description kln_rotor kln_mul(in kln_rotor a, in kln_rotor b) Multiplies two rotors and returns the result kln_translator kln_mul(in kln_translator a, in kln_translator b) Multiplies two translators and returns the result kln_motor kln_mul(in kln_motor a, in kln_motor b) Multiplies two motors and returns the result kln_plane kln_apply(in kln_rotor r, in kln_plane p) Applies a rotor to a plane kln_plane kln_apply(in kln_motor m, in kln_plane p) Applies a motor to a plane kln_point kln_apply(in kln_rotor r, in kln_point p) Applies a rotor to a point kln_point kln_apply(in kln_motor m, in kln_point p) Applies a motor to a point kln_point kln_apply(in kln_motor m) Applies a motor to the origin GPU support is verified with a C++ test suite powered by a shim to handle vector swizzle operations and provide implementations for GLSL built-in functions. GPU support is currently preliminary and achieving parity with seamless interoperability with the Klein C++ headers is an ongoing objective.","title":"GPU Support"},{"location":"overview/","text":"API Overview tr > td:first-child { white-space: nowrap; } Working with Klein is designed to be as simple as it is efficient. To \"grok\" the API, it suffices to understand the API in terms of the primary operations supported through the primary geometric entities. The entities provided are Euclidean objects ( points , lines , planes ), objects that arise in Projective space ( directions , ideal lines ), and geometric actions ( rotors , translators , motors , and planes ). Class Description plane A plane is the manifestation of a reflection of \\(\\mathbf{E}^3\\) (consider the set of fixed points of a reflection). line A line is the manifestation of a rotation of \\(\\mathbf{E}^3\\) (consider the set of fixed points of a rotation). branch A branch is a line through the origin ideal_line An ideal line is a line at infinity point A point is the manifestation of a roto-reflection of \\(\\mathbf{E}^3\\) (which has a single fixed point) direction A direction is modeled as a point at infinity (homogeneous weight \\(0\\) ) rotor A rotor is the product of two intersecting planes (generating a rotation) translator A translator is the product of two parallel planes (generating a translation) motor A motor is a screw combining a rotation and translation along a screw axis dual A dual is the sum of a scalar and pseudoscalar quantity. Dual numbers show up in a number of contexts, including the factorization of a motor axis, and as the result of several meet and join operations. Note The call operator on a plane performs a reflection of the passed entity through the plane. The call operator on a rotor performs a rotation of the entity. The translator translates, and the motor performs a combination of a rotation and a translation. The multivector operations such as the geometric product, exterior product, regressive product, etc. are supported for all the listed entities above via the following operator table: Operator Description + Addition - Subtraction * s Uniform scaling by a float or int s / s Uniform inverse scaling by a float or int s * Geometric Product ^ Exterior Product & Regressive Product | Symmetric Inner Product ! Poincar\u00e9 Dual Note Addition and subtraction is only supported between arguments of the same type. For example, two planes can be added together, but not a plane and a rotor . Tip For the geometric actions (implemented via the conjugation operator \\(xP\\widetilde{x}\\) ), the call operator should be used on the action itself as this will invoke a more optimized routine than invoking x * P * ~x manually. For example, given a rotor r and a point p , applying the rotor to p as r(p) will be faster with equivalent results to r * p * ~r . Similarly, while the regressive product between two entities a and b can be computed as !(!a ^ !b) , the explicit a & b should be preferred for efficiency. There are a few additional freestanding functions to perform various tasks. Function Description project Projects the first argument onto the second argument and returns the result. log Takes the logarithm of the argument and returns the result. exp Computes the exponential of the argument and returns the result. sqrt Computes the square root of a rotor or motor and returns the result. Note Throughout the API, you may see functions and methods marked with KLN_VEC_CALL . This macro expands to __vectorcall to ensure that register passing is used on MSVC.","title":"Overview"},{"location":"overview/#api-overview","text":"tr > td:first-child { white-space: nowrap; } Working with Klein is designed to be as simple as it is efficient. To \"grok\" the API, it suffices to understand the API in terms of the primary operations supported through the primary geometric entities. The entities provided are Euclidean objects ( points , lines , planes ), objects that arise in Projective space ( directions , ideal lines ), and geometric actions ( rotors , translators , motors , and planes ). Class Description plane A plane is the manifestation of a reflection of \\(\\mathbf{E}^3\\) (consider the set of fixed points of a reflection). line A line is the manifestation of a rotation of \\(\\mathbf{E}^3\\) (consider the set of fixed points of a rotation). branch A branch is a line through the origin ideal_line An ideal line is a line at infinity point A point is the manifestation of a roto-reflection of \\(\\mathbf{E}^3\\) (which has a single fixed point) direction A direction is modeled as a point at infinity (homogeneous weight \\(0\\) ) rotor A rotor is the product of two intersecting planes (generating a rotation) translator A translator is the product of two parallel planes (generating a translation) motor A motor is a screw combining a rotation and translation along a screw axis dual A dual is the sum of a scalar and pseudoscalar quantity. Dual numbers show up in a number of contexts, including the factorization of a motor axis, and as the result of several meet and join operations. Note The call operator on a plane performs a reflection of the passed entity through the plane. The call operator on a rotor performs a rotation of the entity. The translator translates, and the motor performs a combination of a rotation and a translation. The multivector operations such as the geometric product, exterior product, regressive product, etc. are supported for all the listed entities above via the following operator table: Operator Description + Addition - Subtraction * s Uniform scaling by a float or int s / s Uniform inverse scaling by a float or int s * Geometric Product ^ Exterior Product & Regressive Product | Symmetric Inner Product ! Poincar\u00e9 Dual Note Addition and subtraction is only supported between arguments of the same type. For example, two planes can be added together, but not a plane and a rotor . Tip For the geometric actions (implemented via the conjugation operator \\(xP\\widetilde{x}\\) ), the call operator should be used on the action itself as this will invoke a more optimized routine than invoking x * P * ~x manually. For example, given a rotor r and a point p , applying the rotor to p as r(p) will be faster with equivalent results to r * p * ~r . Similarly, while the regressive product between two entities a and b can be computed as !(!a ^ !b) , the explicit a & b should be preferred for efficiency. There are a few additional freestanding functions to perform various tasks. Function Description project Projects the first argument onto the second argument and returns the result. log Takes the logarithm of the argument and returns the result. exp Computes the exponential of the argument and returns the result. sqrt Computes the square root of a rotor or motor and returns the result. Note Throughout the API, you may see functions and methods marked with KLN_VEC_CALL . This macro expands to __vectorcall to ensure that register passing is used on MSVC.","title":"API Overview"},{"location":"perf/","text":"Performance of SSE code is tricky to estimate, especially in real-world scenarios. Properties of code tested in a microbenchmark do not transfer well to the wild. For example, aggressive register usage generally translates to better microbenchmark results, but may not result in faster running \"real-world\" applications. On this page, assembly snippets for common routines are provided for inspection, as well as analysis produced by llvm-mca . Users are encouranged to benchmark their own code and create an issue if a performance issue is believed to have been discovered. The analysis provided by LLVM-MCA cannot be used as a proxy for predicting performance, although it is a useful tool to compare alternatives. Only a few routines are provided here as an indicator of the performance and implementation characteristics of the rest of the code. To understand the implications of the various counters and resource estimates provided, please refer to the excellent analysis provided at uops.info . Rotor Composition kln :: rotor ab ( kln :: rotor const & a , kln :: rotor const & b ) { return a * b ; } Klein LLVM-MCA assembly and analysis Iterations : 100 Instructions : 2400 Total Cycles : 821 Total uOps : 2400 Dispatch Width : 6 uOps Per Cycle : 2.92 IPC : 2.92 Block RThroughput : 8.0 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 6 0.50 * movaps (% rdi ), % xmm0 1 6 0.50 * movaps (% rsi ), % xmm1 1 1 0.33 movaps % xmm0 , % xmm2 1 1 1.00 shufps $0 , % xmm0 , % xmm2 1 4 0.50 mulps % xmm1 , % xmm2 1 1 0.33 movaps % xmm0 , % xmm3 1 1 1.00 shufps $121 , % xmm0 , % xmm3 1 1 0.33 movaps % xmm1 , % xmm4 1 1 1.00 shufps $157 , % xmm1 , % xmm4 1 4 0.50 mulps % xmm3 , % xmm4 1 4 0.50 subps % xmm4 , % xmm2 1 1 0.33 movaps % xmm0 , % xmm3 1 1 1.00 shufps $230 , % xmm0 , % xmm3 1 1 0.33 movaps % xmm1 , % xmm4 1 1 1.00 shufps $2 , % xmm1 , % xmm4 1 4 0.50 mulps % xmm3 , % xmm4 1 1 1.00 shufps $159 , % xmm0 , % xmm0 1 1 1.00 shufps $123 , % xmm1 , % xmm1 1 4 0.50 mulps % xmm0 , % xmm1 1 4 0.50 addps % xmm4 , % xmm1 1 1 0.25 movl $ - 2147483648 , % eax 1 1 1.00 movd % eax , % xmm0 1 1 0.33 pxor % xmm1 , % xmm0 1 4 0.50 addps % xmm2 , % xmm0 Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - - 6.49 6.50 1.00 1.00 - 8.01 1.00 - Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - - 1.00 - - - - movaps (% rdi ), % xmm0 - - - - 1.00 - - - - - movaps (% rsi ), % xmm1 - - 0.50 0.50 - - - - - - movaps % xmm0 , % xmm2 - - - - - - - 1.00 - - shufps $0 , % xmm0 , % xmm2 - - 0.03 0.97 - - - - - - mulps % xmm1 , % xmm2 - - 0.50 0.50 - - - - - - movaps % xmm0 , % xmm3 - - - - - - - 1.00 - - shufps $121 , % xmm0 , % xmm3 - - 0.51 0.48 - - - 0.01 - - movaps % xmm1 , % xmm4 - - - - - - - 1.00 - - shufps $157 , % xmm1 , % xmm4 - - 0.98 0.02 - - - - - - mulps % xmm3 , % xmm4 - - 0.94 0.06 - - - - - - subps % xmm4 , % xmm2 - - 0.50 0.50 - - - - - - movaps % xmm0 , % xmm3 - - - - - - - 1.00 - - shufps $230 , % xmm0 , % xmm3 - - 0.50 0.50 - - - - - - movaps % xmm1 , % xmm4 - - - - - - - 1.00 - - shufps $2 , % xmm1 , % xmm4 - - 0.51 0.49 - - - - - - mulps % xmm3 , % xmm4 - - - - - - - 1.00 - - shufps $159 , % xmm0 , % xmm0 - - - - - - - 1.00 - - shufps $123 , % xmm1 , % xmm1 - - 0.53 0.47 - - - - - - mulps % xmm0 , % xmm1 - - 0.02 0.98 - - - - - - addps % xmm4 , % xmm1 - - - - - - - - 1.00 - movl $ - 2147483648 , % eax - - - - - - - 1.00 - - movd % eax , % xmm0 - - 0.48 0.52 - - - - - - pxor % xmm1 , % xmm0 - - 0.49 0.51 - - - - - - addps % xmm2 , % xmm0 For comparison, here is the assembly and analysis corresponding to semantically identical code from RTM . rtm :: quatf ab ( rtm :: quatf const & a , rtm :: quatf const & b ) { return rtm :: quat_mul ( a , b ); } RTM LLVM-MCA assembly and analysis Iterations : 100 Instructions : 2300 Total Cycles : 824 Total uOps : 2600 Dispatch Width : 6 uOps Per Cycle : 3.16 IPC : 2.79 Block RThroughput : 7.0 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 6 0.50 * movaps (% rdi ), % xmm0 1 6 0.50 * movaps (% rsi ), % xmm2 1 1 0.33 movaps % xmm2 , % xmm1 1 1 1.00 shufps $0 , % xmm2 , % xmm1 1 1 0.33 movaps % xmm2 , % xmm3 1 1 1.00 shufps $85 , % xmm2 , % xmm3 1 1 0.33 movaps % xmm2 , % xmm4 1 1 1.00 shufps $170 , % xmm2 , % xmm4 1 1 1.00 shufps $255 , % xmm2 , % xmm2 1 4 0.50 mulps % xmm0 , % xmm2 1 1 0.33 movaps % xmm0 , % xmm5 1 1 1.00 shufps $27 , % xmm0 , % xmm5 1 4 0.50 mulps % xmm5 , % xmm1 1 1 1.00 shufps $177 , % xmm5 , % xmm5 1 4 0.50 mulps % xmm3 , % xmm5 2 7 0.50 * xorps . LCPI0_0 (% rip ), % xmm1 1 1 1.00 shufps $177 , % xmm0 , % xmm0 1 4 0.50 mulps % xmm4 , % xmm0 2 7 0.50 * xorps . LCPI0_1 (% rip ), % xmm5 2 7 0.50 * xorps . LCPI0_2 (% rip ), % xmm0 1 4 0.50 addps % xmm2 , % xmm1 1 4 0.50 addps % xmm5 , % xmm0 1 4 0.50 addps % xmm1 , % xmm0 Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - - 6.49 6.50 2.50 2.50 - 8.01 - - Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - 0.50 0.50 - - - - movaps (% rdi ), % xmm0 - - - - 0.49 0.51 - - - - movaps (% rsi ), % xmm2 - - 0.03 0.96 - - - 0.01 - - movaps % xmm2 , % xmm1 - - - - - - - 1.00 - - shufps $0 , % xmm2 , % xmm1 - - 0.95 0.05 - - - - - - movaps % xmm2 , % xmm3 - - - - - - - 1.00 - - shufps $85 , % xmm2 , % xmm3 - - 0.04 0.96 - - - - - - movaps % xmm2 , % xmm4 - - - - - - - 1.00 - - shufps $170 , % xmm2 , % xmm4 - - - - - - - 1.00 - - shufps $255 , % xmm2 , % xmm2 - - 0.49 0.51 - - - - - - mulps % xmm0 , % xmm2 - - 0.95 0.05 - - - - - - movaps % xmm0 , % xmm5 - - - - - - - 1.00 - - shufps $27 , % xmm0 , % xmm5 - - 0.52 0.48 - - - - - - mulps % xmm5 , % xmm1 - - - - - - - 1.00 - - shufps $177 , % xmm5 , % xmm5 - - 0.49 0.51 - - - - - - mulps % xmm3 , % xmm5 - - 0.48 0.52 0.50 0.50 - - - - xorps . LCPI0_0 (% rip ), % xmm1 - - - - - - - 1.00 - - shufps $177 , % xmm0 , % xmm0 - - 0.52 0.48 - - - - - - mulps % xmm4 , % xmm0 - - 0.48 0.52 0.50 0.50 - - - - xorps . LCPI0_1 (% rip ), % xmm5 - - - - 0.51 0.49 - 1.00 - - xorps . LCPI0_2 (% rip ), % xmm0 - - 0.51 0.49 - - - - - - addps % xmm2 , % xmm1 - - 0.52 0.48 - - - - - - addps % xmm5 , % xmm0 - - 0.51 0.49 - - - - - - addps % xmm1 , % xmm0 Finally, for good measure, here is the same procedure and analysis for GLM glm :: quat rotor_composition ( glm :: quat const & a , glm :: quat const & b ) { return a * b ; } GLM LLVM-MCA assembly and analysis Iterations : 100 Instructions : 5700 Total Cycles : 1522 Total uOps : 5800 Dispatch Width : 6 uOps Per Cycle : 3.81 IPC : 3.75 Block RThroughput : 14.0 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 5 0.50 * movss (% rdi ), % xmm4 1 5 0.50 * movss 4 (% rdi ), % xmm3 1 5 0.50 * movss 8 (% rdi ), % xmm2 1 5 0.50 * movss 12 (% rdi ), % xmm0 1 5 0.50 * movss (% rsi ), % xmm9 1 5 0.50 * movss 4 (% rsi ), % xmm8 1 5 0.50 * movss 8 (% rsi ), % xmm7 1 5 0.50 * movss 12 (% rsi ), % xmm10 1 1 0.33 movaps % xmm0 , % xmm5 1 1 0.33 movaps % xmm4 , % xmm1 1 1 0.33 movaps % xmm0 , % xmm6 1 4 0.50 mulss % xmm10 , % xmm1 1 1 0.33 movaps % xmm2 , % xmm11 1 4 0.50 mulss % xmm9 , % xmm5 1 4 0.50 mulss % xmm8 , % xmm6 1 4 0.50 mulss % xmm10 , % xmm11 1 4 0.50 addss % xmm1 , % xmm5 1 1 0.33 movaps % xmm3 , % xmm1 1 4 0.50 mulss % xmm7 , % xmm1 1 4 0.50 addss % xmm1 , % xmm5 1 1 0.33 movaps % xmm2 , % xmm1 1 4 0.50 mulss % xmm8 , % xmm1 1 4 0.50 subss % xmm1 , % xmm5 1 1 0.33 movaps % xmm3 , % xmm1 1 4 0.50 mulss % xmm10 , % xmm1 1 4 0.50 addss % xmm1 , % xmm6 1 1 0.33 movaps % xmm2 , % xmm1 1 4 0.50 mulss % xmm9 , % xmm1 1 4 0.50 mulss % xmm7 , % xmm2 1 4 0.50 addss % xmm1 , % xmm6 1 1 0.33 movaps % xmm4 , % xmm1 1 4 0.50 mulss % xmm7 , % xmm1 1 4 0.50 subss % xmm1 , % xmm6 1 1 0.33 movaps % xmm0 , % xmm1 1 4 0.50 mulss % xmm7 , % xmm1 1 4 0.50 mulss % xmm10 , % xmm0 1 1 1.00 unpcklps % xmm6 , % xmm5 1 1 0.33 movaps % xmm5 , % xmm7 1 4 0.50 addss % xmm11 , % xmm1 1 1 0.33 movaps % xmm4 , % xmm11 1 4 0.50 mulss % xmm8 , % xmm11 1 4 0.50 mulss % xmm9 , % xmm4 1 4 0.50 addss % xmm11 , % xmm1 1 1 0.33 movaps % xmm3 , % xmm11 1 4 0.50 mulss % xmm8 , % xmm3 1 4 0.50 subss % xmm4 , % xmm0 1 4 0.50 mulss % xmm9 , % xmm11 1 4 0.50 subss % xmm3 , % xmm0 1 4 0.50 subss % xmm11 , % xmm1 1 4 0.50 subss % xmm2 , % xmm0 1 1 1.00 unpcklps % xmm0 , % xmm1 1 1 1.00 movlhps % xmm1 , % xmm7 2 1 1.00 * movaps % xmm7 , - 40 (% rsp ) 1 5 0.50 * movq - 32 (% rsp ), % rax 1 5 0.50 * movq - 40 (% rsp ), % xmm0 1 1 1.00 movq % rax , % xmm1 1 1 1.00 * movq % rax , - 16 (% rsp ) Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - - 15.00 15.00 5.01 5.01 2.00 15.00 - 1.98 Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - - 1.00 - - - - movss (% rdi ), % xmm4 - - - - 1.00 - - - - - movss 4 (% rdi ), % xmm3 - - - - 0.01 0.99 - - - - movss 8 (% rdi ), % xmm2 - - - - 0.99 0.01 - - - - movss 12 (% rdi ), % xmm0 - - - - - 1.00 - - - - movss (% rsi ), % xmm9 - - - - 1.00 - - - - - movss 4 (% rsi ), % xmm8 - - - - 0.98 0.02 - - - - movss 8 (% rsi ), % xmm7 - - - - 0.02 0.98 - - - - movss 12 (% rsi ), % xmm10 - - 0.48 - - - - 0.52 - - movaps % xmm0 , % xmm5 - - - 0.49 - - - 0.51 - - movaps % xmm4 , % xmm1 - - 0.98 0.01 - - - 0.01 - - movaps % xmm0 , % xmm6 - - 0.98 0.02 - - - - - - mulss % xmm10 , % xmm1 - - 0.01 0.01 - - - 0.98 - - movaps % xmm2 , % xmm11 - - 0.50 0.50 - - - - - - mulss % xmm9 , % xmm5 - - 1.00 - - - - - - - mulss % xmm8 , % xmm6 - - 0.50 0.50 - - - - - - mulss % xmm10 , % xmm11 - - 0.49 0.51 - - - - - - addss % xmm1 , % xmm5 - - - 0.01 - - - 0.99 - - movaps % xmm3 , % xmm1 - - 0.99 0.01 - - - - - - mulss % xmm7 , % xmm1 - - - 1.00 - - - - - - addss % xmm1 , % xmm5 - - - - - - - 1.00 - - movaps % xmm2 , % xmm1 - - 1.00 - - - - - - - mulss % xmm8 , % xmm1 - - 0.01 0.99 - - - - - - subss % xmm1 , % xmm5 - - 0.01 - - - - 0.99 - - movaps % xmm3 , % xmm1 - - 0.50 0.50 - - - - - - mulss % xmm10 , % xmm1 - - 0.49 0.51 - - - - - - addss % xmm1 , % xmm6 - - - - - - - 1.00 - - movaps % xmm2 , % xmm1 - - 0.99 0.01 - - - - - - mulss % xmm9 , % xmm1 - - 0.01 0.99 - - - - - - mulss % xmm7 , % xmm2 - - 0.50 0.50 - - - - - - addss % xmm1 , % xmm6 - - - - - - - 1.00 - - movaps % xmm4 , % xmm1 - - 1.00 - - - - - - - mulss % xmm7 , % xmm1 - - - 1.00 - - - - - - subss % xmm1 , % xmm6 - - - - - - - 1.00 - - movaps % xmm0 , % xmm1 - - 1.00 - - - - - - - mulss % xmm7 , % xmm1 - - 0.50 0.50 - - - - - - mulss % xmm10 , % xmm0 - - - - - - - 1.00 - - unpcklps % xmm6 , % xmm5 - - - - - - - 1.00 - - movaps % xmm5 , % xmm7 - - 0.50 0.50 - - - - - - addss % xmm11 , % xmm1 - - - - - - - 1.00 - - movaps % xmm4 , % xmm11 - - 0.99 0.01 - - - - - - mulss % xmm8 , % xmm11 - - 0.02 0.98 - - - - - - mulss % xmm9 , % xmm4 - - 0.02 0.98 - - - - - - addss % xmm11 , % xmm1 - - - - - - - 1.00 - - movaps % xmm3 , % xmm11 - - 0.98 0.02 - - - - - - mulss % xmm8 , % xmm3 - - 0.01 0.99 - - - - - - subss % xmm4 , % xmm0 - - 0.51 0.49 - - - - - - mulss % xmm9 , % xmm11 - - 0.02 0.98 - - - - - - subss % xmm3 , % xmm0 - - - 1.00 - - - - - - subss % xmm11 , % xmm1 - - 0.01 0.99 - - - - - - subss % xmm2 , % xmm0 - - - - - - - 1.00 - - unpcklps % xmm0 , % xmm1 - - - - - - - 1.00 - - movlhps % xmm1 , % xmm7 - - - - 0.01 - 1.00 - - 0.99 movaps % xmm7 , - 40 (% rsp ) - - - - - 1.00 - - - - movq - 32 (% rsp ), % rax - - - - 1.00 - - - - - movq - 40 (% rsp ), % xmm0 - - - - - - - 1.00 - - movq % rax , % xmm1 - - - - - 0.01 1.00 - - 0.99 movq % rax , - 16 (% rsp ) Motor-Point Application (Dual Quat Application) kln :: point motor_application ( kln :: motor const & m , kln :: point const & p ) { return m ( p ); } Klein LLVM-MCA assembly and analysis Iterations : 100 Instructions : 5900 Total Cycles : 1831 Total uOps : 5900 Dispatch Width : 6 uOps Per Cycle : 3.22 IPC : 3.22 Block RThroughput : 13.5 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 6 0.50 * movaps (% rdi ), % xmm3 1 6 0.50 * movaps 16 (% rdi ), % xmm6 1 1 0.33 movaps % xmm3 , % xmm12 1 1 1.00 shufps $0 , % xmm3 , % xmm12 1 1 0.33 movaps % xmm3 , % xmm11 1 1 0.33 movaps % xmm3 , % xmm10 1 1 0.33 movaps % xmm12 , % xmm8 1 1 0.33 movaps % xmm12 , % xmm9 1 1 0.33 movaps % xmm3 , % xmm4 1 1 0.33 movaps % xmm3 , % xmm1 1 1 0.33 movaps % xmm6 , % xmm7 1 4 0.50 mulps % xmm6 , % xmm12 1 1 0.33 movaps % xmm6 , % xmm0 1 1 1.00 shufps $0 , % xmm6 , % xmm6 1 4 0.50 mulps % xmm3 , % xmm6 1 1 1.00 shufps $156 , % xmm3 , % xmm3 1 4 0.50 mulps % xmm3 , % xmm11 1 1 1.00 shufps $120 , % xmm10 , % xmm10 1 4 0.50 mulps % xmm10 , % xmm8 1 4 0.50 subps % xmm8 , % xmm11 1 4 0.50 mulps % xmm3 , % xmm9 1 4 0.50 mulps % xmm10 , % xmm4 1 4 0.50 addps % xmm9 , % xmm4 1 4 0.50 mulps % xmm1 , % xmm1 1 1 0.33 movaps % xmm1 , % xmm5 1 1 1.00 shufps $1 , % xmm1 , % xmm5 1 4 0.50 addps % xmm1 , % xmm5 1 1 0.33 movaps % xmm1 , % xmm2 1 1 1.00 shufps $158 , % xmm1 , % xmm2 1 1 1.00 shufps $123 , % xmm1 , % xmm1 1 4 0.50 addps % xmm2 , % xmm1 1 1 0.25 movl $ - 2147483648 , % eax 1 1 1.00 movd % eax , % xmm2 1 1 0.33 pxor % xmm1 , % xmm2 1 6 0.50 * movaps . LCPI3_0 (% rip ), % xmm1 1 4 0.50 mulps % xmm1 , % xmm11 1 4 0.50 mulps % xmm1 , % xmm4 1 4 0.50 subps % xmm2 , % xmm5 1 1 1.00 shufps $156 , % xmm7 , % xmm7 1 4 0.50 mulps % xmm10 , % xmm7 1 4 0.50 subps % xmm12 , % xmm7 1 1 1.00 shufps $120 , % xmm0 , % xmm0 1 4 0.50 mulps % xmm3 , % xmm0 1 4 0.50 subps % xmm0 , % xmm7 1 4 0.50 subps % xmm6 , % xmm7 1 4 0.50 mulps % xmm1 , % xmm7 1 6 0.50 * movaps (% rsi ), % xmm0 1 1 0.33 movaps % xmm0 , % xmm1 1 1 1.00 shufps $156 , % xmm0 , % xmm1 1 4 0.50 mulps % xmm11 , % xmm1 1 1 0.33 movaps % xmm0 , % xmm2 1 1 1.00 shufps $120 , % xmm0 , % xmm2 1 4 0.50 mulps % xmm4 , % xmm2 1 4 0.50 addps % xmm1 , % xmm2 1 4 0.50 mulps % xmm0 , % xmm5 1 4 0.50 addps % xmm2 , % xmm5 1 1 1.00 shufps $0 , % xmm0 , % xmm0 1 4 0.50 mulps % xmm7 , % xmm0 1 4 0.50 addps % xmm5 , % xmm0 Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - - 18.01 18.01 2.00 2.00 - 17.98 1.00 - Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - - 1.00 - - - - movaps (% rdi ), % xmm3 - - - - 1.00 - - - - - movaps 16 (% rdi ), % xmm6 - - 0.01 0.98 - - - 0.01 - - movaps % xmm3 , % xmm12 - - - - - - - 1.00 - - shufps $0 , % xmm3 , % xmm12 - - - 1.00 - - - - - - movaps % xmm3 , % xmm11 - - 0.01 0.49 - - - 0.50 - - movaps % xmm3 , % xmm10 - - 0.49 0.01 - - - 0.50 - - movaps % xmm12 , % xmm8 - - - 0.50 - - - 0.50 - - movaps % xmm12 , % xmm9 - - - 0.51 - - - 0.49 - - movaps % xmm3 , % xmm4 - - 0.50 0.01 - - - 0.49 - - movaps % xmm3 , % xmm1 - - 0.01 0.50 - - - 0.49 - - movaps % xmm6 , % xmm7 - - - 1.00 - - - - - - mulps % xmm6 , % xmm12 - - - - - - - 1.00 - - movaps % xmm6 , % xmm0 - - - - - - - 1.00 - - shufps $0 , % xmm6 , % xmm6 - - 0.50 0.50 - - - - - - mulps % xmm3 , % xmm6 - - - - - - - 1.00 - - shufps $156 , % xmm3 , % xmm3 - - 0.98 0.02 - - - - - - mulps % xmm3 , % xmm11 - - - - - - - 1.00 - - shufps $120 , % xmm10 , % xmm10 - - 0.02 0.98 - - - - - - mulps % xmm10 , % xmm8 - - 0.03 0.97 - - - - - - subps % xmm8 , % xmm11 - - 0.01 0.99 - - - - - - mulps % xmm3 , % xmm9 - - 0.49 0.51 - - - - - - mulps % xmm10 , % xmm4 - - 0.49 0.51 - - - - - - addps % xmm9 , % xmm4 - - 0.51 0.49 - - - - - - mulps % xmm1 , % xmm1 - - 0.49 - - - - 0.51 - - movaps % xmm1 , % xmm5 - - - - - - - 1.00 - - shufps $1 , % xmm1 , % xmm5 - - 0.99 0.01 - - - - - - addps % xmm1 , % xmm5 - - 0.01 0.50 - - - 0.49 - - movaps % xmm1 , % xmm2 - - - - - - - 1.00 - - shufps $158 , % xmm1 , % xmm2 - - - - - - - 1.00 - - shufps $123 , % xmm1 , % xmm1 - - 0.03 0.97 - - - - - - addps % xmm2 , % xmm1 - - - - - - - - 1.00 - movl $ - 2147483648 , % eax - - - - - - - 1.00 - - movd % eax , % xmm2 - - 0.99 0.01 - - - - - - pxor % xmm1 , % xmm2 - - - - - 1.00 - - - - movaps . LCPI3_0 (% rip ), % xmm1 - - 0.52 0.48 - - - - - - mulps % xmm1 , % xmm11 - - 0.01 0.99 - - - - - - mulps % xmm1 , % xmm4 - - 0.98 0.02 - - - - - - subps % xmm2 , % xmm5 - - - - - - - 1.00 - - shufps $156 , % xmm7 , % xmm7 - - 0.49 0.51 - - - - - - mulps % xmm10 , % xmm7 - - 0.50 0.50 - - - - - - subps % xmm12 , % xmm7 - - - - - - - 1.00 - - shufps $120 , % xmm0 , % xmm0 - - 0.52 0.48 - - - - - - mulps % xmm3 , % xmm0 - - 0.50 0.50 - - - - - - subps % xmm0 , % xmm7 - - 1.00 - - - - - - - subps % xmm6 , % xmm7 - - 1.00 - - - - - - - mulps % xmm1 , % xmm7 - - - - 1.00 - - - - - movaps (% rsi ), % xmm0 - - 0.48 0.52 - - - - - - movaps % xmm0 , % xmm1 - - - - - - - 1.00 - - shufps $156 , % xmm0 , % xmm1 - - 0.99 0.01 - - - - - - mulps % xmm11 , % xmm1 - - - 1.00 - - - - - - movaps % xmm0 , % xmm2 - - - - - - - 1.00 - - shufps $120 , % xmm0 , % xmm2 - - 0.50 0.50 - - - - - - mulps % xmm4 , % xmm2 - - 0.99 0.01 - - - - - - addps % xmm1 , % xmm2 - - 0.01 0.99 - - - - - - mulps % xmm0 , % xmm5 - - 0.99 0.01 - - - - - - addps % xmm2 , % xmm5 - - - - - - - 1.00 - - shufps $0 , % xmm0 , % xmm0 - - 0.98 0.02 - - - - - - mulps % xmm7 , % xmm0 - - 0.99 0.01 - - - - - - addps % xmm5 , % xmm0 glm :: vec4 motor_application ( glm :: dualquat const & a , glm :: vec4 const & b ) { return glm :: mat3x4_cast ( a ) * b ; } GLM LLVM-MCA assembly and analysis Iterations : 100 Instructions : 14100 Total Cycles : 5435 Total uOps : 15700 Dispatch Width : 6 uOps Per Cycle : 2.89 IPC : 2.59 Block RThroughput : 38.5 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 5 0.50 * movss 4 (% rdi ), % xmm1 1 5 0.50 * movss (% rdi ), % xmm2 1 5 0.50 * movss 8 (% rdi ), % xmm15 1 5 0.50 * movss 12 (% rdi ), % xmm7 1 1 0.33 movaps % xmm2 , % xmm3 1 1 0.33 movaps % xmm1 , % xmm0 1 1 0.33 movaps % xmm1 , % xmm6 1 5 0.50 * movss (% rsi ), % xmm10 1 4 0.50 mulss % xmm1 , % xmm0 1 1 0.33 movaps % xmm7 , % xmm5 1 1 0.33 movaps % xmm2 , % xmm4 1 5 0.50 * movss 4 (% rsi ), % xmm9 1 4 0.50 mulss % xmm2 , % xmm3 1 1 0.33 movaps % xmm15 , % xmm14 1 1 0.33 movaps % xmm2 , % xmm11 1 5 0.50 * movss 8 (% rsi ), % xmm8 1 1 0.33 movaps % xmm15 , % xmm12 1 1 0.33 movaps % xmm15 , % xmm13 1 4 0.50 addss % xmm0 , % xmm3 1 1 0.33 movaps % xmm15 , % xmm0 1 4 0.50 mulss % xmm15 , % xmm0 1 4 0.50 addss % xmm0 , % xmm3 1 1 0.33 movaps % xmm7 , % xmm0 1 4 0.50 mulss % xmm7 , % xmm0 1 4 0.50 addss % xmm0 , % xmm3 1 1 0.33 movaps % xmm15 , % xmm0 1 11 3.00 divss % xmm3 , % xmm5 1 11 3.00 divss % xmm3 , % xmm6 1 11 3.00 divss % xmm3 , % xmm4 1 11 3.00 divss % xmm3 , % xmm14 1 1 0.33 movaps % xmm5 , % xmm3 1 1 0.33 movaps % xmm1 , % xmm5 1 4 0.50 mulss % xmm6 , % xmm5 1 4 0.50 addss % xmm6 , % xmm6 1 4 0.50 mulss % xmm3 , % xmm7 1 4 0.50 addss % xmm3 , % xmm3 1 4 0.50 mulss % xmm4 , % xmm11 1 4 0.50 addss % xmm4 , % xmm4 1 4 0.50 mulss % xmm6 , % xmm13 2 1 1.00 * movss % xmm5 , - 56 (% rsp ) 1 4 0.50 mulss % xmm3 , % xmm2 1 1 0.33 movaps % xmm1 , % xmm5 1 4 0.50 mulss % xmm3 , % xmm1 1 4 0.50 mulss % xmm4 , % xmm12 2 1 1.00 * movss % xmm11 , - 40 (% rsp ) 1 4 0.50 mulss % xmm4 , % xmm5 1 5 0.50 * movss 24 (% rdi ), % xmm11 2 1 1.00 * movss % xmm13 , - 16 (% rsp ) 1 4 0.50 mulss % xmm3 , % xmm15 1 5 0.50 * movss 16 (% rdi ), % xmm13 2 1 1.00 * movss % xmm2 , - 24 (% rsp ) 2 1 1.00 * movss % xmm1 , - 20 (% rsp ) 1 5 0.50 * movss 28 (% rdi ), % xmm1 2 1 1.00 * movss % xmm12 , - 28 (% rsp ) 1 5 0.50 * movss 20 (% rdi ), % xmm12 2 1 1.00 * movss % xmm1 , - 12 (% rsp ) 1 4 0.50 mulss % xmm14 , % xmm0 1 4 0.50 addss % xmm14 , % xmm14 1 5 0.50 * movss - 40 (% rsp ), % xmm1 1 1 0.33 movaps % xmm5 , % xmm2 1 4 0.50 subss % xmm15 , % xmm5 1 4 0.50 addss % xmm15 , % xmm2 1 5 0.50 * movss - 16 (% rsp ), % xmm15 1 4 0.50 addss % xmm7 , % xmm1 2 9 0.50 * subss - 56 (% rsp ), % xmm1 1 4 0.50 mulss % xmm10 , % xmm5 1 4 0.50 mulss % xmm9 , % xmm2 1 4 0.50 subss % xmm0 , % xmm1 1 4 0.50 mulss % xmm10 , % xmm1 1 4 0.50 addss % xmm2 , % xmm1 1 5 0.50 * movss - 28 (% rsp ), % xmm2 2 9 0.50 * subss - 20 (% rsp ), % xmm2 1 4 0.50 mulss % xmm8 , % xmm2 1 4 0.50 addss % xmm2 , % xmm1 1 5 0.50 * movss - 56 (% rsp ), % xmm2 1 4 0.50 addss % xmm7 , % xmm2 2 9 0.50 * subss - 40 (% rsp ), % xmm2 1 4 0.50 subss % xmm0 , % xmm2 1 4 0.50 addss % xmm7 , % xmm0 1 1 0.33 movaps % xmm3 , % xmm7 2 9 0.50 * subss - 40 (% rsp ), % xmm0 2 9 0.50 * subss - 56 (% rsp ), % xmm0 1 4 0.50 mulss % xmm13 , % xmm7 1 4 0.50 mulss % xmm9 , % xmm2 1 4 0.50 addss % xmm5 , % xmm2 1 5 0.50 * movss - 24 (% rsp ), % xmm5 1 4 0.50 addss % xmm15 , % xmm5 2 9 0.50 * subss - 24 (% rsp ), % xmm15 1 4 0.50 mulss % xmm8 , % xmm5 1 4 0.50 mulss % xmm9 , % xmm15 1 4 0.50 addss % xmm5 , % xmm2 1 5 0.50 * movss - 28 (% rsp ), % xmm5 2 9 0.50 * addss - 20 (% rsp ), % xmm5 1 4 0.50 mulss % xmm10 , % xmm5 1 1 1.00 unpcklps % xmm2 , % xmm1 1 4 0.50 addss % xmm15 , % xmm5 1 1 0.33 movaps % xmm0 , % xmm15 1 4 0.50 mulss % xmm8 , % xmm15 1 4 0.50 addss % xmm15 , % xmm5 1 5 0.50 * movss - 12 (% rsp ), % xmm15 1 1 0.33 movaps % xmm15 , % xmm0 1 4 0.50 mulss % xmm4 , % xmm0 1 4 0.50 subss % xmm7 , % xmm0 1 1 0.33 movaps % xmm14 , % xmm7 1 4 0.50 mulss % xmm12 , % xmm7 1 4 0.50 addss % xmm7 , % xmm0 1 1 0.33 movaps % xmm6 , % xmm7 1 4 0.50 mulss % xmm11 , % xmm7 1 4 0.50 subss % xmm7 , % xmm0 1 1 0.33 movaps % xmm14 , % xmm7 1 4 0.50 mulss % xmm13 , % xmm7 1 4 0.50 mulss % xmm15 , % xmm14 1 4 0.50 mulss % xmm0 , % xmm10 1 1 0.33 movaps % xmm15 , % xmm0 1 4 0.50 mulss % xmm6 , % xmm0 1 4 0.50 mulss % xmm13 , % xmm6 1 4 0.50 subss % xmm7 , % xmm0 1 1 0.33 movaps % xmm3 , % xmm7 1 4 0.50 mulss % xmm12 , % xmm7 1 4 0.50 addss % xmm6 , % xmm14 1 1 0.33 movaps % xmm1 , % xmm6 1 4 0.50 mulss % xmm11 , % xmm3 1 4 0.50 subss % xmm7 , % xmm0 1 1 0.33 movaps % xmm4 , % xmm7 1 4 0.50 mulss % xmm12 , % xmm4 1 4 0.50 mulss % xmm11 , % xmm7 1 4 0.50 subss % xmm4 , % xmm14 1 4 0.50 addss % xmm7 , % xmm0 2 7 0.50 * xorps . LC0 (% rip ), % xmm0 1 4 0.50 subss % xmm3 , % xmm14 1 4 0.50 mulss % xmm0 , % xmm9 1 4 0.50 mulss % xmm14 , % xmm8 1 4 0.50 subss % xmm10 , % xmm9 1 4 0.50 subss % xmm8 , % xmm9 1 1 1.00 unpcklps % xmm9 , % xmm5 1 1 1.00 movlhps % xmm5 , % xmm6 2 1 1.00 * movaps % xmm6 , - 56 (% rsp ) 1 5 0.50 * movq - 48 (% rsp ), % rax 1 5 0.50 * movq - 56 (% rsp ), % xmm0 1 1 1.00 movq % rax , % xmm1 1 1 1.00 * movq % rax , - 40 (% rsp ) Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - 12.00 41.03 41.04 15.49 15.51 9.00 29.93 - 6.00 Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - 0.50 0.50 - - - - movss 4 (% rdi ), % xmm1 - - - - 0.50 0.50 - - - - movss (% rdi ), % xmm2 - - - - 0.50 0.50 - - - - movss 8 (% rdi ), % xmm15 - - - - 0.50 0.50 - - - - movss 12 (% rdi ), % xmm7 - - - - - - - 1.00 - - movaps % xmm2 , % xmm3 - - - 0.01 - - - 0.99 - - movaps % xmm1 , % xmm0 - - 0.01 - - - - 0.99 - - movaps % xmm1 , % xmm6 - - - - 0.50 0.50 - - - - movss (% rsi ), % xmm10 - - 0.99 0.01 - - - - - - mulss % xmm1 , % xmm0 - - - - - - - 1.00 - - movaps % xmm7 , % xmm5 - - 0.01 - - - - 0.99 - - movaps % xmm2 , % xmm4 - - - - 0.50 0.50 - - - - movss 4 (% rsi ), % xmm9 - - 0.99 0.01 - - - - - - mulss % xmm2 , % xmm3 - - - - - - - 1.00 - - movaps % xmm15 , % xmm14 - - 0.01 - - - - 0.99 - - movaps % xmm2 , % xmm11 - - - - 0.49 0.51 - - - - movss 8 (% rsi ), % xmm8 - - 0.99 - - - - 0.01 - - movaps % xmm15 , % xmm12 - - - 0.01 - - - 0.99 - - movaps % xmm15 , % xmm13 - - 0.99 0.01 - - - - - - addss % xmm0 , % xmm3 - - 0.01 - - - - 0.99 - - movaps % xmm15 , % xmm0 - - 0.99 0.01 - - - - - - mulss % xmm15 , % xmm0 - - 0.99 0.01 - - - - - - addss % xmm0 , % xmm3 - - - - - - - 1.00 - - movaps % xmm7 , % xmm0 - - 0.99 0.01 - - - - - - mulss % xmm7 , % xmm0 - - 0.01 0.99 - - - - - - addss % xmm0 , % xmm3 - - 0.01 - - - - 0.99 - - movaps % xmm15 , % xmm0 - 3.00 1.00 - - - - - - - divss % xmm3 , % xmm5 - 3.00 1.00 - - - - - - - divss % xmm3 , % xmm6 - 3.00 1.00 - - - - - - - divss % xmm3 , % xmm4 - 3.00 1.00 - - - - - - - divss % xmm3 , % xmm14 - - - - - - - 1.00 - - movaps % xmm5 , % xmm3 - - - - - - - 1.00 - - movaps % xmm1 , % xmm5 - - - 1.00 - - - - - - mulss % xmm6 , % xmm5 - - 1.00 - - - - - - - addss % xmm6 , % xmm6 - - - 1.00 - - - - - - mulss % xmm3 , % xmm7 - - 1.00 - - - - - - - addss % xmm3 , % xmm3 - - 1.00 - - - - - - - mulss % xmm4 , % xmm11 - - - 1.00 - - - - - - addss % xmm4 , % xmm4 - - - 1.00 - - - - - - mulss % xmm6 , % xmm13 - - - - - 0.99 1.00 - - 0.01 movss % xmm5 , - 56 (% rsp ) - - - 1.00 - - - - - - mulss % xmm3 , % xmm2 - - 0.01 - - - - 0.99 - - movaps % xmm1 , % xmm5 - - 1.00 - - - - - - - mulss % xmm3 , % xmm1 - - - 1.00 - - - - - - mulss % xmm4 , % xmm12 - - - - 0.99 - 1.00 - - 0.01 movss % xmm11 , - 40 (% rsp ) - - 1.00 - - - - - - - mulss % xmm4 , % xmm5 - - - - 0.51 0.49 - - - - movss 24 (% rdi ), % xmm11 - - - - - 0.01 1.00 - - 0.99 movss % xmm13 , - 16 (% rsp ) - - - 1.00 - - - - - - mulss % xmm3 , % xmm15 - - - - 0.49 0.51 - - - - movss 16 (% rdi ), % xmm13 - - - - 0.01 0.99 1.00 - - - movss % xmm2 , - 24 (% rsp ) - - - - - - 1.00 - - 1.00 movss % xmm1 , - 20 (% rsp ) - - - - 0.51 0.49 - - - - movss 28 (% rdi ), % xmm1 - - - - - - 1.00 - - 1.00 movss % xmm12 , - 28 (% rsp ) - - - - 0.49 0.51 - - - - movss 20 (% rdi ), % xmm12 - - - - - - 1.00 - - 1.00 movss % xmm1 , - 12 (% rsp ) - - 1.00 - - - - - - - mulss % xmm14 , % xmm0 - - - 1.00 - - - - - - addss % xmm14 , % xmm14 - - - - 0.51 0.49 - - - - movss - 40 (% rsp ), % xmm1 - - - - - - - 1.00 - - movaps % xmm5 , % xmm2 - - - 1.00 - - - - - - subss % xmm15 , % xmm5 - - - 1.00 - - - - - - addss % xmm15 , % xmm2 - - - - 0.50 0.50 - - - - movss - 16 (% rsp ), % xmm15 - - 1.00 - - - - - - - addss % xmm7 , % xmm1 - - - 1.00 0.99 0.01 - - - - subss - 56 (% rsp ), % xmm1 - - - 1.00 - - - - - - mulss % xmm10 , % xmm5 - - - 1.00 - - - - - - mulss % xmm9 , % xmm2 - - - 1.00 - - - - - - subss % xmm0 , % xmm1 - - 0.01 0.99 - - - - - - mulss % xmm10 , % xmm1 - - 0.01 0.99 - - - - - - addss % xmm2 , % xmm1 - - - - 0.50 0.50 - - - - movss - 28 (% rsp ), % xmm2 - - 1.00 - 0.49 0.51 - - - - subss - 20 (% rsp ), % xmm2 - - 0.01 0.99 - - - - - - mulss % xmm8 , % xmm2 - - 0.01 0.99 - - - - - - addss % xmm2 , % xmm1 - - - - 0.51 0.49 - - - - movss - 56 (% rsp ), % xmm2 - - 1.00 - - - - - - - addss % xmm7 , % xmm2 - - - 1.00 0.50 0.50 - - - - subss - 40 (% rsp ), % xmm2 - - - 1.00 - - - - - - subss % xmm0 , % xmm2 - - 1.00 - - - - - - - addss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm3 , % xmm7 - - 1.00 - 0.50 0.50 - - - - subss - 40 (% rsp ), % xmm0 - - 1.00 - 0.50 0.50 - - - - subss - 56 (% rsp ), % xmm0 - - 1.00 - - - - - - - mulss % xmm13 , % xmm7 - - 0.01 0.99 - - - - - - mulss % xmm9 , % xmm2 - - 0.01 0.99 - - - - - - addss % xmm5 , % xmm2 - - - - 0.50 0.50 - - - - movss - 24 (% rsp ), % xmm5 - - 0.99 0.01 - - - - - - addss % xmm15 , % xmm5 - - 1.00 - 0.50 0.50 - - - - subss - 24 (% rsp ), % xmm15 - - 0.99 0.01 - - - - - - mulss % xmm8 , % xmm5 - - - 1.00 - - - - - - mulss % xmm9 , % xmm15 - - - 1.00 - - - - - - addss % xmm5 , % xmm2 - - - - 0.50 0.50 - - - - movss - 28 (% rsp ), % xmm5 - - - 1.00 0.50 0.50 - - - - addss - 20 (% rsp ), % xmm5 - - - 1.00 - - - - - - mulss % xmm10 , % xmm5 - - - - - - - 1.00 - - unpcklps % xmm2 , % xmm1 - - - 1.00 - - - - - - addss % xmm15 , % xmm5 - - - - - - - 1.00 - - movaps % xmm0 , % xmm15 - - 0.01 0.99 - - - - - - mulss % xmm8 , % xmm15 - - 0.01 0.99 - - - - - - addss % xmm15 , % xmm5 - - - - 0.50 0.50 - - - - movss - 12 (% rsp ), % xmm15 - - - - - - - 1.00 - - movaps % xmm15 , % xmm0 - - - 1.00 - - - - - - mulss % xmm4 , % xmm0 - - - 1.00 - - - - - - subss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm14 , % xmm7 - - 1.00 - - - - - - - mulss % xmm12 , % xmm7 - - - 1.00 - - - - - - addss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm6 , % xmm7 - - 1.00 - - - - - - - mulss % xmm11 , % xmm7 - - 0.99 0.01 - - - - - - subss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm14 , % xmm7 - - - 1.00 - - - - - - mulss % xmm13 , % xmm7 - - 1.00 - - - - - - - mulss % xmm15 , % xmm14 - - 0.99 0.01 - - - - - - mulss % xmm0 , % xmm10 - - - - - - - 1.00 - - movaps % xmm15 , % xmm0 - - - 1.00 - - - - - - mulss % xmm6 , % xmm0 - - 1.00 - - - - - - - mulss % xmm13 , % xmm6 - - 1.00 - - - - - - - subss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm3 , % xmm7 - - 1.00 - - - - - - - mulss % xmm12 , % xmm7 - - 1.00 - - - - - - - addss % xmm6 , % xmm14 - - - - - - - 1.00 - - movaps % xmm1 , % xmm6 - - 1.00 - - - - - - - mulss % xmm11 , % xmm3 - - 0.99 0.01 - - - - - - subss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm4 , % xmm7 - - - 1.00 - - - - - - mulss % xmm12 , % xmm4 - - 1.00 - - - - - - - mulss % xmm11 , % xmm7 - - - 1.00 - - - - - - subss % xmm4 , % xmm14 - - 0.99 0.01 - - - - - - addss % xmm7 , % xmm0 - - - - 0.50 0.50 - 1.00 - - xorps . LC0 (% rip ), % xmm0 - - - 1.00 - - - - - - subss % xmm3 , % xmm14 - - - 1.00 - - - - - - mulss % xmm0 , % xmm9 - - 0.01 0.99 - - - - - - mulss % xmm14 , % xmm8 - - 1.00 - - - - - - - subss % xmm10 , % xmm9 - - - 1.00 - - - - - - subss % xmm8 , % xmm9 - - - - - - - 1.00 - - unpcklps % xmm9 , % xmm5 - - - - - - - 1.00 - - movlhps % xmm5 , % xmm6 - - - - - - 1.00 - - 1.00 movaps % xmm6 , - 56 (% rsp ) - - - - 0.50 0.50 - - - - movq - 48 (% rsp ), % rax - - - - 0.50 0.50 - - - - movq - 56 (% rsp ), % xmm0 - - - - - - - 1.00 - - movq % rax , % xmm1 - - - - - 0.01 1.00 - - 0.99 movq % rax , - 40 (% rsp ) Note An RTM implementation of the dual-quat application is not provided (internally, RTM uses a type called qvvf which stores scale, translation, and rotation as separate components). The qvvf cannot be interpolated the same way as a motor or dual quaternion so it is omitted from this portion of the analysis.","title":"Performance"},{"location":"perf/#rotor-composition","text":"kln :: rotor ab ( kln :: rotor const & a , kln :: rotor const & b ) { return a * b ; } Klein LLVM-MCA assembly and analysis Iterations : 100 Instructions : 2400 Total Cycles : 821 Total uOps : 2400 Dispatch Width : 6 uOps Per Cycle : 2.92 IPC : 2.92 Block RThroughput : 8.0 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 6 0.50 * movaps (% rdi ), % xmm0 1 6 0.50 * movaps (% rsi ), % xmm1 1 1 0.33 movaps % xmm0 , % xmm2 1 1 1.00 shufps $0 , % xmm0 , % xmm2 1 4 0.50 mulps % xmm1 , % xmm2 1 1 0.33 movaps % xmm0 , % xmm3 1 1 1.00 shufps $121 , % xmm0 , % xmm3 1 1 0.33 movaps % xmm1 , % xmm4 1 1 1.00 shufps $157 , % xmm1 , % xmm4 1 4 0.50 mulps % xmm3 , % xmm4 1 4 0.50 subps % xmm4 , % xmm2 1 1 0.33 movaps % xmm0 , % xmm3 1 1 1.00 shufps $230 , % xmm0 , % xmm3 1 1 0.33 movaps % xmm1 , % xmm4 1 1 1.00 shufps $2 , % xmm1 , % xmm4 1 4 0.50 mulps % xmm3 , % xmm4 1 1 1.00 shufps $159 , % xmm0 , % xmm0 1 1 1.00 shufps $123 , % xmm1 , % xmm1 1 4 0.50 mulps % xmm0 , % xmm1 1 4 0.50 addps % xmm4 , % xmm1 1 1 0.25 movl $ - 2147483648 , % eax 1 1 1.00 movd % eax , % xmm0 1 1 0.33 pxor % xmm1 , % xmm0 1 4 0.50 addps % xmm2 , % xmm0 Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - - 6.49 6.50 1.00 1.00 - 8.01 1.00 - Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - - 1.00 - - - - movaps (% rdi ), % xmm0 - - - - 1.00 - - - - - movaps (% rsi ), % xmm1 - - 0.50 0.50 - - - - - - movaps % xmm0 , % xmm2 - - - - - - - 1.00 - - shufps $0 , % xmm0 , % xmm2 - - 0.03 0.97 - - - - - - mulps % xmm1 , % xmm2 - - 0.50 0.50 - - - - - - movaps % xmm0 , % xmm3 - - - - - - - 1.00 - - shufps $121 , % xmm0 , % xmm3 - - 0.51 0.48 - - - 0.01 - - movaps % xmm1 , % xmm4 - - - - - - - 1.00 - - shufps $157 , % xmm1 , % xmm4 - - 0.98 0.02 - - - - - - mulps % xmm3 , % xmm4 - - 0.94 0.06 - - - - - - subps % xmm4 , % xmm2 - - 0.50 0.50 - - - - - - movaps % xmm0 , % xmm3 - - - - - - - 1.00 - - shufps $230 , % xmm0 , % xmm3 - - 0.50 0.50 - - - - - - movaps % xmm1 , % xmm4 - - - - - - - 1.00 - - shufps $2 , % xmm1 , % xmm4 - - 0.51 0.49 - - - - - - mulps % xmm3 , % xmm4 - - - - - - - 1.00 - - shufps $159 , % xmm0 , % xmm0 - - - - - - - 1.00 - - shufps $123 , % xmm1 , % xmm1 - - 0.53 0.47 - - - - - - mulps % xmm0 , % xmm1 - - 0.02 0.98 - - - - - - addps % xmm4 , % xmm1 - - - - - - - - 1.00 - movl $ - 2147483648 , % eax - - - - - - - 1.00 - - movd % eax , % xmm0 - - 0.48 0.52 - - - - - - pxor % xmm1 , % xmm0 - - 0.49 0.51 - - - - - - addps % xmm2 , % xmm0 For comparison, here is the assembly and analysis corresponding to semantically identical code from RTM . rtm :: quatf ab ( rtm :: quatf const & a , rtm :: quatf const & b ) { return rtm :: quat_mul ( a , b ); } RTM LLVM-MCA assembly and analysis Iterations : 100 Instructions : 2300 Total Cycles : 824 Total uOps : 2600 Dispatch Width : 6 uOps Per Cycle : 3.16 IPC : 2.79 Block RThroughput : 7.0 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 6 0.50 * movaps (% rdi ), % xmm0 1 6 0.50 * movaps (% rsi ), % xmm2 1 1 0.33 movaps % xmm2 , % xmm1 1 1 1.00 shufps $0 , % xmm2 , % xmm1 1 1 0.33 movaps % xmm2 , % xmm3 1 1 1.00 shufps $85 , % xmm2 , % xmm3 1 1 0.33 movaps % xmm2 , % xmm4 1 1 1.00 shufps $170 , % xmm2 , % xmm4 1 1 1.00 shufps $255 , % xmm2 , % xmm2 1 4 0.50 mulps % xmm0 , % xmm2 1 1 0.33 movaps % xmm0 , % xmm5 1 1 1.00 shufps $27 , % xmm0 , % xmm5 1 4 0.50 mulps % xmm5 , % xmm1 1 1 1.00 shufps $177 , % xmm5 , % xmm5 1 4 0.50 mulps % xmm3 , % xmm5 2 7 0.50 * xorps . LCPI0_0 (% rip ), % xmm1 1 1 1.00 shufps $177 , % xmm0 , % xmm0 1 4 0.50 mulps % xmm4 , % xmm0 2 7 0.50 * xorps . LCPI0_1 (% rip ), % xmm5 2 7 0.50 * xorps . LCPI0_2 (% rip ), % xmm0 1 4 0.50 addps % xmm2 , % xmm1 1 4 0.50 addps % xmm5 , % xmm0 1 4 0.50 addps % xmm1 , % xmm0 Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - - 6.49 6.50 2.50 2.50 - 8.01 - - Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - 0.50 0.50 - - - - movaps (% rdi ), % xmm0 - - - - 0.49 0.51 - - - - movaps (% rsi ), % xmm2 - - 0.03 0.96 - - - 0.01 - - movaps % xmm2 , % xmm1 - - - - - - - 1.00 - - shufps $0 , % xmm2 , % xmm1 - - 0.95 0.05 - - - - - - movaps % xmm2 , % xmm3 - - - - - - - 1.00 - - shufps $85 , % xmm2 , % xmm3 - - 0.04 0.96 - - - - - - movaps % xmm2 , % xmm4 - - - - - - - 1.00 - - shufps $170 , % xmm2 , % xmm4 - - - - - - - 1.00 - - shufps $255 , % xmm2 , % xmm2 - - 0.49 0.51 - - - - - - mulps % xmm0 , % xmm2 - - 0.95 0.05 - - - - - - movaps % xmm0 , % xmm5 - - - - - - - 1.00 - - shufps $27 , % xmm0 , % xmm5 - - 0.52 0.48 - - - - - - mulps % xmm5 , % xmm1 - - - - - - - 1.00 - - shufps $177 , % xmm5 , % xmm5 - - 0.49 0.51 - - - - - - mulps % xmm3 , % xmm5 - - 0.48 0.52 0.50 0.50 - - - - xorps . LCPI0_0 (% rip ), % xmm1 - - - - - - - 1.00 - - shufps $177 , % xmm0 , % xmm0 - - 0.52 0.48 - - - - - - mulps % xmm4 , % xmm0 - - 0.48 0.52 0.50 0.50 - - - - xorps . LCPI0_1 (% rip ), % xmm5 - - - - 0.51 0.49 - 1.00 - - xorps . LCPI0_2 (% rip ), % xmm0 - - 0.51 0.49 - - - - - - addps % xmm2 , % xmm1 - - 0.52 0.48 - - - - - - addps % xmm5 , % xmm0 - - 0.51 0.49 - - - - - - addps % xmm1 , % xmm0 Finally, for good measure, here is the same procedure and analysis for GLM glm :: quat rotor_composition ( glm :: quat const & a , glm :: quat const & b ) { return a * b ; } GLM LLVM-MCA assembly and analysis Iterations : 100 Instructions : 5700 Total Cycles : 1522 Total uOps : 5800 Dispatch Width : 6 uOps Per Cycle : 3.81 IPC : 3.75 Block RThroughput : 14.0 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 5 0.50 * movss (% rdi ), % xmm4 1 5 0.50 * movss 4 (% rdi ), % xmm3 1 5 0.50 * movss 8 (% rdi ), % xmm2 1 5 0.50 * movss 12 (% rdi ), % xmm0 1 5 0.50 * movss (% rsi ), % xmm9 1 5 0.50 * movss 4 (% rsi ), % xmm8 1 5 0.50 * movss 8 (% rsi ), % xmm7 1 5 0.50 * movss 12 (% rsi ), % xmm10 1 1 0.33 movaps % xmm0 , % xmm5 1 1 0.33 movaps % xmm4 , % xmm1 1 1 0.33 movaps % xmm0 , % xmm6 1 4 0.50 mulss % xmm10 , % xmm1 1 1 0.33 movaps % xmm2 , % xmm11 1 4 0.50 mulss % xmm9 , % xmm5 1 4 0.50 mulss % xmm8 , % xmm6 1 4 0.50 mulss % xmm10 , % xmm11 1 4 0.50 addss % xmm1 , % xmm5 1 1 0.33 movaps % xmm3 , % xmm1 1 4 0.50 mulss % xmm7 , % xmm1 1 4 0.50 addss % xmm1 , % xmm5 1 1 0.33 movaps % xmm2 , % xmm1 1 4 0.50 mulss % xmm8 , % xmm1 1 4 0.50 subss % xmm1 , % xmm5 1 1 0.33 movaps % xmm3 , % xmm1 1 4 0.50 mulss % xmm10 , % xmm1 1 4 0.50 addss % xmm1 , % xmm6 1 1 0.33 movaps % xmm2 , % xmm1 1 4 0.50 mulss % xmm9 , % xmm1 1 4 0.50 mulss % xmm7 , % xmm2 1 4 0.50 addss % xmm1 , % xmm6 1 1 0.33 movaps % xmm4 , % xmm1 1 4 0.50 mulss % xmm7 , % xmm1 1 4 0.50 subss % xmm1 , % xmm6 1 1 0.33 movaps % xmm0 , % xmm1 1 4 0.50 mulss % xmm7 , % xmm1 1 4 0.50 mulss % xmm10 , % xmm0 1 1 1.00 unpcklps % xmm6 , % xmm5 1 1 0.33 movaps % xmm5 , % xmm7 1 4 0.50 addss % xmm11 , % xmm1 1 1 0.33 movaps % xmm4 , % xmm11 1 4 0.50 mulss % xmm8 , % xmm11 1 4 0.50 mulss % xmm9 , % xmm4 1 4 0.50 addss % xmm11 , % xmm1 1 1 0.33 movaps % xmm3 , % xmm11 1 4 0.50 mulss % xmm8 , % xmm3 1 4 0.50 subss % xmm4 , % xmm0 1 4 0.50 mulss % xmm9 , % xmm11 1 4 0.50 subss % xmm3 , % xmm0 1 4 0.50 subss % xmm11 , % xmm1 1 4 0.50 subss % xmm2 , % xmm0 1 1 1.00 unpcklps % xmm0 , % xmm1 1 1 1.00 movlhps % xmm1 , % xmm7 2 1 1.00 * movaps % xmm7 , - 40 (% rsp ) 1 5 0.50 * movq - 32 (% rsp ), % rax 1 5 0.50 * movq - 40 (% rsp ), % xmm0 1 1 1.00 movq % rax , % xmm1 1 1 1.00 * movq % rax , - 16 (% rsp ) Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - - 15.00 15.00 5.01 5.01 2.00 15.00 - 1.98 Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - - 1.00 - - - - movss (% rdi ), % xmm4 - - - - 1.00 - - - - - movss 4 (% rdi ), % xmm3 - - - - 0.01 0.99 - - - - movss 8 (% rdi ), % xmm2 - - - - 0.99 0.01 - - - - movss 12 (% rdi ), % xmm0 - - - - - 1.00 - - - - movss (% rsi ), % xmm9 - - - - 1.00 - - - - - movss 4 (% rsi ), % xmm8 - - - - 0.98 0.02 - - - - movss 8 (% rsi ), % xmm7 - - - - 0.02 0.98 - - - - movss 12 (% rsi ), % xmm10 - - 0.48 - - - - 0.52 - - movaps % xmm0 , % xmm5 - - - 0.49 - - - 0.51 - - movaps % xmm4 , % xmm1 - - 0.98 0.01 - - - 0.01 - - movaps % xmm0 , % xmm6 - - 0.98 0.02 - - - - - - mulss % xmm10 , % xmm1 - - 0.01 0.01 - - - 0.98 - - movaps % xmm2 , % xmm11 - - 0.50 0.50 - - - - - - mulss % xmm9 , % xmm5 - - 1.00 - - - - - - - mulss % xmm8 , % xmm6 - - 0.50 0.50 - - - - - - mulss % xmm10 , % xmm11 - - 0.49 0.51 - - - - - - addss % xmm1 , % xmm5 - - - 0.01 - - - 0.99 - - movaps % xmm3 , % xmm1 - - 0.99 0.01 - - - - - - mulss % xmm7 , % xmm1 - - - 1.00 - - - - - - addss % xmm1 , % xmm5 - - - - - - - 1.00 - - movaps % xmm2 , % xmm1 - - 1.00 - - - - - - - mulss % xmm8 , % xmm1 - - 0.01 0.99 - - - - - - subss % xmm1 , % xmm5 - - 0.01 - - - - 0.99 - - movaps % xmm3 , % xmm1 - - 0.50 0.50 - - - - - - mulss % xmm10 , % xmm1 - - 0.49 0.51 - - - - - - addss % xmm1 , % xmm6 - - - - - - - 1.00 - - movaps % xmm2 , % xmm1 - - 0.99 0.01 - - - - - - mulss % xmm9 , % xmm1 - - 0.01 0.99 - - - - - - mulss % xmm7 , % xmm2 - - 0.50 0.50 - - - - - - addss % xmm1 , % xmm6 - - - - - - - 1.00 - - movaps % xmm4 , % xmm1 - - 1.00 - - - - - - - mulss % xmm7 , % xmm1 - - - 1.00 - - - - - - subss % xmm1 , % xmm6 - - - - - - - 1.00 - - movaps % xmm0 , % xmm1 - - 1.00 - - - - - - - mulss % xmm7 , % xmm1 - - 0.50 0.50 - - - - - - mulss % xmm10 , % xmm0 - - - - - - - 1.00 - - unpcklps % xmm6 , % xmm5 - - - - - - - 1.00 - - movaps % xmm5 , % xmm7 - - 0.50 0.50 - - - - - - addss % xmm11 , % xmm1 - - - - - - - 1.00 - - movaps % xmm4 , % xmm11 - - 0.99 0.01 - - - - - - mulss % xmm8 , % xmm11 - - 0.02 0.98 - - - - - - mulss % xmm9 , % xmm4 - - 0.02 0.98 - - - - - - addss % xmm11 , % xmm1 - - - - - - - 1.00 - - movaps % xmm3 , % xmm11 - - 0.98 0.02 - - - - - - mulss % xmm8 , % xmm3 - - 0.01 0.99 - - - - - - subss % xmm4 , % xmm0 - - 0.51 0.49 - - - - - - mulss % xmm9 , % xmm11 - - 0.02 0.98 - - - - - - subss % xmm3 , % xmm0 - - - 1.00 - - - - - - subss % xmm11 , % xmm1 - - 0.01 0.99 - - - - - - subss % xmm2 , % xmm0 - - - - - - - 1.00 - - unpcklps % xmm0 , % xmm1 - - - - - - - 1.00 - - movlhps % xmm1 , % xmm7 - - - - 0.01 - 1.00 - - 0.99 movaps % xmm7 , - 40 (% rsp ) - - - - - 1.00 - - - - movq - 32 (% rsp ), % rax - - - - 1.00 - - - - - movq - 40 (% rsp ), % xmm0 - - - - - - - 1.00 - - movq % rax , % xmm1 - - - - - 0.01 1.00 - - 0.99 movq % rax , - 16 (% rsp )","title":"Rotor Composition"},{"location":"perf/#motor-point-application-dual-quat-application","text":"kln :: point motor_application ( kln :: motor const & m , kln :: point const & p ) { return m ( p ); } Klein LLVM-MCA assembly and analysis Iterations : 100 Instructions : 5900 Total Cycles : 1831 Total uOps : 5900 Dispatch Width : 6 uOps Per Cycle : 3.22 IPC : 3.22 Block RThroughput : 13.5 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 6 0.50 * movaps (% rdi ), % xmm3 1 6 0.50 * movaps 16 (% rdi ), % xmm6 1 1 0.33 movaps % xmm3 , % xmm12 1 1 1.00 shufps $0 , % xmm3 , % xmm12 1 1 0.33 movaps % xmm3 , % xmm11 1 1 0.33 movaps % xmm3 , % xmm10 1 1 0.33 movaps % xmm12 , % xmm8 1 1 0.33 movaps % xmm12 , % xmm9 1 1 0.33 movaps % xmm3 , % xmm4 1 1 0.33 movaps % xmm3 , % xmm1 1 1 0.33 movaps % xmm6 , % xmm7 1 4 0.50 mulps % xmm6 , % xmm12 1 1 0.33 movaps % xmm6 , % xmm0 1 1 1.00 shufps $0 , % xmm6 , % xmm6 1 4 0.50 mulps % xmm3 , % xmm6 1 1 1.00 shufps $156 , % xmm3 , % xmm3 1 4 0.50 mulps % xmm3 , % xmm11 1 1 1.00 shufps $120 , % xmm10 , % xmm10 1 4 0.50 mulps % xmm10 , % xmm8 1 4 0.50 subps % xmm8 , % xmm11 1 4 0.50 mulps % xmm3 , % xmm9 1 4 0.50 mulps % xmm10 , % xmm4 1 4 0.50 addps % xmm9 , % xmm4 1 4 0.50 mulps % xmm1 , % xmm1 1 1 0.33 movaps % xmm1 , % xmm5 1 1 1.00 shufps $1 , % xmm1 , % xmm5 1 4 0.50 addps % xmm1 , % xmm5 1 1 0.33 movaps % xmm1 , % xmm2 1 1 1.00 shufps $158 , % xmm1 , % xmm2 1 1 1.00 shufps $123 , % xmm1 , % xmm1 1 4 0.50 addps % xmm2 , % xmm1 1 1 0.25 movl $ - 2147483648 , % eax 1 1 1.00 movd % eax , % xmm2 1 1 0.33 pxor % xmm1 , % xmm2 1 6 0.50 * movaps . LCPI3_0 (% rip ), % xmm1 1 4 0.50 mulps % xmm1 , % xmm11 1 4 0.50 mulps % xmm1 , % xmm4 1 4 0.50 subps % xmm2 , % xmm5 1 1 1.00 shufps $156 , % xmm7 , % xmm7 1 4 0.50 mulps % xmm10 , % xmm7 1 4 0.50 subps % xmm12 , % xmm7 1 1 1.00 shufps $120 , % xmm0 , % xmm0 1 4 0.50 mulps % xmm3 , % xmm0 1 4 0.50 subps % xmm0 , % xmm7 1 4 0.50 subps % xmm6 , % xmm7 1 4 0.50 mulps % xmm1 , % xmm7 1 6 0.50 * movaps (% rsi ), % xmm0 1 1 0.33 movaps % xmm0 , % xmm1 1 1 1.00 shufps $156 , % xmm0 , % xmm1 1 4 0.50 mulps % xmm11 , % xmm1 1 1 0.33 movaps % xmm0 , % xmm2 1 1 1.00 shufps $120 , % xmm0 , % xmm2 1 4 0.50 mulps % xmm4 , % xmm2 1 4 0.50 addps % xmm1 , % xmm2 1 4 0.50 mulps % xmm0 , % xmm5 1 4 0.50 addps % xmm2 , % xmm5 1 1 1.00 shufps $0 , % xmm0 , % xmm0 1 4 0.50 mulps % xmm7 , % xmm0 1 4 0.50 addps % xmm5 , % xmm0 Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - - 18.01 18.01 2.00 2.00 - 17.98 1.00 - Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - - 1.00 - - - - movaps (% rdi ), % xmm3 - - - - 1.00 - - - - - movaps 16 (% rdi ), % xmm6 - - 0.01 0.98 - - - 0.01 - - movaps % xmm3 , % xmm12 - - - - - - - 1.00 - - shufps $0 , % xmm3 , % xmm12 - - - 1.00 - - - - - - movaps % xmm3 , % xmm11 - - 0.01 0.49 - - - 0.50 - - movaps % xmm3 , % xmm10 - - 0.49 0.01 - - - 0.50 - - movaps % xmm12 , % xmm8 - - - 0.50 - - - 0.50 - - movaps % xmm12 , % xmm9 - - - 0.51 - - - 0.49 - - movaps % xmm3 , % xmm4 - - 0.50 0.01 - - - 0.49 - - movaps % xmm3 , % xmm1 - - 0.01 0.50 - - - 0.49 - - movaps % xmm6 , % xmm7 - - - 1.00 - - - - - - mulps % xmm6 , % xmm12 - - - - - - - 1.00 - - movaps % xmm6 , % xmm0 - - - - - - - 1.00 - - shufps $0 , % xmm6 , % xmm6 - - 0.50 0.50 - - - - - - mulps % xmm3 , % xmm6 - - - - - - - 1.00 - - shufps $156 , % xmm3 , % xmm3 - - 0.98 0.02 - - - - - - mulps % xmm3 , % xmm11 - - - - - - - 1.00 - - shufps $120 , % xmm10 , % xmm10 - - 0.02 0.98 - - - - - - mulps % xmm10 , % xmm8 - - 0.03 0.97 - - - - - - subps % xmm8 , % xmm11 - - 0.01 0.99 - - - - - - mulps % xmm3 , % xmm9 - - 0.49 0.51 - - - - - - mulps % xmm10 , % xmm4 - - 0.49 0.51 - - - - - - addps % xmm9 , % xmm4 - - 0.51 0.49 - - - - - - mulps % xmm1 , % xmm1 - - 0.49 - - - - 0.51 - - movaps % xmm1 , % xmm5 - - - - - - - 1.00 - - shufps $1 , % xmm1 , % xmm5 - - 0.99 0.01 - - - - - - addps % xmm1 , % xmm5 - - 0.01 0.50 - - - 0.49 - - movaps % xmm1 , % xmm2 - - - - - - - 1.00 - - shufps $158 , % xmm1 , % xmm2 - - - - - - - 1.00 - - shufps $123 , % xmm1 , % xmm1 - - 0.03 0.97 - - - - - - addps % xmm2 , % xmm1 - - - - - - - - 1.00 - movl $ - 2147483648 , % eax - - - - - - - 1.00 - - movd % eax , % xmm2 - - 0.99 0.01 - - - - - - pxor % xmm1 , % xmm2 - - - - - 1.00 - - - - movaps . LCPI3_0 (% rip ), % xmm1 - - 0.52 0.48 - - - - - - mulps % xmm1 , % xmm11 - - 0.01 0.99 - - - - - - mulps % xmm1 , % xmm4 - - 0.98 0.02 - - - - - - subps % xmm2 , % xmm5 - - - - - - - 1.00 - - shufps $156 , % xmm7 , % xmm7 - - 0.49 0.51 - - - - - - mulps % xmm10 , % xmm7 - - 0.50 0.50 - - - - - - subps % xmm12 , % xmm7 - - - - - - - 1.00 - - shufps $120 , % xmm0 , % xmm0 - - 0.52 0.48 - - - - - - mulps % xmm3 , % xmm0 - - 0.50 0.50 - - - - - - subps % xmm0 , % xmm7 - - 1.00 - - - - - - - subps % xmm6 , % xmm7 - - 1.00 - - - - - - - mulps % xmm1 , % xmm7 - - - - 1.00 - - - - - movaps (% rsi ), % xmm0 - - 0.48 0.52 - - - - - - movaps % xmm0 , % xmm1 - - - - - - - 1.00 - - shufps $156 , % xmm0 , % xmm1 - - 0.99 0.01 - - - - - - mulps % xmm11 , % xmm1 - - - 1.00 - - - - - - movaps % xmm0 , % xmm2 - - - - - - - 1.00 - - shufps $120 , % xmm0 , % xmm2 - - 0.50 0.50 - - - - - - mulps % xmm4 , % xmm2 - - 0.99 0.01 - - - - - - addps % xmm1 , % xmm2 - - 0.01 0.99 - - - - - - mulps % xmm0 , % xmm5 - - 0.99 0.01 - - - - - - addps % xmm2 , % xmm5 - - - - - - - 1.00 - - shufps $0 , % xmm0 , % xmm0 - - 0.98 0.02 - - - - - - mulps % xmm7 , % xmm0 - - 0.99 0.01 - - - - - - addps % xmm5 , % xmm0 glm :: vec4 motor_application ( glm :: dualquat const & a , glm :: vec4 const & b ) { return glm :: mat3x4_cast ( a ) * b ; } GLM LLVM-MCA assembly and analysis Iterations : 100 Instructions : 14100 Total Cycles : 5435 Total uOps : 15700 Dispatch Width : 6 uOps Per Cycle : 2.89 IPC : 2.59 Block RThroughput : 38.5 Instruction Info : [ 1 ]: # uOps [ 2 ]: Latency [ 3 ]: RThroughput [ 4 ]: MayLoad [ 5 ]: MayStore [ 6 ]: HasSideEffects ( U ) [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] Instructions : 1 5 0.50 * movss 4 (% rdi ), % xmm1 1 5 0.50 * movss (% rdi ), % xmm2 1 5 0.50 * movss 8 (% rdi ), % xmm15 1 5 0.50 * movss 12 (% rdi ), % xmm7 1 1 0.33 movaps % xmm2 , % xmm3 1 1 0.33 movaps % xmm1 , % xmm0 1 1 0.33 movaps % xmm1 , % xmm6 1 5 0.50 * movss (% rsi ), % xmm10 1 4 0.50 mulss % xmm1 , % xmm0 1 1 0.33 movaps % xmm7 , % xmm5 1 1 0.33 movaps % xmm2 , % xmm4 1 5 0.50 * movss 4 (% rsi ), % xmm9 1 4 0.50 mulss % xmm2 , % xmm3 1 1 0.33 movaps % xmm15 , % xmm14 1 1 0.33 movaps % xmm2 , % xmm11 1 5 0.50 * movss 8 (% rsi ), % xmm8 1 1 0.33 movaps % xmm15 , % xmm12 1 1 0.33 movaps % xmm15 , % xmm13 1 4 0.50 addss % xmm0 , % xmm3 1 1 0.33 movaps % xmm15 , % xmm0 1 4 0.50 mulss % xmm15 , % xmm0 1 4 0.50 addss % xmm0 , % xmm3 1 1 0.33 movaps % xmm7 , % xmm0 1 4 0.50 mulss % xmm7 , % xmm0 1 4 0.50 addss % xmm0 , % xmm3 1 1 0.33 movaps % xmm15 , % xmm0 1 11 3.00 divss % xmm3 , % xmm5 1 11 3.00 divss % xmm3 , % xmm6 1 11 3.00 divss % xmm3 , % xmm4 1 11 3.00 divss % xmm3 , % xmm14 1 1 0.33 movaps % xmm5 , % xmm3 1 1 0.33 movaps % xmm1 , % xmm5 1 4 0.50 mulss % xmm6 , % xmm5 1 4 0.50 addss % xmm6 , % xmm6 1 4 0.50 mulss % xmm3 , % xmm7 1 4 0.50 addss % xmm3 , % xmm3 1 4 0.50 mulss % xmm4 , % xmm11 1 4 0.50 addss % xmm4 , % xmm4 1 4 0.50 mulss % xmm6 , % xmm13 2 1 1.00 * movss % xmm5 , - 56 (% rsp ) 1 4 0.50 mulss % xmm3 , % xmm2 1 1 0.33 movaps % xmm1 , % xmm5 1 4 0.50 mulss % xmm3 , % xmm1 1 4 0.50 mulss % xmm4 , % xmm12 2 1 1.00 * movss % xmm11 , - 40 (% rsp ) 1 4 0.50 mulss % xmm4 , % xmm5 1 5 0.50 * movss 24 (% rdi ), % xmm11 2 1 1.00 * movss % xmm13 , - 16 (% rsp ) 1 4 0.50 mulss % xmm3 , % xmm15 1 5 0.50 * movss 16 (% rdi ), % xmm13 2 1 1.00 * movss % xmm2 , - 24 (% rsp ) 2 1 1.00 * movss % xmm1 , - 20 (% rsp ) 1 5 0.50 * movss 28 (% rdi ), % xmm1 2 1 1.00 * movss % xmm12 , - 28 (% rsp ) 1 5 0.50 * movss 20 (% rdi ), % xmm12 2 1 1.00 * movss % xmm1 , - 12 (% rsp ) 1 4 0.50 mulss % xmm14 , % xmm0 1 4 0.50 addss % xmm14 , % xmm14 1 5 0.50 * movss - 40 (% rsp ), % xmm1 1 1 0.33 movaps % xmm5 , % xmm2 1 4 0.50 subss % xmm15 , % xmm5 1 4 0.50 addss % xmm15 , % xmm2 1 5 0.50 * movss - 16 (% rsp ), % xmm15 1 4 0.50 addss % xmm7 , % xmm1 2 9 0.50 * subss - 56 (% rsp ), % xmm1 1 4 0.50 mulss % xmm10 , % xmm5 1 4 0.50 mulss % xmm9 , % xmm2 1 4 0.50 subss % xmm0 , % xmm1 1 4 0.50 mulss % xmm10 , % xmm1 1 4 0.50 addss % xmm2 , % xmm1 1 5 0.50 * movss - 28 (% rsp ), % xmm2 2 9 0.50 * subss - 20 (% rsp ), % xmm2 1 4 0.50 mulss % xmm8 , % xmm2 1 4 0.50 addss % xmm2 , % xmm1 1 5 0.50 * movss - 56 (% rsp ), % xmm2 1 4 0.50 addss % xmm7 , % xmm2 2 9 0.50 * subss - 40 (% rsp ), % xmm2 1 4 0.50 subss % xmm0 , % xmm2 1 4 0.50 addss % xmm7 , % xmm0 1 1 0.33 movaps % xmm3 , % xmm7 2 9 0.50 * subss - 40 (% rsp ), % xmm0 2 9 0.50 * subss - 56 (% rsp ), % xmm0 1 4 0.50 mulss % xmm13 , % xmm7 1 4 0.50 mulss % xmm9 , % xmm2 1 4 0.50 addss % xmm5 , % xmm2 1 5 0.50 * movss - 24 (% rsp ), % xmm5 1 4 0.50 addss % xmm15 , % xmm5 2 9 0.50 * subss - 24 (% rsp ), % xmm15 1 4 0.50 mulss % xmm8 , % xmm5 1 4 0.50 mulss % xmm9 , % xmm15 1 4 0.50 addss % xmm5 , % xmm2 1 5 0.50 * movss - 28 (% rsp ), % xmm5 2 9 0.50 * addss - 20 (% rsp ), % xmm5 1 4 0.50 mulss % xmm10 , % xmm5 1 1 1.00 unpcklps % xmm2 , % xmm1 1 4 0.50 addss % xmm15 , % xmm5 1 1 0.33 movaps % xmm0 , % xmm15 1 4 0.50 mulss % xmm8 , % xmm15 1 4 0.50 addss % xmm15 , % xmm5 1 5 0.50 * movss - 12 (% rsp ), % xmm15 1 1 0.33 movaps % xmm15 , % xmm0 1 4 0.50 mulss % xmm4 , % xmm0 1 4 0.50 subss % xmm7 , % xmm0 1 1 0.33 movaps % xmm14 , % xmm7 1 4 0.50 mulss % xmm12 , % xmm7 1 4 0.50 addss % xmm7 , % xmm0 1 1 0.33 movaps % xmm6 , % xmm7 1 4 0.50 mulss % xmm11 , % xmm7 1 4 0.50 subss % xmm7 , % xmm0 1 1 0.33 movaps % xmm14 , % xmm7 1 4 0.50 mulss % xmm13 , % xmm7 1 4 0.50 mulss % xmm15 , % xmm14 1 4 0.50 mulss % xmm0 , % xmm10 1 1 0.33 movaps % xmm15 , % xmm0 1 4 0.50 mulss % xmm6 , % xmm0 1 4 0.50 mulss % xmm13 , % xmm6 1 4 0.50 subss % xmm7 , % xmm0 1 1 0.33 movaps % xmm3 , % xmm7 1 4 0.50 mulss % xmm12 , % xmm7 1 4 0.50 addss % xmm6 , % xmm14 1 1 0.33 movaps % xmm1 , % xmm6 1 4 0.50 mulss % xmm11 , % xmm3 1 4 0.50 subss % xmm7 , % xmm0 1 1 0.33 movaps % xmm4 , % xmm7 1 4 0.50 mulss % xmm12 , % xmm4 1 4 0.50 mulss % xmm11 , % xmm7 1 4 0.50 subss % xmm4 , % xmm14 1 4 0.50 addss % xmm7 , % xmm0 2 7 0.50 * xorps . LC0 (% rip ), % xmm0 1 4 0.50 subss % xmm3 , % xmm14 1 4 0.50 mulss % xmm0 , % xmm9 1 4 0.50 mulss % xmm14 , % xmm8 1 4 0.50 subss % xmm10 , % xmm9 1 4 0.50 subss % xmm8 , % xmm9 1 1 1.00 unpcklps % xmm9 , % xmm5 1 1 1.00 movlhps % xmm5 , % xmm6 2 1 1.00 * movaps % xmm6 , - 56 (% rsp ) 1 5 0.50 * movq - 48 (% rsp ), % rax 1 5 0.50 * movq - 56 (% rsp ), % xmm0 1 1 1.00 movq % rax , % xmm1 1 1 1.00 * movq % rax , - 40 (% rsp ) Resources : [ 0 ] - SKLDivider [ 1 ] - SKLFPDivider [ 2 ] - SKLPort0 [ 3 ] - SKLPort1 [ 4 ] - SKLPort2 [ 5 ] - SKLPort3 [ 6 ] - SKLPort4 [ 7 ] - SKLPort5 [ 8 ] - SKLPort6 [ 9 ] - SKLPort7 Resource pressure per iteration : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] - 12.00 41.03 41.04 15.49 15.51 9.00 29.93 - 6.00 Resource pressure by instruction : [ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] Instructions : - - - - 0.50 0.50 - - - - movss 4 (% rdi ), % xmm1 - - - - 0.50 0.50 - - - - movss (% rdi ), % xmm2 - - - - 0.50 0.50 - - - - movss 8 (% rdi ), % xmm15 - - - - 0.50 0.50 - - - - movss 12 (% rdi ), % xmm7 - - - - - - - 1.00 - - movaps % xmm2 , % xmm3 - - - 0.01 - - - 0.99 - - movaps % xmm1 , % xmm0 - - 0.01 - - - - 0.99 - - movaps % xmm1 , % xmm6 - - - - 0.50 0.50 - - - - movss (% rsi ), % xmm10 - - 0.99 0.01 - - - - - - mulss % xmm1 , % xmm0 - - - - - - - 1.00 - - movaps % xmm7 , % xmm5 - - 0.01 - - - - 0.99 - - movaps % xmm2 , % xmm4 - - - - 0.50 0.50 - - - - movss 4 (% rsi ), % xmm9 - - 0.99 0.01 - - - - - - mulss % xmm2 , % xmm3 - - - - - - - 1.00 - - movaps % xmm15 , % xmm14 - - 0.01 - - - - 0.99 - - movaps % xmm2 , % xmm11 - - - - 0.49 0.51 - - - - movss 8 (% rsi ), % xmm8 - - 0.99 - - - - 0.01 - - movaps % xmm15 , % xmm12 - - - 0.01 - - - 0.99 - - movaps % xmm15 , % xmm13 - - 0.99 0.01 - - - - - - addss % xmm0 , % xmm3 - - 0.01 - - - - 0.99 - - movaps % xmm15 , % xmm0 - - 0.99 0.01 - - - - - - mulss % xmm15 , % xmm0 - - 0.99 0.01 - - - - - - addss % xmm0 , % xmm3 - - - - - - - 1.00 - - movaps % xmm7 , % xmm0 - - 0.99 0.01 - - - - - - mulss % xmm7 , % xmm0 - - 0.01 0.99 - - - - - - addss % xmm0 , % xmm3 - - 0.01 - - - - 0.99 - - movaps % xmm15 , % xmm0 - 3.00 1.00 - - - - - - - divss % xmm3 , % xmm5 - 3.00 1.00 - - - - - - - divss % xmm3 , % xmm6 - 3.00 1.00 - - - - - - - divss % xmm3 , % xmm4 - 3.00 1.00 - - - - - - - divss % xmm3 , % xmm14 - - - - - - - 1.00 - - movaps % xmm5 , % xmm3 - - - - - - - 1.00 - - movaps % xmm1 , % xmm5 - - - 1.00 - - - - - - mulss % xmm6 , % xmm5 - - 1.00 - - - - - - - addss % xmm6 , % xmm6 - - - 1.00 - - - - - - mulss % xmm3 , % xmm7 - - 1.00 - - - - - - - addss % xmm3 , % xmm3 - - 1.00 - - - - - - - mulss % xmm4 , % xmm11 - - - 1.00 - - - - - - addss % xmm4 , % xmm4 - - - 1.00 - - - - - - mulss % xmm6 , % xmm13 - - - - - 0.99 1.00 - - 0.01 movss % xmm5 , - 56 (% rsp ) - - - 1.00 - - - - - - mulss % xmm3 , % xmm2 - - 0.01 - - - - 0.99 - - movaps % xmm1 , % xmm5 - - 1.00 - - - - - - - mulss % xmm3 , % xmm1 - - - 1.00 - - - - - - mulss % xmm4 , % xmm12 - - - - 0.99 - 1.00 - - 0.01 movss % xmm11 , - 40 (% rsp ) - - 1.00 - - - - - - - mulss % xmm4 , % xmm5 - - - - 0.51 0.49 - - - - movss 24 (% rdi ), % xmm11 - - - - - 0.01 1.00 - - 0.99 movss % xmm13 , - 16 (% rsp ) - - - 1.00 - - - - - - mulss % xmm3 , % xmm15 - - - - 0.49 0.51 - - - - movss 16 (% rdi ), % xmm13 - - - - 0.01 0.99 1.00 - - - movss % xmm2 , - 24 (% rsp ) - - - - - - 1.00 - - 1.00 movss % xmm1 , - 20 (% rsp ) - - - - 0.51 0.49 - - - - movss 28 (% rdi ), % xmm1 - - - - - - 1.00 - - 1.00 movss % xmm12 , - 28 (% rsp ) - - - - 0.49 0.51 - - - - movss 20 (% rdi ), % xmm12 - - - - - - 1.00 - - 1.00 movss % xmm1 , - 12 (% rsp ) - - 1.00 - - - - - - - mulss % xmm14 , % xmm0 - - - 1.00 - - - - - - addss % xmm14 , % xmm14 - - - - 0.51 0.49 - - - - movss - 40 (% rsp ), % xmm1 - - - - - - - 1.00 - - movaps % xmm5 , % xmm2 - - - 1.00 - - - - - - subss % xmm15 , % xmm5 - - - 1.00 - - - - - - addss % xmm15 , % xmm2 - - - - 0.50 0.50 - - - - movss - 16 (% rsp ), % xmm15 - - 1.00 - - - - - - - addss % xmm7 , % xmm1 - - - 1.00 0.99 0.01 - - - - subss - 56 (% rsp ), % xmm1 - - - 1.00 - - - - - - mulss % xmm10 , % xmm5 - - - 1.00 - - - - - - mulss % xmm9 , % xmm2 - - - 1.00 - - - - - - subss % xmm0 , % xmm1 - - 0.01 0.99 - - - - - - mulss % xmm10 , % xmm1 - - 0.01 0.99 - - - - - - addss % xmm2 , % xmm1 - - - - 0.50 0.50 - - - - movss - 28 (% rsp ), % xmm2 - - 1.00 - 0.49 0.51 - - - - subss - 20 (% rsp ), % xmm2 - - 0.01 0.99 - - - - - - mulss % xmm8 , % xmm2 - - 0.01 0.99 - - - - - - addss % xmm2 , % xmm1 - - - - 0.51 0.49 - - - - movss - 56 (% rsp ), % xmm2 - - 1.00 - - - - - - - addss % xmm7 , % xmm2 - - - 1.00 0.50 0.50 - - - - subss - 40 (% rsp ), % xmm2 - - - 1.00 - - - - - - subss % xmm0 , % xmm2 - - 1.00 - - - - - - - addss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm3 , % xmm7 - - 1.00 - 0.50 0.50 - - - - subss - 40 (% rsp ), % xmm0 - - 1.00 - 0.50 0.50 - - - - subss - 56 (% rsp ), % xmm0 - - 1.00 - - - - - - - mulss % xmm13 , % xmm7 - - 0.01 0.99 - - - - - - mulss % xmm9 , % xmm2 - - 0.01 0.99 - - - - - - addss % xmm5 , % xmm2 - - - - 0.50 0.50 - - - - movss - 24 (% rsp ), % xmm5 - - 0.99 0.01 - - - - - - addss % xmm15 , % xmm5 - - 1.00 - 0.50 0.50 - - - - subss - 24 (% rsp ), % xmm15 - - 0.99 0.01 - - - - - - mulss % xmm8 , % xmm5 - - - 1.00 - - - - - - mulss % xmm9 , % xmm15 - - - 1.00 - - - - - - addss % xmm5 , % xmm2 - - - - 0.50 0.50 - - - - movss - 28 (% rsp ), % xmm5 - - - 1.00 0.50 0.50 - - - - addss - 20 (% rsp ), % xmm5 - - - 1.00 - - - - - - mulss % xmm10 , % xmm5 - - - - - - - 1.00 - - unpcklps % xmm2 , % xmm1 - - - 1.00 - - - - - - addss % xmm15 , % xmm5 - - - - - - - 1.00 - - movaps % xmm0 , % xmm15 - - 0.01 0.99 - - - - - - mulss % xmm8 , % xmm15 - - 0.01 0.99 - - - - - - addss % xmm15 , % xmm5 - - - - 0.50 0.50 - - - - movss - 12 (% rsp ), % xmm15 - - - - - - - 1.00 - - movaps % xmm15 , % xmm0 - - - 1.00 - - - - - - mulss % xmm4 , % xmm0 - - - 1.00 - - - - - - subss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm14 , % xmm7 - - 1.00 - - - - - - - mulss % xmm12 , % xmm7 - - - 1.00 - - - - - - addss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm6 , % xmm7 - - 1.00 - - - - - - - mulss % xmm11 , % xmm7 - - 0.99 0.01 - - - - - - subss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm14 , % xmm7 - - - 1.00 - - - - - - mulss % xmm13 , % xmm7 - - 1.00 - - - - - - - mulss % xmm15 , % xmm14 - - 0.99 0.01 - - - - - - mulss % xmm0 , % xmm10 - - - - - - - 1.00 - - movaps % xmm15 , % xmm0 - - - 1.00 - - - - - - mulss % xmm6 , % xmm0 - - 1.00 - - - - - - - mulss % xmm13 , % xmm6 - - 1.00 - - - - - - - subss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm3 , % xmm7 - - 1.00 - - - - - - - mulss % xmm12 , % xmm7 - - 1.00 - - - - - - - addss % xmm6 , % xmm14 - - - - - - - 1.00 - - movaps % xmm1 , % xmm6 - - 1.00 - - - - - - - mulss % xmm11 , % xmm3 - - 0.99 0.01 - - - - - - subss % xmm7 , % xmm0 - - - - - - - 1.00 - - movaps % xmm4 , % xmm7 - - - 1.00 - - - - - - mulss % xmm12 , % xmm4 - - 1.00 - - - - - - - mulss % xmm11 , % xmm7 - - - 1.00 - - - - - - subss % xmm4 , % xmm14 - - 0.99 0.01 - - - - - - addss % xmm7 , % xmm0 - - - - 0.50 0.50 - 1.00 - - xorps . LC0 (% rip ), % xmm0 - - - 1.00 - - - - - - subss % xmm3 , % xmm14 - - - 1.00 - - - - - - mulss % xmm0 , % xmm9 - - 0.01 0.99 - - - - - - mulss % xmm14 , % xmm8 - - 1.00 - - - - - - - subss % xmm10 , % xmm9 - - - 1.00 - - - - - - subss % xmm8 , % xmm9 - - - - - - - 1.00 - - unpcklps % xmm9 , % xmm5 - - - - - - - 1.00 - - movlhps % xmm5 , % xmm6 - - - - - - 1.00 - - 1.00 movaps % xmm6 , - 56 (% rsp ) - - - - 0.50 0.50 - - - - movq - 48 (% rsp ), % rax - - - - 0.50 0.50 - - - - movq - 56 (% rsp ), % xmm0 - - - - - - - 1.00 - - movq % rax , % xmm1 - - - - - 0.01 1.00 - - 0.99 movq % rax , - 40 (% rsp ) Note An RTM implementation of the dual-quat application is not provided (internally, RTM uses a type called qvvf which stores scale, translation, and rotation as separate components). The qvvf cannot be interpolated the same way as a motor or dual quaternion so it is omitted from this portion of the analysis.","title":"Motor-Point Application (Dual Quat Application)"},{"location":"quickstart/","text":"Klein is header only, so you may use it by adding the contents of the public directory to your include path. If you use cmake , you may opt to link the klein target interface. If you have CMake 3.15 or later, you can use the following snippet to easily fetch Klein into your build tree: include ( FetchContent ) # This tracks the latest commit on the master branch of the Klein # repository. Instead of `origin/master`, you can specify a specific # commit hash or tag. FetchContent_Declare ( klein GIT_REPOSITORY https://github.com/jeremyong/Klein.git GIT_TAG origin/master ) FetchContent_MakeAvailable ( klein ) # Now, you can use target_link_libraries(your_lib PUBLIC klein::klein) # If you can target SSE4.1 (~97% market penetration), you can link against # the target klein::klein_sse42 instead. The primary \"catch-all\" header provided can be included using #include <klein/klein.hpp> . The klein.hpp header includes the following: File Purpose direction.hpp Defines the direction class. dual.hpp Defines the dual class. plane.hpp Defines the plane class. point.hpp Defines the point class. line.hpp Defines the line , branch , and ideal_line classes. rotor.hpp Defines the rotor class. translator.hpp Defines the translator class. motor.hpp Defines the motor class. dual.hpp Defines the dual class. geometric_product.hpp Defines the geometric product between all supported entities. meet.hpp Defines the exterior product between all supported entities. join.hpp Defines the regressive product between all supported entities. inner_product.hpp Defines the inner product between all supported entities. project.hpp Defines the project function to project between entities. exp_log.hpp Defines the exp and log functions between supported entities. Here's a simple snippet to get you started: #include <klein/klein.hpp> // Create a rotor representing a pi/2 rotation about the z-axis // Normalization is done automatically rotor r { M_PI * 0.5f , 0.f , 0.f , 1.f }; // Create a translator that represents a translation of 1 unit // in the yz-direction. Normalization is done automatically. translator t { 1.f , 0.f , 1.f , 1.f }; // Create a motor that combines the action of the rotation and // translation above. motor m = r * t ; // Construct a point at position (1, 0, 0) point p1 { 1 , 0 , 0 }; // Apply the motor to the point. This is equivalent to the conjugation // operator m * p1 * ~m where * is the geometric product and ~ is the // reverse operation. point p2 = m ( p1 ); // We could have also written p2 = m * p1 * ~m but this will be slower // because the call operator eliminates some redundant or cancelled // computation. // point p2 = m * p1 * ~m; // We can access the coordinates of p2 with p2.x(), p2.y(), p2.z(), // and p2.w(), where p.2w() is the homogeneous coordinate (initialized // to one). It is recommended to localize coordinate access in this way // as it requires unpacking storage that may occupy an SSE register. // Rotors and motors can produce 4x4 transformation matrices suitable // for upload to a shader or for interoperability with code expecting // matrices as part of its interface. The matrix returned in this way // is a column-major matrix mat4x4 m_matrix = m . as_mat4x4 (); The spherical interpolation (aka slerp) employed to produce smooth incremental rotations/transformations in the quaternion algebra is available in Klein using the exp and log functions as in the snippet below. // Blend between two motors with a parameter t in the range [0, 1] kln :: motor blend_motors ( kln :: motor const & a , kln :: motor const & b , float t ) { // Starting from a, the motor needed to get to b is b * ~a. // To perform this motion continuously, we can take the principal // branch of the logarithm of b * ~a, and subdivide it before // re-exponentiating it to produce a motor again. // In practice, this should be cached whenever possible. line motor_step = log ( b * ~ a ); // exp(log(m)) = exp(t*log(m) + (1 - t)*log(m)) // = exp(t*(log(m))) * exp((1 - t)*log(m)) motor_step *= t ; // The exponential of the step here can be cached if the blend occurs // with fixed steps toward the final motor. Compose the interpolated // result with the start motor to produce the intermediate blended // motor. return exp ( motor_step ) * a ; }","title":"Quick Start"},{"location":"references/","text":"Klein is deeply indebted to several members of the GA community and their work. Beyond the works cited here, the author stands of the shoulders of giants (Felix Klein , Sophus Lie, Arthur Cayley, William Rowan Hamilton, Julius Pl\u00fccker, and William Kingdon Clifford, among others). [1] Gunn, Charles G. (2019). Course notes Geometric Algebra for Computer Graphics, SIGGRAPH 2019. arXiv link [2] Steven De Keninck and Charles Gunn. (2019). SIGGRAPH 2019 Geometric Algebra Course. youtube link [3] Leo Dorst, Daniel Fontijne, Stephen Mann. (2007) Geometric Algebra for Computer Science. Burlington, MA: Morgan Kaufmann Publishers Inc.","title":"References"},{"location":"shell/","text":"In the sym directory resides code for a lightweight computer algebra system that can evaluate geometric algebra expressions symbolically. This tool was used to validate the implementation of Klein and verify various optimizations in its SSE routines (nearly every operation is fully vectorized). The tool is compiled by default as the executable klein_shell when Klein is built as a standalone project. If you wish to enable it if transitively including the project, you'll need to set the CMake option KLEIN_BUILD_SYM to ON . To use the shell, you can either run it interactively from a terminal, or you can pipe text files to it. For example, suppose we had a file that looked like: # test . klein # My klein test ( a0 e123 + a1 e021 + a2 e013 + a3 e032 ) * ( b0 + b1 e12 + b2 e31 + b3 e23 ) Running the command cat test.klein | ./klein_shell will produce the following output: # test . klein # My klein test a0 b0 e0 + - a0 b3 e012 + a0 b2 e013 + - a0 b1 e023 Whitespace and lines starting with a # are echoed back in the output and the expressions provided are evaluated and simplified symbolically. Numerical constants are permitted. The grammar is relatively simple and the Klein shell is a work in progress. Several examples are provided in the repository to examine to understand proper usage. They are stored in the scripts folder and are used to both demonstrate GA concepts and validate existing code and test cases.","title":"Klein Shell"},{"location":"api/dir/","text":"group dir Directions in \\(\\mathbf{P}(\\mathbb{R}^3_{3, 0, 1})\\) are represented using points at infinity (homogeneous coordinate 0). Having a homogeneous coordinate of zero ensures that directions are translation-invariant. Summary Members Descriptions public direction () = default public direction (float x,float y,float z) noexcept Create a normalized direction. public direction (__m128 p3) noexcept public explicit direction (float * data) noexcept Data should point to four floats with memory layout (0.f, x, y, z) where the zero occupies the lowest address in memory. public float x () const noexcept public float y () const noexcept public float z () const noexcept public void normalize () noexcept Normalize this direction by dividing all components by the magnitude (by default, rsqrtps is used with a single Newton-Raphson refinement iteration) public direction normalized () const noexcept Return a normalized copy of this direction. public direction &KLN_VEC_CALL operator+= (direction b) noexcept Direction addition. public direction &KLN_VEC_CALL operator-= (direction b) noexcept Direction subtraction. public direction & operator*= (float s) noexcept Direction uniform scale. public direction & operator*= (int s) noexcept Direction uniform scale. public direction & operator/= (float s) noexcept Direction uniform inverse scale. public direction & operator/= (int s) noexcept Direction uniform inverse scale. public direction KLN_VEC_CALL operator+ (direction a,direction b) noexcept Direction addition. public direction KLN_VEC_CALL operator- (direction a,direction b) noexcept Direction subtraction. public direction KLN_VEC_CALL operator* (direction d,float s) noexcept Direction uniform scale. public direction KLN_VEC_CALL operator* (float s,direction d) noexcept Direction uniform scale. public direction KLN_VEC_CALL operator* (direction d,int s) noexcept Direction uniform scale. public direction KLN_VEC_CALL operator* (int s,direction d) noexcept Direction uniform scale. public direction KLN_VEC_CALL operator/ (direction d,float s) noexcept Direction uniform inverse scale. public direction KLN_VEC_CALL operator/ (direction d,int s) noexcept Direction uniform inverse scale. public direction operator- (direction d) noexcept Unary minus. Members direction () = default direction (float x,float y,float z) noexcept Create a normalized direction. direction (__m128 p3) noexcept explicit direction (float * data) noexcept Data should point to four floats with memory layout (0.f, x, y, z) where the zero occupies the lowest address in memory. float x () const noexcept float y () const noexcept float z () const noexcept void normalize () noexcept Normalize this direction by dividing all components by the magnitude (by default, rsqrtps is used with a single Newton-Raphson refinement iteration) direction normalized () const noexcept Return a normalized copy of this direction. direction &KLN_VEC_CALL operator+= (direction b) noexcept Direction addition. direction &KLN_VEC_CALL operator-= (direction b) noexcept Direction subtraction. direction & operator*= (float s) noexcept Direction uniform scale. direction & operator*= (int s) noexcept Direction uniform scale. direction & operator/= (float s) noexcept Direction uniform inverse scale. direction & operator/= (int s) noexcept Direction uniform inverse scale. direction KLN_VEC_CALL operator+ (direction a,direction b) noexcept Direction addition. direction KLN_VEC_CALL operator- (direction a,direction b) noexcept Direction subtraction. direction KLN_VEC_CALL operator* (direction d,float s) noexcept Direction uniform scale. direction KLN_VEC_CALL operator* (float s,direction d) noexcept Direction uniform scale. direction KLN_VEC_CALL operator* (direction d,int s) noexcept Direction uniform scale. direction KLN_VEC_CALL operator* (int s,direction d) noexcept Direction uniform scale. direction KLN_VEC_CALL operator/ (direction d,float s) noexcept Direction uniform inverse scale. direction KLN_VEC_CALL operator/ (direction d,int s) noexcept Direction uniform inverse scale. direction operator- (direction d) noexcept Unary minus.","title":"Direction"},{"location":"api/dir/#group__dir","text":"Directions in \\(\\mathbf{P}(\\mathbb{R}^3_{3, 0, 1})\\) are represented using points at infinity (homogeneous coordinate 0). Having a homogeneous coordinate of zero ensures that directions are translation-invariant.","title":"group dir"},{"location":"api/dir/#summary","text":"Members Descriptions public direction () = default public direction (float x,float y,float z) noexcept Create a normalized direction. public direction (__m128 p3) noexcept public explicit direction (float * data) noexcept Data should point to four floats with memory layout (0.f, x, y, z) where the zero occupies the lowest address in memory. public float x () const noexcept public float y () const noexcept public float z () const noexcept public void normalize () noexcept Normalize this direction by dividing all components by the magnitude (by default, rsqrtps is used with a single Newton-Raphson refinement iteration) public direction normalized () const noexcept Return a normalized copy of this direction. public direction &KLN_VEC_CALL operator+= (direction b) noexcept Direction addition. public direction &KLN_VEC_CALL operator-= (direction b) noexcept Direction subtraction. public direction & operator*= (float s) noexcept Direction uniform scale. public direction & operator*= (int s) noexcept Direction uniform scale. public direction & operator/= (float s) noexcept Direction uniform inverse scale. public direction & operator/= (int s) noexcept Direction uniform inverse scale. public direction KLN_VEC_CALL operator+ (direction a,direction b) noexcept Direction addition. public direction KLN_VEC_CALL operator- (direction a,direction b) noexcept Direction subtraction. public direction KLN_VEC_CALL operator* (direction d,float s) noexcept Direction uniform scale. public direction KLN_VEC_CALL operator* (float s,direction d) noexcept Direction uniform scale. public direction KLN_VEC_CALL operator* (direction d,int s) noexcept Direction uniform scale. public direction KLN_VEC_CALL operator* (int s,direction d) noexcept Direction uniform scale. public direction KLN_VEC_CALL operator/ (direction d,float s) noexcept Direction uniform inverse scale. public direction KLN_VEC_CALL operator/ (direction d,int s) noexcept Direction uniform inverse scale. public direction operator- (direction d) noexcept Unary minus.","title":"Summary"},{"location":"api/dir/#members","text":"","title":"Members"},{"location":"api/dir/#group__dir_1gac86167cefc9b8118a8f894aaba99f9a5","text":"","title":"direction() = default"},{"location":"api/dir/#group__dir_1ga8fc796733d32a69230136b8376003fca","text":"Create a normalized direction.","title":"direction(float x,float y,float z) noexcept"},{"location":"api/dir/#group__dir_1ga7cc439bc60bbbe279bbda37f2e0d139b","text":"","title":"direction(__m128 p3) noexcept"},{"location":"api/dir/#group__dir_1ga42ce139ace571176acabbce21d6c64b2","text":"Data should point to four floats with memory layout (0.f, x, y, z) where the zero occupies the lowest address in memory.","title":"explicit  direction(float * data) noexcept"},{"location":"api/dir/#group__dir_1ga721087c2056a33cd780c678ae0ec39dd","text":"","title":"float  x() const noexcept"},{"location":"api/dir/#group__dir_1ga40bc7052a639d57afde7a860c1631638","text":"","title":"float  y() const noexcept"},{"location":"api/dir/#group__dir_1ga1e16d3ed0ff945d0d1cbf1e6458d334b","text":"","title":"float  z() const noexcept"},{"location":"api/dir/#group__dir_1ga143cd2cfeb94860ce1d47b9735064802","text":"Normalize this direction by dividing all components by the magnitude (by default, rsqrtps is used with a single Newton-Raphson refinement iteration)","title":"void  normalize() noexcept"},{"location":"api/dir/#group__dir_1ga1f97cae228749958e81d2747a3cdb4c2","text":"Return a normalized copy of this direction.","title":"direction  normalized() const noexcept"},{"location":"api/dir/#group__dir_1gabf098bdf982bbd9572d9fb09a5f76786","text":"Direction addition.","title":"direction &amp;KLN_VEC_CALL  operator+=(direction b) noexcept"},{"location":"api/dir/#group__dir_1ga4bd0650e5c363ec427a4021b678f0567","text":"Direction subtraction.","title":"direction &amp;KLN_VEC_CALL  operator-=(direction b) noexcept"},{"location":"api/dir/#group__dir_1ga8f2c363e3b6ce34e18451b6c716be97a","text":"Direction uniform scale.","title":"direction &amp;  operator*=(float s) noexcept"},{"location":"api/dir/#group__dir_1ga6a07c40530461b7a4c94d2aff1371217","text":"Direction uniform scale.","title":"direction &amp;  operator*=(int s) noexcept"},{"location":"api/dir/#group__dir_1ga9cac6b5beba3d2e2b0ce1e9a5158c25f","text":"Direction uniform inverse scale.","title":"direction &amp;  operator/=(float s) noexcept"},{"location":"api/dir/#group__dir_1ga2717db218937fdb1b88aba24d3abd189","text":"Direction uniform inverse scale.","title":"direction &amp;  operator/=(int s) noexcept"},{"location":"api/dir/#group__dir_1ga3aa93423517b128de3d64111201220ce","text":"Direction addition.","title":"direction KLN_VEC_CALL  operator+(direction a,direction b) noexcept"},{"location":"api/dir/#group__dir_1gacdc4f7208ad657c450708efcc7fe27d0","text":"Direction subtraction.","title":"direction KLN_VEC_CALL  operator-(direction a,direction b) noexcept"},{"location":"api/dir/#group__dir_1ga5d061f57e3a9f92620f6e90d5dbcb8cb","text":"Direction uniform scale.","title":"direction KLN_VEC_CALL  operator*(direction d,float s) noexcept"},{"location":"api/dir/#group__dir_1ga0a2f15a137d3c9ef3e5b83e3eee71f9a","text":"Direction uniform scale.","title":"direction KLN_VEC_CALL  operator*(float s,direction d) noexcept"},{"location":"api/dir/#group__dir_1ga9d4aadcb32609919e0a2614b1041fdf0","text":"Direction uniform scale.","title":"direction KLN_VEC_CALL  operator*(direction d,int s) noexcept"},{"location":"api/dir/#group__dir_1ga0229ad2276f2d9a7f07baee7ee3d7582","text":"Direction uniform scale.","title":"direction KLN_VEC_CALL  operator*(int s,direction d) noexcept"},{"location":"api/dir/#group__dir_1ga4473202567a1e1bf3a0929c33d723f52","text":"Direction uniform inverse scale.","title":"direction KLN_VEC_CALL  operator/(direction d,float s) noexcept"},{"location":"api/dir/#group__dir_1ga2a8d9ef9111a21d1a55fe08e2c656317","text":"Direction uniform inverse scale.","title":"direction KLN_VEC_CALL  operator/(direction d,int s) noexcept"},{"location":"api/dir/#group__dir_1ga65b1fe0cfac3611b65b78924cb5a61ac","text":"Unary minus.","title":"direction  operator-(direction d) noexcept"},{"location":"api/dot/","text":"group dot The symmetric inner product takes two arguments and contracts the lower graded element to the greater graded element. If lower graded element spans an index that is not contained in the higher graded element, the result is annihilated. Otherwise, the result is the part of the higher graded element \"most unlike\" the lower graded element. Thus, the symmetric inner product can be thought of as a bidirectional contraction operator. There is some merit in providing both a left and right contraction operator for explicitness. However, when using Klein, it's generally clear what the interpretation of the symmetric inner product is with respect to the projection on various entities. Angle between planes kln :: plane a { x1 , y1 , z1 , d1 }; kln :: plane b { x2 , y2 , z2 , d2 }; // Compute the cos of the angle between two planes float cos_ang = a | b ; Line to plane through point kln :: point a { x1 , y1 , z1 }; kln :: plane b { x2 , y2 , z2 , d2 }; // The line l contains a and the shortest path from a to plane b. line l = a | b ; Summary Members Descriptions public float operator\\| (plane a,plane b) noexcept public plane operator\\| (plane a,line b) noexcept public plane operator\\| (line b,plane a) noexcept public plane operator\\| (plane a,ideal_line b) noexcept public plane operator\\| (ideal_line b,plane a) noexcept public line operator\\| (plane a,point b) noexcept public line operator\\| (point a,plane b) noexcept public float operator\\| (line a,line b) noexcept public plane operator\\| (point a,line b) noexcept public plane operator\\| (line b,point a) noexcept public float operator\\| (point a,point b) noexcept Members float operator| (plane a,plane b) noexcept plane operator| (plane a,line b) noexcept plane operator| (line b,plane a) noexcept plane operator| (plane a,ideal_line b) noexcept plane operator| (ideal_line b,plane a) noexcept line operator| (plane a,point b) noexcept line operator| (point a,plane b) noexcept float operator| (line a,line b) noexcept plane operator| (point a,line b) noexcept plane operator| (line b,point a) noexcept float operator| (point a,point b) noexcept","title":"Inner Product"},{"location":"api/dot/#group__dot","text":"The symmetric inner product takes two arguments and contracts the lower graded element to the greater graded element. If lower graded element spans an index that is not contained in the higher graded element, the result is annihilated. Otherwise, the result is the part of the higher graded element \"most unlike\" the lower graded element. Thus, the symmetric inner product can be thought of as a bidirectional contraction operator. There is some merit in providing both a left and right contraction operator for explicitness. However, when using Klein, it's generally clear what the interpretation of the symmetric inner product is with respect to the projection on various entities. Angle between planes kln :: plane a { x1 , y1 , z1 , d1 }; kln :: plane b { x2 , y2 , z2 , d2 }; // Compute the cos of the angle between two planes float cos_ang = a | b ; Line to plane through point kln :: point a { x1 , y1 , z1 }; kln :: plane b { x2 , y2 , z2 , d2 }; // The line l contains a and the shortest path from a to plane b. line l = a | b ;","title":"group dot"},{"location":"api/dot/#summary","text":"Members Descriptions public float operator\\| (plane a,plane b) noexcept public plane operator\\| (plane a,line b) noexcept public plane operator\\| (line b,plane a) noexcept public plane operator\\| (plane a,ideal_line b) noexcept public plane operator\\| (ideal_line b,plane a) noexcept public line operator\\| (plane a,point b) noexcept public line operator\\| (point a,plane b) noexcept public float operator\\| (line a,line b) noexcept public plane operator\\| (point a,line b) noexcept public plane operator\\| (line b,point a) noexcept public float operator\\| (point a,point b) noexcept","title":"Summary"},{"location":"api/dot/#members","text":"","title":"Members"},{"location":"api/dot/#group__dot_1gad318da9ce7f0d17c6be4a28606f7055d","text":"","title":"float  operator|(plane a,plane b) noexcept"},{"location":"api/dot/#group__dot_1gac5eb4e0be057f05d06fdb47af9c67884","text":"","title":"plane  operator|(plane a,line b) noexcept"},{"location":"api/dot/#group__dot_1ga6e653adaf2281eb98ea2fb859adebf91","text":"","title":"plane  operator|(line b,plane a) noexcept"},{"location":"api/dot/#group__dot_1ga95c5016a18aac7ec611fbb69ade553eb","text":"","title":"plane  operator|(plane a,ideal_line b) noexcept"},{"location":"api/dot/#group__dot_1ga3672748f41be5a0c523e0434bb48da7d","text":"","title":"plane  operator|(ideal_line b,plane a) noexcept"},{"location":"api/dot/#group__dot_1gaf165d820d2709047750f9f9c4e627dc2","text":"","title":"line  operator|(plane a,point b) noexcept"},{"location":"api/dot/#group__dot_1ga21190874d649c1828316b8133c8c7ec0","text":"","title":"line  operator|(point a,plane b) noexcept"},{"location":"api/dot/#group__dot_1gab9b2443f7c67a96f08b03ce749565305","text":"","title":"float  operator|(line a,line b) noexcept"},{"location":"api/dot/#group__dot_1ga4319b71d30d700e2579c26e181fd16fd","text":"","title":"plane  operator|(point a,line b) noexcept"},{"location":"api/dot/#group__dot_1ga36111b62f962203bb1a964cd6417b371","text":"","title":"plane  operator|(line b,point a) noexcept"},{"location":"api/dot/#group__dot_1ga4ad7845d5581052aca22d5547ef7d5b1","text":"","title":"float  operator|(point a,point b) noexcept"},{"location":"api/dual/","text":"group dual The Poincar\u00e9 Dual of an element is the \"subspace complement\" of the argument with respect to the pseudoscalar in the exterior algebra. In practice, it is a relabeling of the coordinates to their dual-coordinates and is used most often to implement a \"join\" operation in terms of the exterior product of the duals of each operand. Ex: The dual of the point \\(\\mathbf{e}_{123} + 3\\mathbf{e}_{013} - 2\\mathbf{e}_{021}\\) (the point at \\((0, 3, -2)\\) ) is the plane \\(\\mathbf{e}_0 + 3\\mathbf{e}_2 - 2\\mathbf{e}_3\\) . Summary Members Descriptions public KLN_INLINE point KLN_VEC_CALL operator! (plane in) noexcept public KLN_INLINE plane KLN_VEC_CALL operator! (point in) noexcept public KLN_INLINE line KLN_VEC_CALL operator! (line in) noexcept public KLN_INLINE branch KLN_VEC_CALL operator! (ideal_line in) noexcept public KLN_INLINE ideal_line KLN_VEC_CALL operator! (branch in) noexcept public KLN_INLINE dual KLN_VEC_CALL operator! (dual in) noexcept Members KLN_INLINE point KLN_VEC_CALL operator! (plane in) noexcept KLN_INLINE plane KLN_VEC_CALL operator! (point in) noexcept KLN_INLINE line KLN_VEC_CALL operator! (line in) noexcept KLN_INLINE branch KLN_VEC_CALL operator! (ideal_line in) noexcept KLN_INLINE ideal_line KLN_VEC_CALL operator! (branch in) noexcept KLN_INLINE dual KLN_VEC_CALL operator! (dual in) noexcept","title":"Poincare Dual"},{"location":"api/dual/#group__dual","text":"The Poincar\u00e9 Dual of an element is the \"subspace complement\" of the argument with respect to the pseudoscalar in the exterior algebra. In practice, it is a relabeling of the coordinates to their dual-coordinates and is used most often to implement a \"join\" operation in terms of the exterior product of the duals of each operand. Ex: The dual of the point \\(\\mathbf{e}_{123} + 3\\mathbf{e}_{013} - 2\\mathbf{e}_{021}\\) (the point at \\((0, 3, -2)\\) ) is the plane \\(\\mathbf{e}_0 + 3\\mathbf{e}_2 - 2\\mathbf{e}_3\\) .","title":"group dual"},{"location":"api/dual/#summary","text":"Members Descriptions public KLN_INLINE point KLN_VEC_CALL operator! (plane in) noexcept public KLN_INLINE plane KLN_VEC_CALL operator! (point in) noexcept public KLN_INLINE line KLN_VEC_CALL operator! (line in) noexcept public KLN_INLINE branch KLN_VEC_CALL operator! (ideal_line in) noexcept public KLN_INLINE ideal_line KLN_VEC_CALL operator! (branch in) noexcept public KLN_INLINE dual KLN_VEC_CALL operator! (dual in) noexcept","title":"Summary"},{"location":"api/dual/#members","text":"","title":"Members"},{"location":"api/dual/#group__dual_1ga3a687310cf04e42ff485b03d557ed5a0","text":"","title":"KLN_INLINE point KLN_VEC_CALL  operator!(plane in) noexcept"},{"location":"api/dual/#group__dual_1ga105ff06095b7eb1fc4ab4b345d7aefb1","text":"","title":"KLN_INLINE plane KLN_VEC_CALL  operator!(point in) noexcept"},{"location":"api/dual/#group__dual_1gaa54dbe6355262d69f4302296708cc3fd","text":"","title":"KLN_INLINE line KLN_VEC_CALL  operator!(line in) noexcept"},{"location":"api/dual/#group__dual_1gac57689e4bf002977c93dbb5e162f7a73","text":"","title":"KLN_INLINE branch KLN_VEC_CALL  operator!(ideal_line in) noexcept"},{"location":"api/dual/#group__dual_1gaba4e70ba96775d4bda3676593256a6be","text":"","title":"KLN_INLINE ideal_line KLN_VEC_CALL  operator!(branch in) noexcept"},{"location":"api/dual/#group__dual_1ga322859aabdd00a64e316ef1d4923a266","text":"","title":"KLN_INLINE dual KLN_VEC_CALL  operator!(dual in) noexcept"},{"location":"api/dualn/","text":"group dualn A dual number is a multivector of the form \\(p + q\\mathbf{e}_{0123}\\) . Summary Members Descriptions public dual KLN_VEC_CALL operator+ (dual a,dual b) noexcept public dual KLN_VEC_CALL operator- (dual a,dual b) noexcept public dual KLN_VEC_CALL operator* (dual a,float s) noexcept public dual KLN_VEC_CALL operator* (float s,dual a) noexcept public dual KLN_VEC_CALL operator/ (dual a,float s) noexcept Members dual KLN_VEC_CALL operator+ (dual a,dual b) noexcept dual KLN_VEC_CALL operator- (dual a,dual b) noexcept dual KLN_VEC_CALL operator* (dual a,float s) noexcept dual KLN_VEC_CALL operator* (float s,dual a) noexcept dual KLN_VEC_CALL operator/ (dual a,float s) noexcept","title":"Dual Numbers"},{"location":"api/dualn/#group__dualn","text":"A dual number is a multivector of the form \\(p + q\\mathbf{e}_{0123}\\) .","title":"group dualn"},{"location":"api/dualn/#summary","text":"Members Descriptions public dual KLN_VEC_CALL operator+ (dual a,dual b) noexcept public dual KLN_VEC_CALL operator- (dual a,dual b) noexcept public dual KLN_VEC_CALL operator* (dual a,float s) noexcept public dual KLN_VEC_CALL operator* (float s,dual a) noexcept public dual KLN_VEC_CALL operator/ (dual a,float s) noexcept","title":"Summary"},{"location":"api/dualn/#members","text":"","title":"Members"},{"location":"api/dualn/#group__dualn_1gad54e557339dd7c8929fb70177ce99431","text":"","title":"dual KLN_VEC_CALL  operator+(dual a,dual b) noexcept"},{"location":"api/dualn/#group__dualn_1gac3c6b82d268dbc0ce92a43479952f30a","text":"","title":"dual KLN_VEC_CALL  operator-(dual a,dual b) noexcept"},{"location":"api/dualn/#group__dualn_1gaaad721d43b803f0bf57bc8d1454dd824","text":"","title":"dual KLN_VEC_CALL  operator*(dual a,float s) noexcept"},{"location":"api/dualn/#group__dualn_1ga061a15005779a7687ab40e54a3257fca","text":"","title":"dual KLN_VEC_CALL  operator*(float s,dual a) noexcept"},{"location":"api/dualn/#group__dualn_1ga2c6bedacc94979d14173bd340aefd6d5","text":"","title":"dual KLN_VEC_CALL  operator/(dual a,float s) noexcept"},{"location":"api/exp_log/","text":"group exp_log The group of rotations, translations, and screws (combined rotatation and translation) is nonlinear . This means, given say, a rotor \\(\\mathbf{r}\\) , the rotor \\(\\frac{\\mathbf{r}}{2}\\) does not correspond to half the rotation. Similarly, for a motor \\(\\mathbf{m}\\) , the motor \\(n \\mathbf{m}\\) is not \\(n\\) applications of the motor \\(\\mathbf{m}\\) . One way we could achieve this is through exponentiation; for example, the motor \\(\\mathbf{m}^3\\) will perform the screw action of \\(\\mathbf{m}\\) three times. However, repeated multiplication in this fashion lacks both efficiency and numerical stability. The solution is to take the logarithm of the action which maps the action to a linear space. Using log(A) where A is one of rotor , translator , or motor , we can apply linear scaling to log(A) , and then re-exponentiate the result. Using this technique, exp(n * log(A)) is equivalent to \\(\\mathbf{A}^n\\) . Summary Members Descriptions public line KLN_VEC_CALL log (motor m) noexcept Takes the principal branch of the logarithm of the motor, returning a bivector. Exponentiation of that bivector without any changes produces this motor again. Scaling that bivector by \\(\\frac{1}{n}\\) , re-exponentiating, and taking the result to the \\(n\\) th power will also produce this motor again. The logarithm presumes that the motor is normalized. public motor KLN_VEC_CALL exp (line l) noexcept Exponentiate a line to produce a motor that posesses this line as its axis. This routine will be used most often when this line is produced as the logarithm of an existing rotor, then scaled to subdivide or accelerate the motor's action. The line need not be a simple bivector for the operation to be well-defined. public ideal_line log (translator t) noexcept Compute the logarithm of the translator, producing an ideal line axis. In practice, the logarithm of a translator is simply the ideal partition (without the scalar \\(1\\) ). public translator KLN_VEC_CALL exp (ideal_line il) noexcept Exponentiate an ideal line to produce a translation. public branch log (rotor r) noexcept Returns the principal branch of this rotor's logarithm. Invoking exp on the returned [kln::branch](../../api/undefined#classkln_1_1branch) maps back to this rotor. public rotor exp (branch b) noexcept Exponentiate a branch to produce a rotor. public rotor sqrt (rotor r) noexcept Compute the square root of the provided rotor \\(r\\) . public rotor sqrt (branch b) noexcept public translator sqrt (translator t) noexcept Compute the square root of the provided translator \\(t\\) . public motor sqrt (motor m) noexcept Compute the square root of the provided motor \\(m\\) . Members line KLN_VEC_CALL log (motor m) noexcept Takes the principal branch of the logarithm of the motor, returning a bivector. Exponentiation of that bivector without any changes produces this motor again. Scaling that bivector by \\(\\frac{1}{n}\\) , re-exponentiating, and taking the result to the \\(n\\) th power will also produce this motor again. The logarithm presumes that the motor is normalized. motor KLN_VEC_CALL exp (line l) noexcept Exponentiate a line to produce a motor that posesses this line as its axis. This routine will be used most often when this line is produced as the logarithm of an existing rotor, then scaled to subdivide or accelerate the motor's action. The line need not be a simple bivector for the operation to be well-defined. ideal_line log (translator t) noexcept Compute the logarithm of the translator, producing an ideal line axis. In practice, the logarithm of a translator is simply the ideal partition (without the scalar \\(1\\) ). translator KLN_VEC_CALL exp (ideal_line il) noexcept Exponentiate an ideal line to produce a translation. The exponential of an ideal line \\(a \\mathbf{e}_{01} + b\\mathbf{e}_{02} + c\\mathbf{e}_{03}\\) is given as: \\[\\exp{\\left[a\\ee_{01} + b\\ee_{02} + c\\ee_{03}\\right]} = 1 +\\ a\\ee_{01} + b\\ee_{02} + c\\ee_{03}\\] branch log (rotor r) noexcept Returns the principal branch of this rotor's logarithm. Invoking exp on the returned [kln::branch](../../api/undefined#classkln_1_1branch) maps back to this rotor. Given a rotor \\(\\cos\\alpha + \\sin\\alpha\\left[a\\ee_{23} + b\\ee_{31} +\\ c\\ee_{23}\\right]\\) , the log is computed as simply \\(\\alpha\\left[a\\ee_{23} + b\\ee_{31} + c\\ee_{23}\\right]\\) . This map is only well-defined if the rotor is normalized such that \\(a^2 + b^2 + c^2 = 1\\) . rotor exp (branch b) noexcept Exponentiate a branch to produce a rotor. rotor sqrt (rotor r) noexcept Compute the square root of the provided rotor \\(r\\) . rotor sqrt (branch b) noexcept translator sqrt (translator t) noexcept Compute the square root of the provided translator \\(t\\) . motor sqrt (motor m) noexcept Compute the square root of the provided motor \\(m\\) .","title":"Exponential/Logarithm"},{"location":"api/exp_log/#group__exp__log","text":"The group of rotations, translations, and screws (combined rotatation and translation) is nonlinear . This means, given say, a rotor \\(\\mathbf{r}\\) , the rotor \\(\\frac{\\mathbf{r}}{2}\\) does not correspond to half the rotation. Similarly, for a motor \\(\\mathbf{m}\\) , the motor \\(n \\mathbf{m}\\) is not \\(n\\) applications of the motor \\(\\mathbf{m}\\) . One way we could achieve this is through exponentiation; for example, the motor \\(\\mathbf{m}^3\\) will perform the screw action of \\(\\mathbf{m}\\) three times. However, repeated multiplication in this fashion lacks both efficiency and numerical stability. The solution is to take the logarithm of the action which maps the action to a linear space. Using log(A) where A is one of rotor , translator , or motor , we can apply linear scaling to log(A) , and then re-exponentiate the result. Using this technique, exp(n * log(A)) is equivalent to \\(\\mathbf{A}^n\\) .","title":"group exp_log"},{"location":"api/exp_log/#summary","text":"Members Descriptions public line KLN_VEC_CALL log (motor m) noexcept Takes the principal branch of the logarithm of the motor, returning a bivector. Exponentiation of that bivector without any changes produces this motor again. Scaling that bivector by \\(\\frac{1}{n}\\) , re-exponentiating, and taking the result to the \\(n\\) th power will also produce this motor again. The logarithm presumes that the motor is normalized. public motor KLN_VEC_CALL exp (line l) noexcept Exponentiate a line to produce a motor that posesses this line as its axis. This routine will be used most often when this line is produced as the logarithm of an existing rotor, then scaled to subdivide or accelerate the motor's action. The line need not be a simple bivector for the operation to be well-defined. public ideal_line log (translator t) noexcept Compute the logarithm of the translator, producing an ideal line axis. In practice, the logarithm of a translator is simply the ideal partition (without the scalar \\(1\\) ). public translator KLN_VEC_CALL exp (ideal_line il) noexcept Exponentiate an ideal line to produce a translation. public branch log (rotor r) noexcept Returns the principal branch of this rotor's logarithm. Invoking exp on the returned [kln::branch](../../api/undefined#classkln_1_1branch) maps back to this rotor. public rotor exp (branch b) noexcept Exponentiate a branch to produce a rotor. public rotor sqrt (rotor r) noexcept Compute the square root of the provided rotor \\(r\\) . public rotor sqrt (branch b) noexcept public translator sqrt (translator t) noexcept Compute the square root of the provided translator \\(t\\) . public motor sqrt (motor m) noexcept Compute the square root of the provided motor \\(m\\) .","title":"Summary"},{"location":"api/exp_log/#members","text":"","title":"Members"},{"location":"api/exp_log/#group__exp__log_1ga3c130313451a2328e43f456d85dd4fb6","text":"Takes the principal branch of the logarithm of the motor, returning a bivector. Exponentiation of that bivector without any changes produces this motor again. Scaling that bivector by \\(\\frac{1}{n}\\) , re-exponentiating, and taking the result to the \\(n\\) th power will also produce this motor again. The logarithm presumes that the motor is normalized.","title":"line KLN_VEC_CALL  log(motor m) noexcept"},{"location":"api/exp_log/#group__exp__log_1gafd039e0f0dd3daa0bcda9bf813509440","text":"Exponentiate a line to produce a motor that posesses this line as its axis. This routine will be used most often when this line is produced as the logarithm of an existing rotor, then scaled to subdivide or accelerate the motor's action. The line need not be a simple bivector for the operation to be well-defined.","title":"motor KLN_VEC_CALL  exp(line l) noexcept"},{"location":"api/exp_log/#group__exp__log_1ga869455da862cba894c72ede161751cf5","text":"Compute the logarithm of the translator, producing an ideal line axis. In practice, the logarithm of a translator is simply the ideal partition (without the scalar \\(1\\) ).","title":"ideal_line  log(translator t) noexcept"},{"location":"api/exp_log/#group__exp__log_1gad82c9474f26ec967f2d28014f86df6da","text":"Exponentiate an ideal line to produce a translation. The exponential of an ideal line \\(a \\mathbf{e}_{01} + b\\mathbf{e}_{02} + c\\mathbf{e}_{03}\\) is given as: \\[\\exp{\\left[a\\ee_{01} + b\\ee_{02} + c\\ee_{03}\\right]} = 1 +\\ a\\ee_{01} + b\\ee_{02} + c\\ee_{03}\\]","title":"translator KLN_VEC_CALL  exp(ideal_line il) noexcept"},{"location":"api/exp_log/#group__exp__log_1gae6a2c74caa439a32c5f1dd0b44b0d7f3","text":"Returns the principal branch of this rotor's logarithm. Invoking exp on the returned [kln::branch](../../api/undefined#classkln_1_1branch) maps back to this rotor. Given a rotor \\(\\cos\\alpha + \\sin\\alpha\\left[a\\ee_{23} + b\\ee_{31} +\\ c\\ee_{23}\\right]\\) , the log is computed as simply \\(\\alpha\\left[a\\ee_{23} + b\\ee_{31} + c\\ee_{23}\\right]\\) . This map is only well-defined if the rotor is normalized such that \\(a^2 + b^2 + c^2 = 1\\) .","title":"branch  log(rotor r) noexcept"},{"location":"api/exp_log/#group__exp__log_1ga1aa5a83379532820974c7e86d4bb5a23","text":"Exponentiate a branch to produce a rotor.","title":"rotor  exp(branch b) noexcept"},{"location":"api/exp_log/#group__exp__log_1gaaa8057683b4825442c5e23d21cf2e8aa","text":"Compute the square root of the provided rotor \\(r\\) .","title":"rotor  sqrt(rotor r) noexcept"},{"location":"api/exp_log/#group__exp__log_1ga3ae618380084d8ef2a58d26fd3672a67","text":"","title":"rotor  sqrt(branch b) noexcept"},{"location":"api/exp_log/#group__exp__log_1ga02407dbecf029cc22be7cd8d1fed5c86","text":"Compute the square root of the provided translator \\(t\\) .","title":"translator  sqrt(translator t) noexcept"},{"location":"api/exp_log/#group__exp__log_1ga5b01d5fc4cbc7294069626c9962f8f39","text":"Compute the square root of the provided motor \\(m\\) .","title":"motor  sqrt(motor m) noexcept"},{"location":"api/ext/","text":"group ext ( meet.hpp ) The exterior product between two basis elements extinguishes if the two operands share any common index. Otherwise, the element produced is equivalent to the union of the subspaces. A sign flip is introduced if the concatenation of the element indices is an odd permutation of the cyclic basis representation. The exterior product extends to general multivectors by linearity. Meeting two planes kln :: plane p1 { x1 , y1 , z1 , d1 }; kln :: plane p2 { x2 , y2 , z2 , d2 }; // l lies at the intersection of p1 and p2. kln :: line l = p1 ^ p2 ; Meeting a line and a plane kln :: plane p1 { x , y , z , d }; kln :: line l2 { mx , my , mz , dx , dy , dz }; // p2 lies at the intersection of p1 and l2. kln :: point p2 = p1 ^ l2 ; Summary Members Descriptions public line KLN_VEC_CALL operator^ (plane a,plane b) noexcept public point KLN_VEC_CALL operator^ (plane a,branch b) noexcept public point KLN_VEC_CALL operator^ (branch b,plane a) noexcept public point KLN_VEC_CALL operator^ (plane a,ideal_line b) noexcept public point KLN_VEC_CALL operator^ (ideal_line b,plane a) noexcept public point KLN_VEC_CALL operator^ (plane a,line b) noexcept public point KLN_VEC_CALL operator^ (line b,plane a) noexcept public dual KLN_VEC_CALL operator^ (plane a,point b) noexcept public dual KLN_VEC_CALL operator^ (point b,plane a) noexcept public dual KLN_VEC_CALL operator^ (branch a,ideal_line b) noexcept public dual KLN_VEC_CALL operator^ (ideal_line b,branch a) noexcept public dual KLN_VEC_CALL operator^ (line a,line b) noexcept public dual KLN_VEC_CALL operator^ (line a,ideal_line b) noexcept public dual KLN_VEC_CALL operator^ (ideal_line b,line a) noexcept public dual KLN_VEC_CALL operator^ (line a,branch b) noexcept public dual KLN_VEC_CALL operator^ (branch b,line a) noexcept Members line KLN_VEC_CALL operator^ (plane a,plane b) noexcept point KLN_VEC_CALL operator^ (plane a,branch b) noexcept point KLN_VEC_CALL operator^ (branch b,plane a) noexcept point KLN_VEC_CALL operator^ (plane a,ideal_line b) noexcept point KLN_VEC_CALL operator^ (ideal_line b,plane a) noexcept point KLN_VEC_CALL operator^ (plane a,line b) noexcept point KLN_VEC_CALL operator^ (line b,plane a) noexcept dual KLN_VEC_CALL operator^ (plane a,point b) noexcept dual KLN_VEC_CALL operator^ (point b,plane a) noexcept dual KLN_VEC_CALL operator^ (branch a,ideal_line b) noexcept dual KLN_VEC_CALL operator^ (ideal_line b,branch a) noexcept dual KLN_VEC_CALL operator^ (line a,line b) noexcept dual KLN_VEC_CALL operator^ (line a,ideal_line b) noexcept dual KLN_VEC_CALL operator^ (ideal_line b,line a) noexcept dual KLN_VEC_CALL operator^ (line a,branch b) noexcept dual KLN_VEC_CALL operator^ (branch b,line a) noexcept","title":"Exterior Product"},{"location":"api/ext/#group__ext","text":"( meet.hpp ) The exterior product between two basis elements extinguishes if the two operands share any common index. Otherwise, the element produced is equivalent to the union of the subspaces. A sign flip is introduced if the concatenation of the element indices is an odd permutation of the cyclic basis representation. The exterior product extends to general multivectors by linearity. Meeting two planes kln :: plane p1 { x1 , y1 , z1 , d1 }; kln :: plane p2 { x2 , y2 , z2 , d2 }; // l lies at the intersection of p1 and p2. kln :: line l = p1 ^ p2 ; Meeting a line and a plane kln :: plane p1 { x , y , z , d }; kln :: line l2 { mx , my , mz , dx , dy , dz }; // p2 lies at the intersection of p1 and l2. kln :: point p2 = p1 ^ l2 ;","title":"group ext"},{"location":"api/ext/#summary","text":"Members Descriptions public line KLN_VEC_CALL operator^ (plane a,plane b) noexcept public point KLN_VEC_CALL operator^ (plane a,branch b) noexcept public point KLN_VEC_CALL operator^ (branch b,plane a) noexcept public point KLN_VEC_CALL operator^ (plane a,ideal_line b) noexcept public point KLN_VEC_CALL operator^ (ideal_line b,plane a) noexcept public point KLN_VEC_CALL operator^ (plane a,line b) noexcept public point KLN_VEC_CALL operator^ (line b,plane a) noexcept public dual KLN_VEC_CALL operator^ (plane a,point b) noexcept public dual KLN_VEC_CALL operator^ (point b,plane a) noexcept public dual KLN_VEC_CALL operator^ (branch a,ideal_line b) noexcept public dual KLN_VEC_CALL operator^ (ideal_line b,branch a) noexcept public dual KLN_VEC_CALL operator^ (line a,line b) noexcept public dual KLN_VEC_CALL operator^ (line a,ideal_line b) noexcept public dual KLN_VEC_CALL operator^ (ideal_line b,line a) noexcept public dual KLN_VEC_CALL operator^ (line a,branch b) noexcept public dual KLN_VEC_CALL operator^ (branch b,line a) noexcept","title":"Summary"},{"location":"api/ext/#members","text":"","title":"Members"},{"location":"api/ext/#group__ext_1gaf6b69634e1bd50ac311c3c3809e0d3f0","text":"","title":"line KLN_VEC_CALL  operator^(plane a,plane b) noexcept"},{"location":"api/ext/#group__ext_1gaddd37930213efde0f90e8abb0f60c2bc","text":"","title":"point KLN_VEC_CALL  operator^(plane a,branch b) noexcept"},{"location":"api/ext/#group__ext_1ga17077e02ba6e4391e6fdf056ae06da76","text":"","title":"point KLN_VEC_CALL  operator^(branch b,plane a) noexcept"},{"location":"api/ext/#group__ext_1ga7c2f4e2deca4fc77fe75ff0fc608ed23","text":"","title":"point KLN_VEC_CALL  operator^(plane a,ideal_line b) noexcept"},{"location":"api/ext/#group__ext_1ga0aa1144df65f9d813a10f258d06277ae","text":"","title":"point KLN_VEC_CALL  operator^(ideal_line b,plane a) noexcept"},{"location":"api/ext/#group__ext_1gaa1676d98117be736ee2bba5f56e309b3","text":"","title":"point KLN_VEC_CALL  operator^(plane a,line b) noexcept"},{"location":"api/ext/#group__ext_1gaf6b24c4d8ecfa0b241e6549f6ce55531","text":"","title":"point KLN_VEC_CALL  operator^(line b,plane a) noexcept"},{"location":"api/ext/#group__ext_1ga4586341ae4d37e91856b56a6890ce5f8","text":"","title":"dual KLN_VEC_CALL  operator^(plane a,point b) noexcept"},{"location":"api/ext/#group__ext_1ga0ca0c0ab8d43f634ca56afd825f9d44e","text":"","title":"dual KLN_VEC_CALL  operator^(point b,plane a) noexcept"},{"location":"api/ext/#group__ext_1gad6a59a5e1fce6d154880a2f703d57904","text":"","title":"dual KLN_VEC_CALL  operator^(branch a,ideal_line b) noexcept"},{"location":"api/ext/#group__ext_1gab85e4f6b524bf5ced8e69bed740a5c36","text":"","title":"dual KLN_VEC_CALL  operator^(ideal_line b,branch a) noexcept"},{"location":"api/ext/#group__ext_1ga2e4a907b6183e39f7d1654b2d2a5fbf7","text":"","title":"dual KLN_VEC_CALL  operator^(line a,line b) noexcept"},{"location":"api/ext/#group__ext_1ga870be4918722a28ad026286942172a07","text":"","title":"dual KLN_VEC_CALL  operator^(line a,ideal_line b) noexcept"},{"location":"api/ext/#group__ext_1ga4d9bce873ef833b7845ac0fdc5eb8b0f","text":"","title":"dual KLN_VEC_CALL  operator^(ideal_line b,line a) noexcept"},{"location":"api/ext/#group__ext_1gad6dec9eb7586335e38b38485ea08cf9c","text":"","title":"dual KLN_VEC_CALL  operator^(line a,branch b) noexcept"},{"location":"api/ext/#group__ext_1gaf52ece148d4d7adfb0645b7c96b75cfa","text":"","title":"dual KLN_VEC_CALL  operator^(branch b,line a) noexcept"},{"location":"api/gp/","text":"group gp The geometric product extends the exterior product with a notion of a metric. When the subspace intersection of the operands of two basis elements is non-zero, instead of the product extinguishing, the grade collapses and a scalar weight is included in the final result according to the metric. The geometric product can be used to build rotations, and by extension, rotations and translations in projective space. Rotor composition kln :: rotor r1 { ang1 , x1 , y1 , z1 }; kln :: rotor r2 { ang2 , x2 , y2 , z2 }; // Compose rotors with the geometric product kln :: rotor r3 = r1 * r2 ;; // r3 combines r2 and r1 in that order Two reflections kln :: plane p1 { x1 , y1 , z1 , d1 }; kln :: plane p2 { x2 , y2 , z2 , d2 }; // The geometric product of two planes combines their reflections kln :: motor m3 = p1 * p2 ; // m3 combines p2 and p1 in that order // If p1 and p2 were parallel, m3 would be a translation. Otherwise, // m3 would be a rotation. Another common usage of the geometric product is to create a transformation that takes one entity to another. Suppose we have two entities \\(a\\) and \\(b\\) and suppose that both entities are normalized such that \\(a^2 = b^2 = 1\\) . Then, the action created by \\(\\sqrt{ab}\\) is the action that maps \\(b\\) to \\(a\\) . Motor between two lines kln :: line l1 { mx1 , my1 , mz1 , dx1 , dy1 , dz1 }; kln :: line l2 { mx2 , my2 , mz2 , dx2 , dy2 , dz2 }; // Ensure lines are normalized if they aren't already l1 . normalize (); l2 . normalize (); kln :: motor m = kln :: sqrt ( l1 * l2 ); kln :: line l3 = m ( l2 ); // l3 will be projectively equivalent to l1. Also provided are division operators that multiply the first argument by the inverse of the second argument. Summary Members Descriptions public motor KLN_VEC_CALL operator* (plane a,plane b) noexcept Construct a motor \\(m\\) such that \\(\\sqrt{m}\\) takes plane \\(b\\) to plane \\(a\\) . public motor KLN_VEC_CALL operator* (plane a,point b) noexcept public motor KLN_VEC_CALL operator* (point b,plane a) noexcept public rotor KLN_VEC_CALL operator* (branch a,branch b) noexcept Generate a rotor \\(r\\) such that \\(\\widetilde{\\sqrt{r}}\\) takes branch \\(b\\) to branch \\(a\\) . public motor KLN_VEC_CALL operator* (line a,line b) noexcept Generates a motor \\(m\\) that produces a screw motion about the common normal to lines \\(a\\) and \\(b\\) . The motor given by \\(\\sqrt{m}\\) takes \\(b\\) to \\(a\\) provided that \\(a\\) and \\(b\\) are both normalized. public translator KLN_VEC_CALL operator* (point a,point b) noexcept Generates a translator \\(t\\) that produces a displacement along the line between points \\(a\\) and \\(b\\) . The translator given by \\(\\sqrt{t}\\) takes \\(b\\) to \\(a\\) . public rotor KLN_VEC_CALL operator* (rotor a,rotor b) noexcept Composes two rotational actions such that the produced rotor has the same effect as applying rotor \\(b\\) , then rotor \\(a\\) . public line KLN_VEC_CALL operator* (dual a,line b) noexcept The product of a dual number and a line effectively weights the line with a rotational and translational quantity. Subsequent exponentiation will produce a motor along the screw axis of line \\(b\\) with rotation and translation given by half the scalar and pseudoscalar parts of the dual number \\(a\\) respectively. public line KLN_VEC_CALL operator* (line b,dual a) noexcept public motor KLN_VEC_CALL operator* (rotor a,translator b) noexcept Compose the action of a translator and rotor ( b will be applied, then a ) public motor KLN_VEC_CALL operator* (translator b,rotor a) noexcept Compose the action of a rotor and translator ( a will be applied, then b ) public translator KLN_VEC_CALL operator* (translator a,translator b) noexcept Compose the action of two translators (this operation is commutative for these operands). public motor KLN_VEC_CALL operator* (rotor a,motor b) noexcept Compose the action of a rotor and motor ( b will be applied, then a ) public motor KLN_VEC_CALL operator* (motor b,rotor a) noexcept Compose the action of a rotor and motor ( a will be applied, then b ) public motor KLN_VEC_CALL operator* (translator a,motor b) noexcept Compose the action of a translator and motor ( b will be applied, then a ) public motor KLN_VEC_CALL operator* (motor b,translator a) noexcept Compose the action of a translator and motor ( a will be applied, then b ) public motor KLN_VEC_CALL operator* (motor a,motor b) noexcept Compose the action of two motors ( b will be applied, then a ) public motor KLN_VEC_CALL operator/ (plane a,plane b) noexcept public translator KLN_VEC_CALL operator/ (point a,point b) noexcept public rotor KLN_VEC_CALL operator/ (branch a,branch b) noexcept public rotor KLN_VEC_CALL operator/ (rotor a,rotor b) noexcept public translator KLN_VEC_CALL operator/ (translator a,translator b) noexcept public motor KLN_VEC_CALL operator/ (line a,line b) noexcept public motor KLN_VEC_CALL operator/ (motor a,rotor b) noexcept public motor KLN_VEC_CALL operator/ (motor a,translator b) noexcept public motor KLN_VEC_CALL operator/ (motor a,motor b) noexcept Members motor KLN_VEC_CALL operator* (plane a,plane b) noexcept Construct a motor \\(m\\) such that \\(\\sqrt{m}\\) takes plane \\(b\\) to plane \\(a\\) . Example kln :: plane p1 { x1 , y1 , z1 , d1 }; kln :: plane p2 { x2 , y2 , z2 , d2 }; kln :: motor m = sqrt ( p1 * p2 ); plane p3 = m ( p2 ); // p3 will be approximately equal to p1 motor KLN_VEC_CALL operator* (plane a,point b) noexcept motor KLN_VEC_CALL operator* (point b,plane a) noexcept rotor KLN_VEC_CALL operator* (branch a,branch b) noexcept Generate a rotor \\(r\\) such that \\(\\widetilde{\\sqrt{r}}\\) takes branch \\(b\\) to branch \\(a\\) . motor KLN_VEC_CALL operator* (line a,line b) noexcept Generates a motor \\(m\\) that produces a screw motion about the common normal to lines \\(a\\) and \\(b\\) . The motor given by \\(\\sqrt{m}\\) takes \\(b\\) to \\(a\\) provided that \\(a\\) and \\(b\\) are both normalized. translator KLN_VEC_CALL operator* (point a,point b) noexcept Generates a translator \\(t\\) that produces a displacement along the line between points \\(a\\) and \\(b\\) . The translator given by \\(\\sqrt{t}\\) takes \\(b\\) to \\(a\\) . rotor KLN_VEC_CALL operator* (rotor a,rotor b) noexcept Composes two rotational actions such that the produced rotor has the same effect as applying rotor \\(b\\) , then rotor \\(a\\) . line KLN_VEC_CALL operator* (dual a,line b) noexcept The product of a dual number and a line effectively weights the line with a rotational and translational quantity. Subsequent exponentiation will produce a motor along the screw axis of line \\(b\\) with rotation and translation given by half the scalar and pseudoscalar parts of the dual number \\(a\\) respectively. line KLN_VEC_CALL operator* (line b,dual a) noexcept motor KLN_VEC_CALL operator* (rotor a,translator b) noexcept Compose the action of a translator and rotor ( b will be applied, then a ) motor KLN_VEC_CALL operator* (translator b,rotor a) noexcept Compose the action of a rotor and translator ( a will be applied, then b ) translator KLN_VEC_CALL operator* (translator a,translator b) noexcept Compose the action of two translators (this operation is commutative for these operands). motor KLN_VEC_CALL operator* (rotor a,motor b) noexcept Compose the action of a rotor and motor ( b will be applied, then a ) motor KLN_VEC_CALL operator* (motor b,rotor a) noexcept Compose the action of a rotor and motor ( a will be applied, then b ) motor KLN_VEC_CALL operator* (translator a,motor b) noexcept Compose the action of a translator and motor ( b will be applied, then a ) motor KLN_VEC_CALL operator* (motor b,translator a) noexcept Compose the action of a translator and motor ( a will be applied, then b ) motor KLN_VEC_CALL operator* (motor a,motor b) noexcept Compose the action of two motors ( b will be applied, then a ) motor KLN_VEC_CALL operator/ (plane a,plane b) noexcept translator KLN_VEC_CALL operator/ (point a,point b) noexcept rotor KLN_VEC_CALL operator/ (branch a,branch b) noexcept rotor KLN_VEC_CALL operator/ (rotor a,rotor b) noexcept translator KLN_VEC_CALL operator/ (translator a,translator b) noexcept motor KLN_VEC_CALL operator/ (line a,line b) noexcept motor KLN_VEC_CALL operator/ (motor a,rotor b) noexcept motor KLN_VEC_CALL operator/ (motor a,translator b) noexcept motor KLN_VEC_CALL operator/ (motor a,motor b) noexcept","title":"Geometric Product"},{"location":"api/gp/#group__gp","text":"The geometric product extends the exterior product with a notion of a metric. When the subspace intersection of the operands of two basis elements is non-zero, instead of the product extinguishing, the grade collapses and a scalar weight is included in the final result according to the metric. The geometric product can be used to build rotations, and by extension, rotations and translations in projective space. Rotor composition kln :: rotor r1 { ang1 , x1 , y1 , z1 }; kln :: rotor r2 { ang2 , x2 , y2 , z2 }; // Compose rotors with the geometric product kln :: rotor r3 = r1 * r2 ;; // r3 combines r2 and r1 in that order Two reflections kln :: plane p1 { x1 , y1 , z1 , d1 }; kln :: plane p2 { x2 , y2 , z2 , d2 }; // The geometric product of two planes combines their reflections kln :: motor m3 = p1 * p2 ; // m3 combines p2 and p1 in that order // If p1 and p2 were parallel, m3 would be a translation. Otherwise, // m3 would be a rotation. Another common usage of the geometric product is to create a transformation that takes one entity to another. Suppose we have two entities \\(a\\) and \\(b\\) and suppose that both entities are normalized such that \\(a^2 = b^2 = 1\\) . Then, the action created by \\(\\sqrt{ab}\\) is the action that maps \\(b\\) to \\(a\\) . Motor between two lines kln :: line l1 { mx1 , my1 , mz1 , dx1 , dy1 , dz1 }; kln :: line l2 { mx2 , my2 , mz2 , dx2 , dy2 , dz2 }; // Ensure lines are normalized if they aren't already l1 . normalize (); l2 . normalize (); kln :: motor m = kln :: sqrt ( l1 * l2 ); kln :: line l3 = m ( l2 ); // l3 will be projectively equivalent to l1. Also provided are division operators that multiply the first argument by the inverse of the second argument.","title":"group gp"},{"location":"api/gp/#summary","text":"Members Descriptions public motor KLN_VEC_CALL operator* (plane a,plane b) noexcept Construct a motor \\(m\\) such that \\(\\sqrt{m}\\) takes plane \\(b\\) to plane \\(a\\) . public motor KLN_VEC_CALL operator* (plane a,point b) noexcept public motor KLN_VEC_CALL operator* (point b,plane a) noexcept public rotor KLN_VEC_CALL operator* (branch a,branch b) noexcept Generate a rotor \\(r\\) such that \\(\\widetilde{\\sqrt{r}}\\) takes branch \\(b\\) to branch \\(a\\) . public motor KLN_VEC_CALL operator* (line a,line b) noexcept Generates a motor \\(m\\) that produces a screw motion about the common normal to lines \\(a\\) and \\(b\\) . The motor given by \\(\\sqrt{m}\\) takes \\(b\\) to \\(a\\) provided that \\(a\\) and \\(b\\) are both normalized. public translator KLN_VEC_CALL operator* (point a,point b) noexcept Generates a translator \\(t\\) that produces a displacement along the line between points \\(a\\) and \\(b\\) . The translator given by \\(\\sqrt{t}\\) takes \\(b\\) to \\(a\\) . public rotor KLN_VEC_CALL operator* (rotor a,rotor b) noexcept Composes two rotational actions such that the produced rotor has the same effect as applying rotor \\(b\\) , then rotor \\(a\\) . public line KLN_VEC_CALL operator* (dual a,line b) noexcept The product of a dual number and a line effectively weights the line with a rotational and translational quantity. Subsequent exponentiation will produce a motor along the screw axis of line \\(b\\) with rotation and translation given by half the scalar and pseudoscalar parts of the dual number \\(a\\) respectively. public line KLN_VEC_CALL operator* (line b,dual a) noexcept public motor KLN_VEC_CALL operator* (rotor a,translator b) noexcept Compose the action of a translator and rotor ( b will be applied, then a ) public motor KLN_VEC_CALL operator* (translator b,rotor a) noexcept Compose the action of a rotor and translator ( a will be applied, then b ) public translator KLN_VEC_CALL operator* (translator a,translator b) noexcept Compose the action of two translators (this operation is commutative for these operands). public motor KLN_VEC_CALL operator* (rotor a,motor b) noexcept Compose the action of a rotor and motor ( b will be applied, then a ) public motor KLN_VEC_CALL operator* (motor b,rotor a) noexcept Compose the action of a rotor and motor ( a will be applied, then b ) public motor KLN_VEC_CALL operator* (translator a,motor b) noexcept Compose the action of a translator and motor ( b will be applied, then a ) public motor KLN_VEC_CALL operator* (motor b,translator a) noexcept Compose the action of a translator and motor ( a will be applied, then b ) public motor KLN_VEC_CALL operator* (motor a,motor b) noexcept Compose the action of two motors ( b will be applied, then a ) public motor KLN_VEC_CALL operator/ (plane a,plane b) noexcept public translator KLN_VEC_CALL operator/ (point a,point b) noexcept public rotor KLN_VEC_CALL operator/ (branch a,branch b) noexcept public rotor KLN_VEC_CALL operator/ (rotor a,rotor b) noexcept public translator KLN_VEC_CALL operator/ (translator a,translator b) noexcept public motor KLN_VEC_CALL operator/ (line a,line b) noexcept public motor KLN_VEC_CALL operator/ (motor a,rotor b) noexcept public motor KLN_VEC_CALL operator/ (motor a,translator b) noexcept public motor KLN_VEC_CALL operator/ (motor a,motor b) noexcept","title":"Summary"},{"location":"api/gp/#members","text":"","title":"Members"},{"location":"api/gp/#group__gp_1gaa3e61221bb38010db55aa0b5f8e17efc","text":"Construct a motor \\(m\\) such that \\(\\sqrt{m}\\) takes plane \\(b\\) to plane \\(a\\) . Example kln :: plane p1 { x1 , y1 , z1 , d1 }; kln :: plane p2 { x2 , y2 , z2 , d2 }; kln :: motor m = sqrt ( p1 * p2 ); plane p3 = m ( p2 ); // p3 will be approximately equal to p1","title":"motor KLN_VEC_CALL  operator*(plane a,plane b) noexcept"},{"location":"api/gp/#group__gp_1ga6ebccec1c450228f4d70a2862981a6ae","text":"","title":"motor KLN_VEC_CALL  operator*(plane a,point b) noexcept"},{"location":"api/gp/#group__gp_1ga72c655dc80b7be4642a36be1cacc39f7","text":"","title":"motor KLN_VEC_CALL  operator*(point b,plane a) noexcept"},{"location":"api/gp/#group__gp_1ga2c84f0a8b28b709e973668df084d1529","text":"Generate a rotor \\(r\\) such that \\(\\widetilde{\\sqrt{r}}\\) takes branch \\(b\\) to branch \\(a\\) .","title":"rotor KLN_VEC_CALL  operator*(branch a,branch b) noexcept"},{"location":"api/gp/#group__gp_1ga152dac80fd07d20e8205a75a651717c7","text":"Generates a motor \\(m\\) that produces a screw motion about the common normal to lines \\(a\\) and \\(b\\) . The motor given by \\(\\sqrt{m}\\) takes \\(b\\) to \\(a\\) provided that \\(a\\) and \\(b\\) are both normalized.","title":"motor KLN_VEC_CALL  operator*(line a,line b) noexcept"},{"location":"api/gp/#group__gp_1ga6d59afd80f83622351ee528209242505","text":"Generates a translator \\(t\\) that produces a displacement along the line between points \\(a\\) and \\(b\\) . The translator given by \\(\\sqrt{t}\\) takes \\(b\\) to \\(a\\) .","title":"translator KLN_VEC_CALL  operator*(point a,point b) noexcept"},{"location":"api/gp/#group__gp_1ga13acc1dbe5763c924a051093829cfa7f","text":"Composes two rotational actions such that the produced rotor has the same effect as applying rotor \\(b\\) , then rotor \\(a\\) .","title":"rotor KLN_VEC_CALL  operator*(rotor a,rotor b) noexcept"},{"location":"api/gp/#group__gp_1ga8c4d528a130478a054f82d57d4fb7301","text":"The product of a dual number and a line effectively weights the line with a rotational and translational quantity. Subsequent exponentiation will produce a motor along the screw axis of line \\(b\\) with rotation and translation given by half the scalar and pseudoscalar parts of the dual number \\(a\\) respectively.","title":"line KLN_VEC_CALL  operator*(dual a,line b) noexcept"},{"location":"api/gp/#group__gp_1ga8ce7535e36f267c43cd82e636cef84f1","text":"","title":"line KLN_VEC_CALL  operator*(line b,dual a) noexcept"},{"location":"api/gp/#group__gp_1gafdd46a387780ea583d6ab6bb68da17e7","text":"Compose the action of a translator and rotor ( b will be applied, then a )","title":"motor KLN_VEC_CALL  operator*(rotor a,translator b) noexcept"},{"location":"api/gp/#group__gp_1ga8c85df199553c9189e2238de6f8ea75f","text":"Compose the action of a rotor and translator ( a will be applied, then b )","title":"motor KLN_VEC_CALL  operator*(translator b,rotor a) noexcept"},{"location":"api/gp/#group__gp_1gae58f3fe871600c10a862f0d798ecfa9a","text":"Compose the action of two translators (this operation is commutative for these operands).","title":"translator KLN_VEC_CALL  operator*(translator a,translator b) noexcept"},{"location":"api/gp/#group__gp_1ga6b7806b8e0563902a4799e8a96023419","text":"Compose the action of a rotor and motor ( b will be applied, then a )","title":"motor KLN_VEC_CALL  operator*(rotor a,motor b) noexcept"},{"location":"api/gp/#group__gp_1ga0d66c1ed07072e669a6618c8a2cd3915","text":"Compose the action of a rotor and motor ( a will be applied, then b )","title":"motor KLN_VEC_CALL  operator*(motor b,rotor a) noexcept"},{"location":"api/gp/#group__gp_1gaf71d001695eb98b0dbde90039957feda","text":"Compose the action of a translator and motor ( b will be applied, then a )","title":"motor KLN_VEC_CALL  operator*(translator a,motor b) noexcept"},{"location":"api/gp/#group__gp_1gae243255b3c91515f8a651ad3ce531650","text":"Compose the action of a translator and motor ( a will be applied, then b )","title":"motor KLN_VEC_CALL  operator*(motor b,translator a) noexcept"},{"location":"api/gp/#group__gp_1ga88f8e53b1842ca28ec1456d887144fec","text":"Compose the action of two motors ( b will be applied, then a )","title":"motor KLN_VEC_CALL  operator*(motor a,motor b) noexcept"},{"location":"api/gp/#group__gp_1gae07ffecb7a36960edc6959958faabc66","text":"","title":"motor KLN_VEC_CALL  operator/(plane a,plane b) noexcept"},{"location":"api/gp/#group__gp_1gab85d0363fbcf716788bedca7d82dbf33","text":"","title":"translator KLN_VEC_CALL  operator/(point a,point b) noexcept"},{"location":"api/gp/#group__gp_1gae2b0b438f70ae7fdcb0bab00472074ec","text":"","title":"rotor KLN_VEC_CALL  operator/(branch a,branch b) noexcept"},{"location":"api/gp/#group__gp_1ga9ed0e3e8b451b340f465d8f910d1ab35","text":"","title":"rotor KLN_VEC_CALL  operator/(rotor a,rotor b) noexcept"},{"location":"api/gp/#group__gp_1ga3bcbe21374e5abcbdcb62586091a9540","text":"","title":"translator KLN_VEC_CALL  operator/(translator a,translator b) noexcept"},{"location":"api/gp/#group__gp_1ga391b74b2c0cab4a1fd80505ddd18763b","text":"","title":"motor KLN_VEC_CALL  operator/(line a,line b) noexcept"},{"location":"api/gp/#group__gp_1gadf3632ea9928e28c4293deff327bdb6c","text":"","title":"motor KLN_VEC_CALL  operator/(motor a,rotor b) noexcept"},{"location":"api/gp/#group__gp_1gac04a8339b0036a0949b2cdd30a7dbcfc","text":"","title":"motor KLN_VEC_CALL  operator/(motor a,translator b) noexcept"},{"location":"api/gp/#group__gp_1ga195ed6702368641d3c46f5afe1f752d3","text":"","title":"motor KLN_VEC_CALL  operator/(motor a,motor b) noexcept"},{"location":"api/lines/","text":"group lines Klein provides three line classes: \"line\", \"branch\", and \"ideal_line\". The line class represents a full six-coordinate bivector. The branch contains three non-degenerate components (aka, a line through the origin). The ideal line represents the line at infinity. When the line is created as a meet of two planes or join of two points (or carefully selected Pl\u00fccker coordinates), it will be a Euclidean line (factorizable as the meet of two vectors). Summary Members Descriptions public ideal_line () = default public ideal_line (float a,float b,float c) noexcept public ideal_line (__m128 xmm) noexcept public float squared_ideal_norm () noexcept public float ideal_norm () noexcept public ideal_line &KLN_VEC_CALL operator+= (ideal_line b) noexcept Ideal line addition. public ideal_line &KLN_VEC_CALL operator-= (ideal_line b) noexcept Ideal line subtraction. public ideal_line & operator*= (float s) noexcept Ideal line uniform scale. public ideal_line & operator*= (int s) noexcept Ideal line uniform scale. public ideal_line & operator/= (float s) noexcept Ideal line uniform inverse scale. public ideal_line & operator/= (int s) noexcept Ideal line uniform inverse scale. public float e01 () const noexcept public float e10 () const noexcept public float e02 () const noexcept public float e20 () const noexcept public float e03 () const noexcept public float e30 () const noexcept public ideal_line KLN_VEC_CALL operator+ (ideal_line a,ideal_line b) noexcept Ideal line addition. public ideal_line KLN_VEC_CALL operator- (ideal_line a,ideal_line b) noexcept Ideal line subtraction. public ideal_line KLN_VEC_CALL operator* (ideal_line l,float s) noexcept Ideal line uniform scale. public ideal_line KLN_VEC_CALL operator* (ideal_line l,int s) noexcept Ideal line uniform scale. public ideal_line KLN_VEC_CALL operator* (float s,ideal_line l) noexcept Ideal line uniform scale. public ideal_line KLN_VEC_CALL operator* (int s,ideal_line l) noexcept Ideal line uniform scale. public ideal_line KLN_VEC_CALL operator/ (ideal_line l,float s) noexcept Ideal line uniform inverse scale. public ideal_line KLN_VEC_CALL operator/ (ideal_line l,int s) noexcept public ideal_line KLN_VEC_CALL operator- (ideal_line l) noexcept Unary minus. public ideal_line KLN_VEC_CALL operator~ (ideal_line l) noexcept Reversion operator. public branch () = default public branch (float a,float b,float c) noexcept Construct the branch as the following multivector: public branch (__m128 xmm) noexcept public float squared_norm () noexcept If a line is constructed as the regressive product (join) of two points, the squared norm provided here is the squared distance between the two points (provided the points are normalized). Returns \\(d^2 + e^2 + f^2\\) . public float norm () noexcept Returns the square root of the quantity produced by squared_norm . public void normalize () noexcept public branch normalized () const noexcept public void invert () noexcept public branch inverse () const noexcept public branch &KLN_VEC_CALL operator+= (branch b) noexcept Branch addition. public branch &KLN_VEC_CALL operator-= (branch b) noexcept Branch subtraction. public branch & operator*= (float s) noexcept Branch uniform scale. public branch & operator*= (int s) noexcept Branch uniform scale. public branch & operator/= (float s) noexcept Branch uniform inverse scale. public branch & operator/= (int s) noexcept Branch uniform inverse scale. public float e12 () const noexcept public float e21 () const noexcept public float z () const noexcept public float e31 () const noexcept public float e13 () const noexcept public float y () const noexcept public float e23 () const noexcept public float e32 () const noexcept public float x () const noexcept public branch KLN_VEC_CALL operator+ (branch a,branch b) noexcept Branch addition. public branch KLN_VEC_CALL operator- (branch a,branch b) noexcept Branch subtraction. public branch KLN_VEC_CALL operator* (branch b,float s) noexcept Branch uniform scale. public branch KLN_VEC_CALL operator* (branch b,int s) noexcept Branch uniform scale. public branch KLN_VEC_CALL operator* (float s,branch b) noexcept Branch uniform scale. public branch KLN_VEC_CALL operator* (int s,branch b) noexcept Branch uniform scale. public branch KLN_VEC_CALL operator/ (branch b,float s) noexcept Branch uniform inverse scale. public branch KLN_VEC_CALL operator/ (branch b,int s) noexcept Branch uniform inverse scale. public branch KLN_VEC_CALL operator- (branch b) noexcept Unary minus. public branch KLN_VEC_CALL operator~ (branch b) noexcept Reversion operator. public line () = default public line (float a,float b,float c,float d,float e,float f) noexcept A line is specifed by 6 coordinates which correspond to the line's Pl\u00fccker coordinates . The coordinates specified in this way correspond to the following multivector: public line (__m128 xmm1,__m128 xmm2) noexcept public line (ideal_line other) noexcept public line (branch other) noexcept public float norm () noexcept Returns the square root of the quantity produced by squared_norm . public float squared_norm () noexcept If a line is constructed as the regressive product (join) of two points, the squared norm provided here is the squared distance between the two points (provided the points are normalized). Returns \\(d^2 + e^2 + f^2\\) . public void normalize () noexcept Normalize a line such that \\(\\ell^2 = -1\\) . public line normalized () const noexcept Return a normalized copy of this line. public void invert () noexcept public line inverse () const noexcept public bool KLN_VEC_CALL operator== (line other) const noexcept Bitwise comparison. public bool KLN_VEC_CALL approx_eq (line other,float epsilon) const noexcept public line &KLN_VEC_CALL operator+= (line b) noexcept Line addition. public line &KLN_VEC_CALL operator-= (line b) noexcept Line subtraction. public line & operator*= (float s) noexcept Line uniform scale. public line & operator*= (int s) noexcept Line uniform scale. public line & operator/= (float s) noexcept Line uniform inverse scale. public line & operator/= (int s) noexcept Line uniform inverse scale. public float e12 () const noexcept public float e21 () const noexcept public float e31 () const noexcept public float e13 () const noexcept public float e23 () const noexcept public float e32 () const noexcept public float e01 () const noexcept public float e10 () const noexcept public float e02 () const noexcept public float e20 () const noexcept public float e03 () const noexcept public float e30 () const noexcept public line KLN_VEC_CALL operator+ (line a,line b) noexcept Line addition. public line KLN_VEC_CALL operator- (line a,line b) noexcept Line subtraction. public line KLN_VEC_CALL operator* (line l,float s) noexcept Line uniform scale. public line KLN_VEC_CALL operator* (line l,int s) noexcept Line uniform scale. public line KLN_VEC_CALL operator* (float s,line l) noexcept Line uniform scale. public line KLN_VEC_CALL operator* (int s,line l) noexcept Line uniform scale. public line KLN_VEC_CALL operator/ (line r,float s) noexcept Line uniform inverse scale. public line KLN_VEC_CALL operator/ (line r,int s) noexcept Line uniform inverse scale. public line KLN_VEC_CALL operator- (line l) noexcept Unary minus. public line KLN_VEC_CALL operator~ (line l) noexcept Reversion operator. Members ideal_line () = default ideal_line (float a,float b,float c) noexcept ideal_line (__m128 xmm) noexcept float squared_ideal_norm () noexcept float ideal_norm () noexcept ideal_line &KLN_VEC_CALL operator+= (ideal_line b) noexcept Ideal line addition. ideal_line &KLN_VEC_CALL operator-= (ideal_line b) noexcept Ideal line subtraction. ideal_line & operator*= (float s) noexcept Ideal line uniform scale. ideal_line & operator*= (int s) noexcept Ideal line uniform scale. ideal_line & operator/= (float s) noexcept Ideal line uniform inverse scale. ideal_line & operator/= (int s) noexcept Ideal line uniform inverse scale. float e01 () const noexcept float e10 () const noexcept float e02 () const noexcept float e20 () const noexcept float e03 () const noexcept float e30 () const noexcept ideal_line KLN_VEC_CALL operator+ (ideal_line a,ideal_line b) noexcept Ideal line addition. ideal_line KLN_VEC_CALL operator- (ideal_line a,ideal_line b) noexcept Ideal line subtraction. ideal_line KLN_VEC_CALL operator* (ideal_line l,float s) noexcept Ideal line uniform scale. ideal_line KLN_VEC_CALL operator* (ideal_line l,int s) noexcept Ideal line uniform scale. ideal_line KLN_VEC_CALL operator* (float s,ideal_line l) noexcept Ideal line uniform scale. ideal_line KLN_VEC_CALL operator* (int s,ideal_line l) noexcept Ideal line uniform scale. ideal_line KLN_VEC_CALL operator/ (ideal_line l,float s) noexcept Ideal line uniform inverse scale. ideal_line KLN_VEC_CALL operator/ (ideal_line l,int s) noexcept ideal_line KLN_VEC_CALL operator- (ideal_line l) noexcept Unary minus. ideal_line KLN_VEC_CALL operator~ (ideal_line l) noexcept Reversion operator. branch () = default branch (float a,float b,float c) noexcept Construct the branch as the following multivector: \\[a \\mathbf{e}_{23} + b\\mathbf{e}_{31} + c\\mathbf{e}_{23}\\] To convince yourself this is a line through the origin, remember that such a line can be generated using the geometric product of two planes through the origin. branch (__m128 xmm) noexcept float squared_norm () noexcept If a line is constructed as the regressive product (join) of two points, the squared norm provided here is the squared distance between the two points (provided the points are normalized). Returns \\(d^2 + e^2 + f^2\\) . float norm () noexcept Returns the square root of the quantity produced by squared_norm . void normalize () noexcept branch normalized () const noexcept void invert () noexcept branch inverse () const noexcept branch &KLN_VEC_CALL operator+= (branch b) noexcept Branch addition. branch &KLN_VEC_CALL operator-= (branch b) noexcept Branch subtraction. branch & operator*= (float s) noexcept Branch uniform scale. branch & operator*= (int s) noexcept Branch uniform scale. branch & operator/= (float s) noexcept Branch uniform inverse scale. branch & operator/= (int s) noexcept Branch uniform inverse scale. float e12 () const noexcept float e21 () const noexcept float z () const noexcept float e31 () const noexcept float e13 () const noexcept float y () const noexcept float e23 () const noexcept float e32 () const noexcept float x () const noexcept branch KLN_VEC_CALL operator+ (branch a,branch b) noexcept Branch addition. branch KLN_VEC_CALL operator- (branch a,branch b) noexcept Branch subtraction. branch KLN_VEC_CALL operator* (branch b,float s) noexcept Branch uniform scale. branch KLN_VEC_CALL operator* (branch b,int s) noexcept Branch uniform scale. branch KLN_VEC_CALL operator* (float s,branch b) noexcept Branch uniform scale. branch KLN_VEC_CALL operator* (int s,branch b) noexcept Branch uniform scale. branch KLN_VEC_CALL operator/ (branch b,float s) noexcept Branch uniform inverse scale. branch KLN_VEC_CALL operator/ (branch b,int s) noexcept Branch uniform inverse scale. branch KLN_VEC_CALL operator- (branch b) noexcept Unary minus. branch KLN_VEC_CALL operator~ (branch b) noexcept Reversion operator. line () = default line (float a,float b,float c,float d,float e,float f) noexcept A line is specifed by 6 coordinates which correspond to the line's Pl\u00fccker coordinates . The coordinates specified in this way correspond to the following multivector: \\[a\\mathbf{e}_{01} + b\\mathbf{e}_{02} + c\\mathbf{e}_{03} +\\ d\\mathbf{e}_{23} + e\\mathbf{e}_{31} + f\\mathbf{e}_{12}\\] line (__m128 xmm1,__m128 xmm2) noexcept line (ideal_line other) noexcept line (branch other) noexcept float norm () noexcept Returns the square root of the quantity produced by squared_norm . float squared_norm () noexcept If a line is constructed as the regressive product (join) of two points, the squared norm provided here is the squared distance between the two points (provided the points are normalized). Returns \\(d^2 + e^2 + f^2\\) . void normalize () noexcept Normalize a line such that \\(\\ell^2 = -1\\) . line normalized () const noexcept Return a normalized copy of this line. void invert () noexcept line inverse () const noexcept bool KLN_VEC_CALL operator== (line other) const noexcept Bitwise comparison. bool KLN_VEC_CALL approx_eq (line other,float epsilon) const noexcept line &KLN_VEC_CALL operator+= (line b) noexcept Line addition. line &KLN_VEC_CALL operator-= (line b) noexcept Line subtraction. line & operator*= (float s) noexcept Line uniform scale. line & operator*= (int s) noexcept Line uniform scale. line & operator/= (float s) noexcept Line uniform inverse scale. line & operator/= (int s) noexcept Line uniform inverse scale. float e12 () const noexcept float e21 () const noexcept float e31 () const noexcept float e13 () const noexcept float e23 () const noexcept float e32 () const noexcept float e01 () const noexcept float e10 () const noexcept float e02 () const noexcept float e20 () const noexcept float e03 () const noexcept float e30 () const noexcept line KLN_VEC_CALL operator+ (line a,line b) noexcept Line addition. line KLN_VEC_CALL operator- (line a,line b) noexcept Line subtraction. line KLN_VEC_CALL operator* (line l,float s) noexcept Line uniform scale. line KLN_VEC_CALL operator* (line l,int s) noexcept Line uniform scale. line KLN_VEC_CALL operator* (float s,line l) noexcept Line uniform scale. line KLN_VEC_CALL operator* (int s,line l) noexcept Line uniform scale. line KLN_VEC_CALL operator/ (line r,float s) noexcept Line uniform inverse scale. line KLN_VEC_CALL operator/ (line r,int s) noexcept Line uniform inverse scale. line KLN_VEC_CALL operator- (line l) noexcept Unary minus. line KLN_VEC_CALL operator~ (line l) noexcept Reversion operator.","title":"Lines"},{"location":"api/lines/#group__lines","text":"Klein provides three line classes: \"line\", \"branch\", and \"ideal_line\". The line class represents a full six-coordinate bivector. The branch contains three non-degenerate components (aka, a line through the origin). The ideal line represents the line at infinity. When the line is created as a meet of two planes or join of two points (or carefully selected Pl\u00fccker coordinates), it will be a Euclidean line (factorizable as the meet of two vectors).","title":"group lines"},{"location":"api/lines/#summary","text":"Members Descriptions public ideal_line () = default public ideal_line (float a,float b,float c) noexcept public ideal_line (__m128 xmm) noexcept public float squared_ideal_norm () noexcept public float ideal_norm () noexcept public ideal_line &KLN_VEC_CALL operator+= (ideal_line b) noexcept Ideal line addition. public ideal_line &KLN_VEC_CALL operator-= (ideal_line b) noexcept Ideal line subtraction. public ideal_line & operator*= (float s) noexcept Ideal line uniform scale. public ideal_line & operator*= (int s) noexcept Ideal line uniform scale. public ideal_line & operator/= (float s) noexcept Ideal line uniform inverse scale. public ideal_line & operator/= (int s) noexcept Ideal line uniform inverse scale. public float e01 () const noexcept public float e10 () const noexcept public float e02 () const noexcept public float e20 () const noexcept public float e03 () const noexcept public float e30 () const noexcept public ideal_line KLN_VEC_CALL operator+ (ideal_line a,ideal_line b) noexcept Ideal line addition. public ideal_line KLN_VEC_CALL operator- (ideal_line a,ideal_line b) noexcept Ideal line subtraction. public ideal_line KLN_VEC_CALL operator* (ideal_line l,float s) noexcept Ideal line uniform scale. public ideal_line KLN_VEC_CALL operator* (ideal_line l,int s) noexcept Ideal line uniform scale. public ideal_line KLN_VEC_CALL operator* (float s,ideal_line l) noexcept Ideal line uniform scale. public ideal_line KLN_VEC_CALL operator* (int s,ideal_line l) noexcept Ideal line uniform scale. public ideal_line KLN_VEC_CALL operator/ (ideal_line l,float s) noexcept Ideal line uniform inverse scale. public ideal_line KLN_VEC_CALL operator/ (ideal_line l,int s) noexcept public ideal_line KLN_VEC_CALL operator- (ideal_line l) noexcept Unary minus. public ideal_line KLN_VEC_CALL operator~ (ideal_line l) noexcept Reversion operator. public branch () = default public branch (float a,float b,float c) noexcept Construct the branch as the following multivector: public branch (__m128 xmm) noexcept public float squared_norm () noexcept If a line is constructed as the regressive product (join) of two points, the squared norm provided here is the squared distance between the two points (provided the points are normalized). Returns \\(d^2 + e^2 + f^2\\) . public float norm () noexcept Returns the square root of the quantity produced by squared_norm . public void normalize () noexcept public branch normalized () const noexcept public void invert () noexcept public branch inverse () const noexcept public branch &KLN_VEC_CALL operator+= (branch b) noexcept Branch addition. public branch &KLN_VEC_CALL operator-= (branch b) noexcept Branch subtraction. public branch & operator*= (float s) noexcept Branch uniform scale. public branch & operator*= (int s) noexcept Branch uniform scale. public branch & operator/= (float s) noexcept Branch uniform inverse scale. public branch & operator/= (int s) noexcept Branch uniform inverse scale. public float e12 () const noexcept public float e21 () const noexcept public float z () const noexcept public float e31 () const noexcept public float e13 () const noexcept public float y () const noexcept public float e23 () const noexcept public float e32 () const noexcept public float x () const noexcept public branch KLN_VEC_CALL operator+ (branch a,branch b) noexcept Branch addition. public branch KLN_VEC_CALL operator- (branch a,branch b) noexcept Branch subtraction. public branch KLN_VEC_CALL operator* (branch b,float s) noexcept Branch uniform scale. public branch KLN_VEC_CALL operator* (branch b,int s) noexcept Branch uniform scale. public branch KLN_VEC_CALL operator* (float s,branch b) noexcept Branch uniform scale. public branch KLN_VEC_CALL operator* (int s,branch b) noexcept Branch uniform scale. public branch KLN_VEC_CALL operator/ (branch b,float s) noexcept Branch uniform inverse scale. public branch KLN_VEC_CALL operator/ (branch b,int s) noexcept Branch uniform inverse scale. public branch KLN_VEC_CALL operator- (branch b) noexcept Unary minus. public branch KLN_VEC_CALL operator~ (branch b) noexcept Reversion operator. public line () = default public line (float a,float b,float c,float d,float e,float f) noexcept A line is specifed by 6 coordinates which correspond to the line's Pl\u00fccker coordinates . The coordinates specified in this way correspond to the following multivector: public line (__m128 xmm1,__m128 xmm2) noexcept public line (ideal_line other) noexcept public line (branch other) noexcept public float norm () noexcept Returns the square root of the quantity produced by squared_norm . public float squared_norm () noexcept If a line is constructed as the regressive product (join) of two points, the squared norm provided here is the squared distance between the two points (provided the points are normalized). Returns \\(d^2 + e^2 + f^2\\) . public void normalize () noexcept Normalize a line such that \\(\\ell^2 = -1\\) . public line normalized () const noexcept Return a normalized copy of this line. public void invert () noexcept public line inverse () const noexcept public bool KLN_VEC_CALL operator== (line other) const noexcept Bitwise comparison. public bool KLN_VEC_CALL approx_eq (line other,float epsilon) const noexcept public line &KLN_VEC_CALL operator+= (line b) noexcept Line addition. public line &KLN_VEC_CALL operator-= (line b) noexcept Line subtraction. public line & operator*= (float s) noexcept Line uniform scale. public line & operator*= (int s) noexcept Line uniform scale. public line & operator/= (float s) noexcept Line uniform inverse scale. public line & operator/= (int s) noexcept Line uniform inverse scale. public float e12 () const noexcept public float e21 () const noexcept public float e31 () const noexcept public float e13 () const noexcept public float e23 () const noexcept public float e32 () const noexcept public float e01 () const noexcept public float e10 () const noexcept public float e02 () const noexcept public float e20 () const noexcept public float e03 () const noexcept public float e30 () const noexcept public line KLN_VEC_CALL operator+ (line a,line b) noexcept Line addition. public line KLN_VEC_CALL operator- (line a,line b) noexcept Line subtraction. public line KLN_VEC_CALL operator* (line l,float s) noexcept Line uniform scale. public line KLN_VEC_CALL operator* (line l,int s) noexcept Line uniform scale. public line KLN_VEC_CALL operator* (float s,line l) noexcept Line uniform scale. public line KLN_VEC_CALL operator* (int s,line l) noexcept Line uniform scale. public line KLN_VEC_CALL operator/ (line r,float s) noexcept Line uniform inverse scale. public line KLN_VEC_CALL operator/ (line r,int s) noexcept Line uniform inverse scale. public line KLN_VEC_CALL operator- (line l) noexcept Unary minus. public line KLN_VEC_CALL operator~ (line l) noexcept Reversion operator.","title":"Summary"},{"location":"api/lines/#members","text":"","title":"Members"},{"location":"api/lines/#group__lines_1ga62ef2297496614693083466f12635558","text":"","title":"ideal_line() = default"},{"location":"api/lines/#group__lines_1ga23cf4cb2763929db4f63dabadc1b9b32","text":"","title":"ideal_line(float a,float b,float c) noexcept"},{"location":"api/lines/#group__lines_1ga0734f86c43d547402c7d06d4eddb0691","text":"","title":"ideal_line(__m128 xmm) noexcept"},{"location":"api/lines/#group__lines_1ga4da377f9f9687a69e0cc1c84b936d53e","text":"","title":"float  squared_ideal_norm() noexcept"},{"location":"api/lines/#group__lines_1gac38415e4e709ce83f215bfbbc6fa43a0","text":"","title":"float  ideal_norm() noexcept"},{"location":"api/lines/#group__lines_1ga6cd29f5c0d762ba34140adfb11e89d4c","text":"Ideal line addition.","title":"ideal_line &amp;KLN_VEC_CALL  operator+=(ideal_line b) noexcept"},{"location":"api/lines/#group__lines_1ga716f3c3a2bab34ea147157a129b259d0","text":"Ideal line subtraction.","title":"ideal_line &amp;KLN_VEC_CALL  operator-=(ideal_line b) noexcept"},{"location":"api/lines/#group__lines_1ga50c085e141902ec94366bedfc5eb1993","text":"Ideal line uniform scale.","title":"ideal_line &amp;  operator*=(float s) noexcept"},{"location":"api/lines/#group__lines_1ga848437f19a14e0e0f946420b388066c2","text":"Ideal line uniform scale.","title":"ideal_line &amp;  operator*=(int s) noexcept"},{"location":"api/lines/#group__lines_1gad5022268754a921e8a91b22745da62fe","text":"Ideal line uniform inverse scale.","title":"ideal_line &amp;  operator/=(float s) noexcept"},{"location":"api/lines/#group__lines_1ga6540e3a798f002b7add9bc83fad74b09","text":"Ideal line uniform inverse scale.","title":"ideal_line &amp;  operator/=(int s) noexcept"},{"location":"api/lines/#group__lines_1ga9209dc293ba4828ee9401471a2c39416","text":"","title":"float  e01() const noexcept"},{"location":"api/lines/#group__lines_1ga630a786b6a720571df80ce07be2b480d","text":"","title":"float  e10() const noexcept"},{"location":"api/lines/#group__lines_1ga64252faa6b55014eb29f1b0b0756c412","text":"","title":"float  e02() const noexcept"},{"location":"api/lines/#group__lines_1ga895a9f40d184bc766580cd4f937d9653","text":"","title":"float  e20() const noexcept"},{"location":"api/lines/#group__lines_1gad7926824f65759c7757206a16c955494","text":"","title":"float  e03() const noexcept"},{"location":"api/lines/#group__lines_1gaf9a7c9717ca8bca47567bc2eb9cbdf5e","text":"","title":"float  e30() const noexcept"},{"location":"api/lines/#group__lines_1gaf20ec975ef8d272dec782a21e92ad292","text":"Ideal line addition.","title":"ideal_line KLN_VEC_CALL  operator+(ideal_line a,ideal_line b) noexcept"},{"location":"api/lines/#group__lines_1gae3e8dad43c2e6da933169175481b8807","text":"Ideal line subtraction.","title":"ideal_line KLN_VEC_CALL  operator-(ideal_line a,ideal_line b) noexcept"},{"location":"api/lines/#group__lines_1ga8c687777271cee937c066f86cf8fc13e","text":"Ideal line uniform scale.","title":"ideal_line KLN_VEC_CALL  operator*(ideal_line l,float s) noexcept"},{"location":"api/lines/#group__lines_1ga585458c330e0b6d6e3725aeb6d1f1711","text":"Ideal line uniform scale.","title":"ideal_line KLN_VEC_CALL  operator*(ideal_line l,int s) noexcept"},{"location":"api/lines/#group__lines_1ga45fa818b3742c77e0a81fa35419e5a1d","text":"Ideal line uniform scale.","title":"ideal_line KLN_VEC_CALL  operator*(float s,ideal_line l) noexcept"},{"location":"api/lines/#group__lines_1ga1c749bb69e95b736eb7ccc14b198ff41","text":"Ideal line uniform scale.","title":"ideal_line KLN_VEC_CALL  operator*(int s,ideal_line l) noexcept"},{"location":"api/lines/#group__lines_1gad4c128535f9e5c60830442b18e62c419","text":"Ideal line uniform inverse scale.","title":"ideal_line KLN_VEC_CALL  operator/(ideal_line l,float s) noexcept"},{"location":"api/lines/#group__lines_1ga600666bf5950f2a58c1d6d0aaefa41f3","text":"","title":"ideal_line KLN_VEC_CALL  operator/(ideal_line l,int s) noexcept"},{"location":"api/lines/#group__lines_1ga3d10cab9e9f55da1b0aea1f95697854f","text":"Unary minus.","title":"ideal_line KLN_VEC_CALL  operator-(ideal_line l) noexcept"},{"location":"api/lines/#group__lines_1ga40e609b90210191b544d61d64032db7c","text":"Reversion operator.","title":"ideal_line KLN_VEC_CALL  operator~(ideal_line l) noexcept"},{"location":"api/lines/#group__lines_1gac0b6196328f798a024d116b0052dc933","text":"","title":"branch() = default"},{"location":"api/lines/#group__lines_1ga85e647f4c92a2dd6896c5afd849d00a5","text":"Construct the branch as the following multivector: \\[a \\mathbf{e}_{23} + b\\mathbf{e}_{31} + c\\mathbf{e}_{23}\\] To convince yourself this is a line through the origin, remember that such a line can be generated using the geometric product of two planes through the origin.","title":"branch(float a,float b,float c) noexcept"},{"location":"api/lines/#group__lines_1ga919bf9527b955fe1d58188edfe5aa802","text":"","title":"branch(__m128 xmm) noexcept"},{"location":"api/lines/#group__lines_1ga0c6c16090b660c63df26aacf985c6f0c","text":"If a line is constructed as the regressive product (join) of two points, the squared norm provided here is the squared distance between the two points (provided the points are normalized). Returns \\(d^2 + e^2 + f^2\\) .","title":"float  squared_norm() noexcept"},{"location":"api/lines/#group__lines_1ga6174cbd24d0189e3f5f9b893d63f5086","text":"Returns the square root of the quantity produced by squared_norm .","title":"float  norm() noexcept"},{"location":"api/lines/#group__lines_1ga4d9e87ff79bba150183642ac82404d13","text":"","title":"void  normalize() noexcept"},{"location":"api/lines/#group__lines_1ga9d8961eee2687dd2b0ec3626193a0849","text":"","title":"branch  normalized() const noexcept"},{"location":"api/lines/#group__lines_1ga1979e6270f96d0fdab20e96f2207c1fa","text":"","title":"void  invert() noexcept"},{"location":"api/lines/#group__lines_1ga73cc09b7435bf131f8497a179dff059b","text":"","title":"branch  inverse() const noexcept"},{"location":"api/lines/#group__lines_1gaeb5c16ed0187ff38df6c685529bb90c2","text":"Branch addition.","title":"branch &amp;KLN_VEC_CALL  operator+=(branch b) noexcept"},{"location":"api/lines/#group__lines_1ga69f66d6b2736f2fdaa02b45e72b1ba2f","text":"Branch subtraction.","title":"branch &amp;KLN_VEC_CALL  operator-=(branch b) noexcept"},{"location":"api/lines/#group__lines_1ga174b924bea5109230431bce2ec996d77","text":"Branch uniform scale.","title":"branch &amp;  operator*=(float s) noexcept"},{"location":"api/lines/#group__lines_1gaf522a7fcce5ccd8ec64dd519b1355945","text":"Branch uniform scale.","title":"branch &amp;  operator*=(int s) noexcept"},{"location":"api/lines/#group__lines_1ga0059f1b65a43b001a072cb6e2e7c0702","text":"Branch uniform inverse scale.","title":"branch &amp;  operator/=(float s) noexcept"},{"location":"api/lines/#group__lines_1gac2d5f7065b967c378f52e192b5cda886","text":"Branch uniform inverse scale.","title":"branch &amp;  operator/=(int s) noexcept"},{"location":"api/lines/#group__lines_1gaf242b6c3e610d5a328dd251dfa8f47d0","text":"","title":"float  e12() const noexcept"},{"location":"api/lines/#group__lines_1ga7523c736e05eea04cd848201b0a93506","text":"","title":"float  e21() const noexcept"},{"location":"api/lines/#group__lines_1ga9eebc3c6c95cec91949528d6ce064169","text":"","title":"float  z() const noexcept"},{"location":"api/lines/#group__lines_1gac71e905e0f2758d0a6fa2242a135a568","text":"","title":"float  e31() const noexcept"},{"location":"api/lines/#group__lines_1gaa00e179436a14b16c88dae12a42792c2","text":"","title":"float  e13() const noexcept"},{"location":"api/lines/#group__lines_1ga6093486d459bb08789ba50998e499794","text":"","title":"float  y() const noexcept"},{"location":"api/lines/#group__lines_1ga7af485388456f1d35f6d25b493e3c466","text":"","title":"float  e23() const noexcept"},{"location":"api/lines/#group__lines_1gaffda6cbc92f913c96c8c9697c7f498a7","text":"","title":"float  e32() const noexcept"},{"location":"api/lines/#group__lines_1ga639819fb843ea77e0cd153c370425267","text":"","title":"float  x() const noexcept"},{"location":"api/lines/#group__lines_1ga806e374cc4281cfc3eecec93d85a31fa","text":"Branch addition.","title":"branch KLN_VEC_CALL  operator+(branch a,branch b) noexcept"},{"location":"api/lines/#group__lines_1ga2bad4a299ed2bcb5fb8532af40608e3d","text":"Branch subtraction.","title":"branch KLN_VEC_CALL  operator-(branch a,branch b) noexcept"},{"location":"api/lines/#group__lines_1ga6f0f933a374ea30980fa71cc222fbdf1","text":"Branch uniform scale.","title":"branch KLN_VEC_CALL  operator*(branch b,float s) noexcept"},{"location":"api/lines/#group__lines_1ga06f26bbb23a3ac8bf2da68d6d86cb9a0","text":"Branch uniform scale.","title":"branch KLN_VEC_CALL  operator*(branch b,int s) noexcept"},{"location":"api/lines/#group__lines_1gafcb9d3b2717d1fdf3591c06894a285a2","text":"Branch uniform scale.","title":"branch KLN_VEC_CALL  operator*(float s,branch b) noexcept"},{"location":"api/lines/#group__lines_1gaacf02b8f4c3af4e74eb6a09eb849cdfa","text":"Branch uniform scale.","title":"branch KLN_VEC_CALL  operator*(int s,branch b) noexcept"},{"location":"api/lines/#group__lines_1ga029c94290f7cec1095460b3ca72fdb5c","text":"Branch uniform inverse scale.","title":"branch KLN_VEC_CALL  operator/(branch b,float s) noexcept"},{"location":"api/lines/#group__lines_1ga749e37e9a3b976563ac06098c5011bf6","text":"Branch uniform inverse scale.","title":"branch KLN_VEC_CALL  operator/(branch b,int s) noexcept"},{"location":"api/lines/#group__lines_1ga1445656708214b75860bc4c21dd92eac","text":"Unary minus.","title":"branch KLN_VEC_CALL  operator-(branch b) noexcept"},{"location":"api/lines/#group__lines_1gaad8d9b139430ae9be3c575741ee82d6e","text":"Reversion operator.","title":"branch KLN_VEC_CALL  operator~(branch b) noexcept"},{"location":"api/lines/#group__lines_1gaf274662f18385ec8065a083d235cc63e","text":"","title":"line() = default"},{"location":"api/lines/#group__lines_1ga3a7b1cdde6811a23a30cd5d4082ee5d7","text":"A line is specifed by 6 coordinates which correspond to the line's Pl\u00fccker coordinates . The coordinates specified in this way correspond to the following multivector: \\[a\\mathbf{e}_{01} + b\\mathbf{e}_{02} + c\\mathbf{e}_{03} +\\ d\\mathbf{e}_{23} + e\\mathbf{e}_{31} + f\\mathbf{e}_{12}\\]","title":"line(float a,float b,float c,float d,float e,float f) noexcept"},{"location":"api/lines/#group__lines_1ga185af75e75e036164d3c1754da405737","text":"","title":"line(__m128 xmm1,__m128 xmm2) noexcept"},{"location":"api/lines/#group__lines_1gaddbd98af6bc9a738816347a15a83c276","text":"","title":"line(ideal_line other) noexcept"},{"location":"api/lines/#group__lines_1gae8e557447c170f2cbb3004b6d9945a9e","text":"","title":"line(branch other) noexcept"},{"location":"api/lines/#group__lines_1gad388b8d134c0c22b1f82026277e39c22","text":"Returns the square root of the quantity produced by squared_norm .","title":"float  norm() noexcept"},{"location":"api/lines/#group__lines_1ga941c27dc8594f947ecf718160ebb084b","text":"If a line is constructed as the regressive product (join) of two points, the squared norm provided here is the squared distance between the two points (provided the points are normalized). Returns \\(d^2 + e^2 + f^2\\) .","title":"float  squared_norm() noexcept"},{"location":"api/lines/#group__lines_1ga1bf22b022eadfaf1e9f9179f346a4cd3","text":"Normalize a line such that \\(\\ell^2 = -1\\) .","title":"void  normalize() noexcept"},{"location":"api/lines/#group__lines_1ga276e9de782855e6c32560923dce491c4","text":"Return a normalized copy of this line.","title":"line  normalized() const noexcept"},{"location":"api/lines/#group__lines_1ga803c6bc20ae199f78a92419521366d2e","text":"","title":"void  invert() noexcept"},{"location":"api/lines/#group__lines_1gac196dc5ee3591a2c302d3d78cd7abcd8","text":"","title":"line  inverse() const noexcept"},{"location":"api/lines/#group__lines_1gae443bd972f232ca9c17924283ab210c6","text":"Bitwise comparison.","title":"bool KLN_VEC_CALL  operator==(line other) const noexcept"},{"location":"api/lines/#group__lines_1ga1b70abc509a2e60dbccb3131acd0801e","text":"","title":"bool KLN_VEC_CALL  approx_eq(line other,float epsilon) const noexcept"},{"location":"api/lines/#group__lines_1ga3189260b7a1b0b6cf1f09a5b1b9bb8f3","text":"Line addition.","title":"line &amp;KLN_VEC_CALL  operator+=(line b) noexcept"},{"location":"api/lines/#group__lines_1ga1ab6e11021c616adfb35f5b11e478447","text":"Line subtraction.","title":"line &amp;KLN_VEC_CALL  operator-=(line b) noexcept"},{"location":"api/lines/#group__lines_1ga64128e5413f0dd3e31808c6dae6aaad6","text":"Line uniform scale.","title":"line &amp;  operator*=(float s) noexcept"},{"location":"api/lines/#group__lines_1gabf0b448a99eda4e48f5b14c998dfbfbc","text":"Line uniform scale.","title":"line &amp;  operator*=(int s) noexcept"},{"location":"api/lines/#group__lines_1gab8d592169b9ed4abc4932a670d98131c","text":"Line uniform inverse scale.","title":"line &amp;  operator/=(float s) noexcept"},{"location":"api/lines/#group__lines_1ga23fdb26f06a4e172aec588b2034e56af","text":"Line uniform inverse scale.","title":"line &amp;  operator/=(int s) noexcept"},{"location":"api/lines/#group__lines_1ga1362bf5e4fbf12c0a1fadeaa4cba905a","text":"","title":"float  e12() const noexcept"},{"location":"api/lines/#group__lines_1gaed1b130b5124643dfe1baf82ef43a091","text":"","title":"float  e21() const noexcept"},{"location":"api/lines/#group__lines_1gaeed171a99dbd03a54aaeeb4297a5f7d4","text":"","title":"float  e31() const noexcept"},{"location":"api/lines/#group__lines_1ga49c1718902c977c0d04a9aae046d97d5","text":"","title":"float  e13() const noexcept"},{"location":"api/lines/#group__lines_1ga637c8b7fa555e5dd30b0faadd88d0095","text":"","title":"float  e23() const noexcept"},{"location":"api/lines/#group__lines_1gaa150f5a6ee68b810f27f9624496face0","text":"","title":"float  e32() const noexcept"},{"location":"api/lines/#group__lines_1gac29f9783375c336ab2d3fb67a3431f07","text":"","title":"float  e01() const noexcept"},{"location":"api/lines/#group__lines_1ga7d163f4afca8fd89a796056c909245d1","text":"","title":"float  e10() const noexcept"},{"location":"api/lines/#group__lines_1gaa38fe9ae6e00bc4d595713c01ac1dd9f","text":"","title":"float  e02() const noexcept"},{"location":"api/lines/#group__lines_1ga4f37f6f38b720170d3b41ecc33c1cef9","text":"","title":"float  e20() const noexcept"},{"location":"api/lines/#group__lines_1gacd1e4c54ab209259cbd3c3042f286580","text":"","title":"float  e03() const noexcept"},{"location":"api/lines/#group__lines_1gaa75f3c527da3e76fba0f63defd1e822d","text":"","title":"float  e30() const noexcept"},{"location":"api/lines/#group__lines_1ga0a83f2a48198edd9507f5bbd4c9b30db","text":"Line addition.","title":"line KLN_VEC_CALL  operator+(line a,line b) noexcept"},{"location":"api/lines/#group__lines_1gadb1e4f4b039a7b4876f5b594f31a3c18","text":"Line subtraction.","title":"line KLN_VEC_CALL  operator-(line a,line b) noexcept"},{"location":"api/lines/#group__lines_1ga2ab242c8429056ce8a0eaff272d58055","text":"Line uniform scale.","title":"line KLN_VEC_CALL  operator*(line l,float s) noexcept"},{"location":"api/lines/#group__lines_1gaeb3211aaaffb0c67796cd16fcc9fdfbb","text":"Line uniform scale.","title":"line KLN_VEC_CALL  operator*(line l,int s) noexcept"},{"location":"api/lines/#group__lines_1gafc0250185f6abbab4af1dfc7ddd7d82f","text":"Line uniform scale.","title":"line KLN_VEC_CALL  operator*(float s,line l) noexcept"},{"location":"api/lines/#group__lines_1ga8cb888db657b2113caea92ab8220594c","text":"Line uniform scale.","title":"line KLN_VEC_CALL  operator*(int s,line l) noexcept"},{"location":"api/lines/#group__lines_1gafb3d9b8897b0af53ecb7e20887be0485","text":"Line uniform inverse scale.","title":"line KLN_VEC_CALL  operator/(line r,float s) noexcept"},{"location":"api/lines/#group__lines_1gae8be4741283b0730feb08cdf697de2b1","text":"Line uniform inverse scale.","title":"line KLN_VEC_CALL  operator/(line r,int s) noexcept"},{"location":"api/lines/#group__lines_1ga17f373e90ac62d4218dae72f9f2099d3","text":"Unary minus.","title":"line KLN_VEC_CALL  operator-(line l) noexcept"},{"location":"api/lines/#group__lines_1gadb187ac167c98d721c8eea5eed2f0120","text":"Reversion operator.","title":"line KLN_VEC_CALL  operator~(line l) noexcept"},{"location":"api/motor/","text":"group motor A motor represents a kinematic motion in our algebra. From Chasles' theorem , we know that any rigid body displacement can be produced by a translation along a line, followed or preceded by a rotation about an axis parallel to that line. The motor algebra is isomorphic to the dual quaternions but exists here in the same algebra as all the other geometric entities and actions at our disposal. Operations such as composing a motor with a rotor or translator are possible for example. The primary benefit to using a motor over its corresponding matrix operation is twofold. First, you get the benefit of numerical stability when composing multiple actions via the geometric product ( * ). Second, because the motors constitute a continuous group, they are amenable to smooth interpolation and differentiation. Example // Create a rotor representing a pi/2 rotation about the z-axis // Normalization is done automatically rotor r { M_PI * 0.5f , 0.f , 0.f , 1.f }; // Create a translator that represents a translation of 1 unit // in the yz-direction. Normalization is done automatically. translator t { 1.f , 0.f , 1.f , 1.f }; // Create a motor that combines the action of the rotation and // translation above. motor m = r * t ; // Initialize a point at (1, 3, 2) kln :: point p1 { 1.f , 3.f , 2.f }; // Translate p1 and rotate it to create a new point p2 kln :: point p2 = m ( p1 ); Motors can be multiplied to one another with the * operator to create a new motor equivalent to the application of each factor. Example // Suppose we have 3 motors m1, m2, and m3 // The motor m created here represents the combined action of m1, // m2, and m3. kln :: motor m = m3 * m2 * m1 ; The same * operator can be used to compose the motor's action with other translators and rotors. A demonstration of using the exponential and logarithmic map to blend between two motors is provided in a test case here . Summary Members Descriptions public motor () = default public motor (float a,float b,float c,float d,float e,float f,float g,float h) noexcept Direct initialization from components. A more common way of creating a motor is to take a product between a rotor and a translator. The arguments coorespond to the multivector \\(a + b\\mathbf{e}_{23} + c\\mathbf{e}_{31} + d\\mathbf{e}_{12} +\\ e\\mathbf{e}_{01} + f\\mathbf{e}_{02} + g\\mathbf{e}_{03} +\\ h\\mathbf{e}_{0123}\\) . public motor (float ang_rad,float d,line l) noexcept Produce a screw motion rotating and translating by given amounts along a provided Euclidean axis. public motor (__m128 p1,__m128 p2) noexcept public KLN_VEC_CALL explicit motor (rotor r) noexcept public KLN_VEC_CALL explicit motor (translator t) noexcept public motor &KLN_VEC_CALL operator= (rotor r) noexcept public motor &KLN_VEC_CALL operator= (translator t) noexcept public void load (float * in) noexcept Load motor data using two unaligned loads. This routine does not assume the data passed in this way is normalized. public void normalize () noexcept Normalizes this motor \\(m\\) such that \\(m\\widetilde{m} = 1\\) . public motor normalized () const noexcept Return a normalized copy of this motor. public void invert () noexcept public motor inverse () const noexcept public void constrain () noexcept Constrains the motor to traverse the shortest arc. public motor constrained () const noexcept public bool KLN_VEC_CALL operator== (motor other) const noexcept Bitwise comparison. public bool KLN_VEC_CALL approx_eq (motor other,float epsilon) const noexcept public mat3x4 as_mat3x4 () const noexcept Convert this motor to a 3x4 column-major matrix representing this motor's action as a linear transformation. The motor must be normalized for this conversion to produce well-defined results, but is more efficient than a 4x4 matrix conversion. public mat4x4 as_mat4x4 () const noexcept Convert this motor to a 4x4 column-major matrix representing this motor's action as a linear transformation. public plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this motor and returns the result \\(mp\\widetilde{m}\\) . public void KLN_VEC_CALL operator() (plane * in,plane * out,size_t count) const noexcept Conjugates an array of planes with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this motor and returns the result \\(m\\ell \\widetilde{m}\\) . public void KLN_VEC_CALL operator() (line * in,line * out,size_t count) const noexcept Conjugates an array of lines with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this motor and returns the result \\(mp\\widetilde{m}\\) . public void KLN_VEC_CALL operator() (point * in,point * out,size_t count) const noexcept Conjugates an array of points with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public point KLN_VEC_CALL operator() (origin) const noexcept Conjugates the origin \\(O\\) with this motor and returns the result \\(mO\\widetilde{m}\\) . public direction KLN_VEC_CALL operator() (direction const & d) const noexcept Conjugates a direction \\(d\\) with this motor and returns the result \\(md\\widetilde{m}\\) . public void KLN_VEC_CALL operator() (direction * in,direction * out,size_t count) const noexcept Conjugates an array of directions with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public motor &KLN_VEC_CALL operator+= (motor b) noexcept Motor addition. public motor &KLN_VEC_CALL operator-= (motor b) noexcept Motor subtraction. public motor & operator*= (float s) noexcept Motor uniform scale. public motor & operator*= (int s) noexcept Motor uniform scale. public motor & operator/= (float s) noexcept Motor uniform inverse scale. public motor & operator/= (int s) noexcept Motor uniform inverse scale. public float scalar () const noexcept public float e12 () const noexcept public float e21 () const noexcept public float e31 () const noexcept public float e13 () const noexcept public float e23 () const noexcept public float e32 () const noexcept public float e01 () const noexcept public float e10 () const noexcept public float e02 () const noexcept public float e20 () const noexcept public float e03 () const noexcept public float e30 () const noexcept public float e0123 () const noexcept public motor KLN_VEC_CALL operator+ (motor a,motor b) noexcept Motor addition. public motor KLN_VEC_CALL operator- (motor a,motor b) noexcept Motor subtraction. public motor KLN_VEC_CALL operator* (motor l,float s) noexcept Motor uniform scale. public motor KLN_VEC_CALL operator* (motor l,int s) noexcept Motor uniform scale. public motor KLN_VEC_CALL operator* (float s,motor l) noexcept Motor uniform scale. public motor KLN_VEC_CALL operator* (int s,motor l) noexcept Motor uniform scale. public motor KLN_VEC_CALL operator/ (motor r,float s) noexcept Motor uniform inverse scale. public motor KLN_VEC_CALL operator/ (motor r,int s) noexcept Motor uniform inverse scale. public motor KLN_VEC_CALL operator- (motor m) noexcept Unary minus. public motor KLN_VEC_CALL operator~ (motor m) noexcept Reversion operator. Members motor () = default motor (float a,float b,float c,float d,float e,float f,float g,float h) noexcept Direct initialization from components. A more common way of creating a motor is to take a product between a rotor and a translator. The arguments coorespond to the multivector \\(a + b\\mathbf{e}_{23} + c\\mathbf{e}_{31} + d\\mathbf{e}_{12} +\\ e\\mathbf{e}_{01} + f\\mathbf{e}_{02} + g\\mathbf{e}_{03} +\\ h\\mathbf{e}_{0123}\\) . motor (float ang_rad,float d,line l) noexcept Produce a screw motion rotating and translating by given amounts along a provided Euclidean axis. motor (__m128 p1,__m128 p2) noexcept KLN_VEC_CALL explicit motor (rotor r) noexcept KLN_VEC_CALL explicit motor (translator t) noexcept motor &KLN_VEC_CALL operator= (rotor r) noexcept motor &KLN_VEC_CALL operator= (translator t) noexcept void load (float * in) noexcept Load motor data using two unaligned loads. This routine does not assume the data passed in this way is normalized. void normalize () noexcept Normalizes this motor \\(m\\) such that \\(m\\widetilde{m} = 1\\) . motor normalized () const noexcept Return a normalized copy of this motor. void invert () noexcept motor inverse () const noexcept void constrain () noexcept Constrains the motor to traverse the shortest arc. motor constrained () const noexcept bool KLN_VEC_CALL operator== (motor other) const noexcept Bitwise comparison. bool KLN_VEC_CALL approx_eq (motor other,float epsilon) const noexcept mat3x4 as_mat3x4 () const noexcept Convert this motor to a 3x4 column-major matrix representing this motor's action as a linear transformation. The motor must be normalized for this conversion to produce well-defined results, but is more efficient than a 4x4 matrix conversion. mat4x4 as_mat4x4 () const noexcept Convert this motor to a 4x4 column-major matrix representing this motor's action as a linear transformation. plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this motor and returns the result \\(mp\\widetilde{m}\\) . void KLN_VEC_CALL operator() (plane * in,plane * out,size_t count) const noexcept Conjugates an array of planes with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). Tip When applying a motor to a list of tightly packed planes, this routine will be significantly faster than applying the motor to each plane individually. line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this motor and returns the result \\(m\\ell \\widetilde{m}\\) . void KLN_VEC_CALL operator() (line * in,line * out,size_t count) const noexcept Conjugates an array of lines with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). Tip When applying a motor to a list of tightly packed lines, this routine will be significantly faster than applying the motor to each line individually. point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this motor and returns the result \\(mp\\widetilde{m}\\) . void KLN_VEC_CALL operator() (point * in,point * out,size_t count) const noexcept Conjugates an array of points with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). Tip When applying a motor to a list of tightly packed points, this routine will be significantly faster than applying the motor to each point individually. point KLN_VEC_CALL operator() (origin) const noexcept Conjugates the origin \\(O\\) with this motor and returns the result \\(mO\\widetilde{m}\\) . direction KLN_VEC_CALL operator() (direction const & d) const noexcept Conjugates a direction \\(d\\) with this motor and returns the result \\(md\\widetilde{m}\\) . The cost of this operation is the same as the application of a rotor due to the translational invariance of directions (points at infinity). void KLN_VEC_CALL operator() (direction * in,direction * out,size_t count) const noexcept Conjugates an array of directions with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). The cost of this operation is the same as the application of a rotor due to the translational invariance of directions (points at infinity). Tip When applying a motor to a list of tightly packed directions, this routine will be significantly faster than applying the motor to each direction individually. motor &KLN_VEC_CALL operator+= (motor b) noexcept Motor addition. motor &KLN_VEC_CALL operator-= (motor b) noexcept Motor subtraction. motor & operator*= (float s) noexcept Motor uniform scale. motor & operator*= (int s) noexcept Motor uniform scale. motor & operator/= (float s) noexcept Motor uniform inverse scale. motor & operator/= (int s) noexcept Motor uniform inverse scale. float scalar () const noexcept float e12 () const noexcept float e21 () const noexcept float e31 () const noexcept float e13 () const noexcept float e23 () const noexcept float e32 () const noexcept float e01 () const noexcept float e10 () const noexcept float e02 () const noexcept float e20 () const noexcept float e03 () const noexcept float e30 () const noexcept float e0123 () const noexcept motor KLN_VEC_CALL operator+ (motor a,motor b) noexcept Motor addition. motor KLN_VEC_CALL operator- (motor a,motor b) noexcept Motor subtraction. motor KLN_VEC_CALL operator* (motor l,float s) noexcept Motor uniform scale. motor KLN_VEC_CALL operator* (motor l,int s) noexcept Motor uniform scale. motor KLN_VEC_CALL operator* (float s,motor l) noexcept Motor uniform scale. motor KLN_VEC_CALL operator* (int s,motor l) noexcept Motor uniform scale. motor KLN_VEC_CALL operator/ (motor r,float s) noexcept Motor uniform inverse scale. motor KLN_VEC_CALL operator/ (motor r,int s) noexcept Motor uniform inverse scale. motor KLN_VEC_CALL operator- (motor m) noexcept Unary minus. motor KLN_VEC_CALL operator~ (motor m) noexcept Reversion operator.","title":"Motor"},{"location":"api/motor/#group__motor","text":"A motor represents a kinematic motion in our algebra. From Chasles' theorem , we know that any rigid body displacement can be produced by a translation along a line, followed or preceded by a rotation about an axis parallel to that line. The motor algebra is isomorphic to the dual quaternions but exists here in the same algebra as all the other geometric entities and actions at our disposal. Operations such as composing a motor with a rotor or translator are possible for example. The primary benefit to using a motor over its corresponding matrix operation is twofold. First, you get the benefit of numerical stability when composing multiple actions via the geometric product ( * ). Second, because the motors constitute a continuous group, they are amenable to smooth interpolation and differentiation. Example // Create a rotor representing a pi/2 rotation about the z-axis // Normalization is done automatically rotor r { M_PI * 0.5f , 0.f , 0.f , 1.f }; // Create a translator that represents a translation of 1 unit // in the yz-direction. Normalization is done automatically. translator t { 1.f , 0.f , 1.f , 1.f }; // Create a motor that combines the action of the rotation and // translation above. motor m = r * t ; // Initialize a point at (1, 3, 2) kln :: point p1 { 1.f , 3.f , 2.f }; // Translate p1 and rotate it to create a new point p2 kln :: point p2 = m ( p1 ); Motors can be multiplied to one another with the * operator to create a new motor equivalent to the application of each factor. Example // Suppose we have 3 motors m1, m2, and m3 // The motor m created here represents the combined action of m1, // m2, and m3. kln :: motor m = m3 * m2 * m1 ; The same * operator can be used to compose the motor's action with other translators and rotors. A demonstration of using the exponential and logarithmic map to blend between two motors is provided in a test case here .","title":"group motor"},{"location":"api/motor/#summary","text":"Members Descriptions public motor () = default public motor (float a,float b,float c,float d,float e,float f,float g,float h) noexcept Direct initialization from components. A more common way of creating a motor is to take a product between a rotor and a translator. The arguments coorespond to the multivector \\(a + b\\mathbf{e}_{23} + c\\mathbf{e}_{31} + d\\mathbf{e}_{12} +\\ e\\mathbf{e}_{01} + f\\mathbf{e}_{02} + g\\mathbf{e}_{03} +\\ h\\mathbf{e}_{0123}\\) . public motor (float ang_rad,float d,line l) noexcept Produce a screw motion rotating and translating by given amounts along a provided Euclidean axis. public motor (__m128 p1,__m128 p2) noexcept public KLN_VEC_CALL explicit motor (rotor r) noexcept public KLN_VEC_CALL explicit motor (translator t) noexcept public motor &KLN_VEC_CALL operator= (rotor r) noexcept public motor &KLN_VEC_CALL operator= (translator t) noexcept public void load (float * in) noexcept Load motor data using two unaligned loads. This routine does not assume the data passed in this way is normalized. public void normalize () noexcept Normalizes this motor \\(m\\) such that \\(m\\widetilde{m} = 1\\) . public motor normalized () const noexcept Return a normalized copy of this motor. public void invert () noexcept public motor inverse () const noexcept public void constrain () noexcept Constrains the motor to traverse the shortest arc. public motor constrained () const noexcept public bool KLN_VEC_CALL operator== (motor other) const noexcept Bitwise comparison. public bool KLN_VEC_CALL approx_eq (motor other,float epsilon) const noexcept public mat3x4 as_mat3x4 () const noexcept Convert this motor to a 3x4 column-major matrix representing this motor's action as a linear transformation. The motor must be normalized for this conversion to produce well-defined results, but is more efficient than a 4x4 matrix conversion. public mat4x4 as_mat4x4 () const noexcept Convert this motor to a 4x4 column-major matrix representing this motor's action as a linear transformation. public plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this motor and returns the result \\(mp\\widetilde{m}\\) . public void KLN_VEC_CALL operator() (plane * in,plane * out,size_t count) const noexcept Conjugates an array of planes with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this motor and returns the result \\(m\\ell \\widetilde{m}\\) . public void KLN_VEC_CALL operator() (line * in,line * out,size_t count) const noexcept Conjugates an array of lines with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this motor and returns the result \\(mp\\widetilde{m}\\) . public void KLN_VEC_CALL operator() (point * in,point * out,size_t count) const noexcept Conjugates an array of points with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public point KLN_VEC_CALL operator() (origin) const noexcept Conjugates the origin \\(O\\) with this motor and returns the result \\(mO\\widetilde{m}\\) . public direction KLN_VEC_CALL operator() (direction const & d) const noexcept Conjugates a direction \\(d\\) with this motor and returns the result \\(md\\widetilde{m}\\) . public void KLN_VEC_CALL operator() (direction * in,direction * out,size_t count) const noexcept Conjugates an array of directions with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public motor &KLN_VEC_CALL operator+= (motor b) noexcept Motor addition. public motor &KLN_VEC_CALL operator-= (motor b) noexcept Motor subtraction. public motor & operator*= (float s) noexcept Motor uniform scale. public motor & operator*= (int s) noexcept Motor uniform scale. public motor & operator/= (float s) noexcept Motor uniform inverse scale. public motor & operator/= (int s) noexcept Motor uniform inverse scale. public float scalar () const noexcept public float e12 () const noexcept public float e21 () const noexcept public float e31 () const noexcept public float e13 () const noexcept public float e23 () const noexcept public float e32 () const noexcept public float e01 () const noexcept public float e10 () const noexcept public float e02 () const noexcept public float e20 () const noexcept public float e03 () const noexcept public float e30 () const noexcept public float e0123 () const noexcept public motor KLN_VEC_CALL operator+ (motor a,motor b) noexcept Motor addition. public motor KLN_VEC_CALL operator- (motor a,motor b) noexcept Motor subtraction. public motor KLN_VEC_CALL operator* (motor l,float s) noexcept Motor uniform scale. public motor KLN_VEC_CALL operator* (motor l,int s) noexcept Motor uniform scale. public motor KLN_VEC_CALL operator* (float s,motor l) noexcept Motor uniform scale. public motor KLN_VEC_CALL operator* (int s,motor l) noexcept Motor uniform scale. public motor KLN_VEC_CALL operator/ (motor r,float s) noexcept Motor uniform inverse scale. public motor KLN_VEC_CALL operator/ (motor r,int s) noexcept Motor uniform inverse scale. public motor KLN_VEC_CALL operator- (motor m) noexcept Unary minus. public motor KLN_VEC_CALL operator~ (motor m) noexcept Reversion operator.","title":"Summary"},{"location":"api/motor/#members","text":"","title":"Members"},{"location":"api/motor/#group__motor_1ga96e82b7a735eed93288b76e1ecb3c13c","text":"","title":"motor() = default"},{"location":"api/motor/#group__motor_1ga0fc9829b8e6323e3ae2cc583361ce3d5","text":"Direct initialization from components. A more common way of creating a motor is to take a product between a rotor and a translator. The arguments coorespond to the multivector \\(a + b\\mathbf{e}_{23} + c\\mathbf{e}_{31} + d\\mathbf{e}_{12} +\\ e\\mathbf{e}_{01} + f\\mathbf{e}_{02} + g\\mathbf{e}_{03} +\\ h\\mathbf{e}_{0123}\\) .","title":"motor(float a,float b,float c,float d,float e,float f,float g,float h) noexcept"},{"location":"api/motor/#group__motor_1ga5cb2fa5186236dffe8ddc875ad0b5063","text":"Produce a screw motion rotating and translating by given amounts along a provided Euclidean axis.","title":"motor(float ang_rad,float d,line l) noexcept"},{"location":"api/motor/#group__motor_1gae0f8cc6b72368628648b650d0fb21186","text":"","title":"motor(__m128 p1,__m128 p2) noexcept"},{"location":"api/motor/#group__motor_1ga87f97067c7decdab7ee4fda78dc37e88","text":"","title":"KLN_VEC_CALL explicit  motor(rotor r) noexcept"},{"location":"api/motor/#group__motor_1ga032fcbcf02e92c46144674a3365fc75a","text":"","title":"KLN_VEC_CALL explicit  motor(translator t) noexcept"},{"location":"api/motor/#group__motor_1ga34cad9009f782f022e61b57d2364e414","text":"","title":"motor &amp;KLN_VEC_CALL  operator=(rotor r) noexcept"},{"location":"api/motor/#group__motor_1gacbd7ff04372942af09879f71d0f62d3a","text":"","title":"motor &amp;KLN_VEC_CALL  operator=(translator t) noexcept"},{"location":"api/motor/#group__motor_1ga3a048b8d0f35322259f8f1cbaad88cab","text":"Load motor data using two unaligned loads. This routine does not assume the data passed in this way is normalized.","title":"void  load(float * in) noexcept"},{"location":"api/motor/#group__motor_1ga8af12b78c4e98b84c51f605b47dbc0a1","text":"Normalizes this motor \\(m\\) such that \\(m\\widetilde{m} = 1\\) .","title":"void  normalize() noexcept"},{"location":"api/motor/#group__motor_1ga6d04fd7c7cfc51f614e73018f1e92122","text":"Return a normalized copy of this motor.","title":"motor  normalized() const noexcept"},{"location":"api/motor/#group__motor_1ga934628e8e8f6d444b1d2fde50e44e219","text":"","title":"void  invert() noexcept"},{"location":"api/motor/#group__motor_1ga0eacf6f6c4f25da1746a9769040ef17f","text":"","title":"motor  inverse() const noexcept"},{"location":"api/motor/#group__motor_1gae856f717434c757ae51f7b63d3a46871","text":"Constrains the motor to traverse the shortest arc.","title":"void  constrain() noexcept"},{"location":"api/motor/#group__motor_1ga7db461c10aede892e0d3abd5be0fa099","text":"","title":"motor  constrained() const noexcept"},{"location":"api/motor/#group__motor_1ga96324fdd9ee73afdc3b246b1aa1177a0","text":"Bitwise comparison.","title":"bool KLN_VEC_CALL  operator==(motor other) const noexcept"},{"location":"api/motor/#group__motor_1ga38cc29c04cc13dadeac2b93547079ced","text":"","title":"bool KLN_VEC_CALL  approx_eq(motor other,float epsilon) const noexcept"},{"location":"api/motor/#group__motor_1gae07a4ac9001f3afe4e1200e114ccf4c6","text":"Convert this motor to a 3x4 column-major matrix representing this motor's action as a linear transformation. The motor must be normalized for this conversion to produce well-defined results, but is more efficient than a 4x4 matrix conversion.","title":"mat3x4  as_mat3x4() const noexcept"},{"location":"api/motor/#group__motor_1gaa84cd8df11fc906888dff2fd20fa6e7b","text":"Convert this motor to a 4x4 column-major matrix representing this motor's action as a linear transformation.","title":"mat4x4  as_mat4x4() const noexcept"},{"location":"api/motor/#group__motor_1gaa0a1d879d7716f962c1c18a0d8483196","text":"Conjugates a plane \\(p\\) with this motor and returns the result \\(mp\\widetilde{m}\\) .","title":"plane KLN_VEC_CALL  operator()(plane const &amp; p) const noexcept"},{"location":"api/motor/#group__motor_1gaff16ea8f993f2c7ddb7e64aa5fd089ad","text":"Conjugates an array of planes with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). Tip When applying a motor to a list of tightly packed planes, this routine will be significantly faster than applying the motor to each plane individually.","title":"void KLN_VEC_CALL  operator()(plane * in,plane * out,size_t count) const noexcept"},{"location":"api/motor/#group__motor_1gaddae2fa94b3f6aa0045209c7692397e7","text":"Conjugates a line \\(\\ell\\) with this motor and returns the result \\(m\\ell \\widetilde{m}\\) .","title":"line KLN_VEC_CALL  operator()(line const &amp; l) const noexcept"},{"location":"api/motor/#group__motor_1ga63d8a856db029b21898c203115c431e0","text":"Conjugates an array of lines with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). Tip When applying a motor to a list of tightly packed lines, this routine will be significantly faster than applying the motor to each line individually.","title":"void KLN_VEC_CALL  operator()(line * in,line * out,size_t count) const noexcept"},{"location":"api/motor/#group__motor_1ga7ae8d73c558d1f6581df3a4b50fb2a40","text":"Conjugates a point \\(p\\) with this motor and returns the result \\(mp\\widetilde{m}\\) .","title":"point KLN_VEC_CALL  operator()(point const &amp; p) const noexcept"},{"location":"api/motor/#group__motor_1gab14cf440bf8281b4a56cc338c568156b","text":"Conjugates an array of points with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). Tip When applying a motor to a list of tightly packed points, this routine will be significantly faster than applying the motor to each point individually.","title":"void KLN_VEC_CALL  operator()(point * in,point * out,size_t count) const noexcept"},{"location":"api/motor/#group__motor_1gafa77e3a1d5a8f28bf6eee4de9e174489","text":"Conjugates the origin \\(O\\) with this motor and returns the result \\(mO\\widetilde{m}\\) .","title":"point KLN_VEC_CALL  operator()(origin) const noexcept"},{"location":"api/motor/#group__motor_1gac8debbfe23b80affa7bf9ef7e0dffc1f","text":"Conjugates a direction \\(d\\) with this motor and returns the result \\(md\\widetilde{m}\\) . The cost of this operation is the same as the application of a rotor due to the translational invariance of directions (points at infinity).","title":"direction KLN_VEC_CALL  operator()(direction const &amp; d) const noexcept"},{"location":"api/motor/#group__motor_1gaff385bad1df3b7ee29439b56bec43376","text":"Conjugates an array of directions with this motor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). The cost of this operation is the same as the application of a rotor due to the translational invariance of directions (points at infinity). Tip When applying a motor to a list of tightly packed directions, this routine will be significantly faster than applying the motor to each direction individually.","title":"void KLN_VEC_CALL  operator()(direction * in,direction * out,size_t count) const noexcept"},{"location":"api/motor/#group__motor_1ga818ff5291121c508902dca5f1e5b7a09","text":"Motor addition.","title":"motor &amp;KLN_VEC_CALL  operator+=(motor b) noexcept"},{"location":"api/motor/#group__motor_1ga339f89870f76a0016cfadf2fc68cd918","text":"Motor subtraction.","title":"motor &amp;KLN_VEC_CALL  operator-=(motor b) noexcept"},{"location":"api/motor/#group__motor_1gafd63fa96a2333b28014f8e3a7a4134ca","text":"Motor uniform scale.","title":"motor &amp;  operator*=(float s) noexcept"},{"location":"api/motor/#group__motor_1ga119d48b12fc69b8fa0d1d02654d719a8","text":"Motor uniform scale.","title":"motor &amp;  operator*=(int s) noexcept"},{"location":"api/motor/#group__motor_1gad8ffc1682cb5df750eea6436a4f27d77","text":"Motor uniform inverse scale.","title":"motor &amp;  operator/=(float s) noexcept"},{"location":"api/motor/#group__motor_1gaa8b3dad31ce3e1fd6d62ee72e5b826e0","text":"Motor uniform inverse scale.","title":"motor &amp;  operator/=(int s) noexcept"},{"location":"api/motor/#group__motor_1ga2dad79dbeb201dc9dafad1c94ecd51cc","text":"","title":"float  scalar() const noexcept"},{"location":"api/motor/#group__motor_1ga0d37119c1407e00425424c4784e7f075","text":"","title":"float  e12() const noexcept"},{"location":"api/motor/#group__motor_1ga6d47c218ab3242156f10106fdf36a777","text":"","title":"float  e21() const noexcept"},{"location":"api/motor/#group__motor_1gae65d5ca5b4d158e23c942f93e3e2a6c1","text":"","title":"float  e31() const noexcept"},{"location":"api/motor/#group__motor_1ga12938d12f57ccb5f76e7594912582f7e","text":"","title":"float  e13() const noexcept"},{"location":"api/motor/#group__motor_1ga016619bad5d460399f782c396a4f1790","text":"","title":"float  e23() const noexcept"},{"location":"api/motor/#group__motor_1gadba251b758a64f618a0768b25de96644","text":"","title":"float  e32() const noexcept"},{"location":"api/motor/#group__motor_1gad7a738cbde6bf041842e9fce7db1a9aa","text":"","title":"float  e01() const noexcept"},{"location":"api/motor/#group__motor_1gac75be08d6e10f57e8c568968ff11fb0d","text":"","title":"float  e10() const noexcept"},{"location":"api/motor/#group__motor_1ga6e8d74bcf2ba45b732b34493104d9a68","text":"","title":"float  e02() const noexcept"},{"location":"api/motor/#group__motor_1ga119218e9aa8d5c1df3c06ac2a79d7eed","text":"","title":"float  e20() const noexcept"},{"location":"api/motor/#group__motor_1ga0f483bcb7243e177dc9815f383066fd1","text":"","title":"float  e03() const noexcept"},{"location":"api/motor/#group__motor_1ga607a40f4fffbad7fb4776ba68bbb1fea","text":"","title":"float  e30() const noexcept"},{"location":"api/motor/#group__motor_1ga7c31381a8ba0be1d784f79f787ca06fc","text":"","title":"float  e0123() const noexcept"},{"location":"api/motor/#group__motor_1ga55bb0d01d56750ae852cccc9127ae60b","text":"Motor addition.","title":"motor KLN_VEC_CALL  operator+(motor a,motor b) noexcept"},{"location":"api/motor/#group__motor_1ga3cb485fe89040eb6d01c70c96a031a14","text":"Motor subtraction.","title":"motor KLN_VEC_CALL  operator-(motor a,motor b) noexcept"},{"location":"api/motor/#group__motor_1gafdb054b171b09ab54d6476d86e5d61e5","text":"Motor uniform scale.","title":"motor KLN_VEC_CALL  operator*(motor l,float s) noexcept"},{"location":"api/motor/#group__motor_1gae7eb210b5f7b49e24db9ee02fda857e3","text":"Motor uniform scale.","title":"motor KLN_VEC_CALL  operator*(motor l,int s) noexcept"},{"location":"api/motor/#group__motor_1ga046f149d83052d0f83a7d24e48653d00","text":"Motor uniform scale.","title":"motor KLN_VEC_CALL  operator*(float s,motor l) noexcept"},{"location":"api/motor/#group__motor_1gadeb2482d5ca5548b73fbc81ea1559169","text":"Motor uniform scale.","title":"motor KLN_VEC_CALL  operator*(int s,motor l) noexcept"},{"location":"api/motor/#group__motor_1gab9468a090086428d6c48d47f75e8b0e7","text":"Motor uniform inverse scale.","title":"motor KLN_VEC_CALL  operator/(motor r,float s) noexcept"},{"location":"api/motor/#group__motor_1gacd7a8807bc6b6238b893150a8d8f97ca","text":"Motor uniform inverse scale.","title":"motor KLN_VEC_CALL  operator/(motor r,int s) noexcept"},{"location":"api/motor/#group__motor_1gaf953e632f3ddff1dc435c3070e07c9b5","text":"Unary minus.","title":"motor KLN_VEC_CALL  operator-(motor m) noexcept"},{"location":"api/motor/#group__motor_1gaf4f013b57e29f6925ddfdf2d6e25ce0a","text":"Reversion operator.","title":"motor KLN_VEC_CALL  operator~(motor m) noexcept"},{"location":"api/plane/","text":"group plane In projective geometry, planes are the fundamental element through which all other entities are constructed. Lines are the meet of two planes, and points are the meet of three planes (equivalently, a line and a plane). The plane multivector in PGA looks like \\(d\\mathbf{e}_0 + a\\mathbf{e}_1 + b\\mathbf{e}_2 + c\\mathbf{e}_3\\) . Points that reside on the plane satisfy the familiar equation \\(d + ax + by + cz = 0\\) . Summary Members Descriptions public plane () = default public plane (__m128 xmm) noexcept public plane (float a,float b,float c,float d) noexcept The constructor performs the rearrangement so the plane can be specified in the familiar form: ax + by + cz + d public explicit plane (float * data) noexcept Data should point to four floats with memory layout (d, a, b, c) where d occupies the lowest address in memory. public void load (float * data) noexcept Unaligned load of data. The data argument should point to 4 floats corresponding to the (d, a, b, c) components of the plane multivector where d occupies the lowest address in memory. public void normalize () noexcept Normalize this plane \\(p\\) such that \\(p \\cdot p = 1\\) . public plane normalized () const noexcept Return a normalized copy of this plane. public float norm () const noexcept Compute the plane norm, which is often used to compute distances between points and lines. public void invert () noexcept public plane inverse () const noexcept public bool KLN_VEC_CALL operator== (plane other) const noexcept public bool KLN_VEC_CALL approx_eq (plane other,float epsilon) const noexcept public plane KLN_VEC_CALL operator() (plane const & p) const noexcept Reflect another plane \\(p_2\\) through this plane \\(p_1\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p_1 p_2 p_1\\) . public line KLN_VEC_CALL operator() (line const & l) const noexcept Reflect line \\(\\ell\\) through this plane \\(p\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p \\ell p\\) . public point KLN_VEC_CALL operator() (point const & p) const noexcept Reflect the point \\(P\\) through this plane \\(p\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p P p\\) . public plane &KLN_VEC_CALL operator+= (plane b) noexcept Plane addition. public plane &KLN_VEC_CALL operator-= (plane b) noexcept Plane subtraction. public plane & operator*= (float s) noexcept Plane uniform scale. public plane & operator*= (int s) noexcept Plane uniform scale. public plane & operator/= (float s) noexcept Plane uniform inverse scale. public plane & operator/= (int s) noexcept Plane uniform inverse scale. public float x () const noexcept public float e1 () const noexcept public float y () const noexcept public float e2 () const noexcept public float z () const noexcept public float e3 () const noexcept public float d () const noexcept public float e0 () const noexcept public plane KLN_VEC_CALL operator+ (plane a,plane b) noexcept Plane addition. public plane KLN_VEC_CALL operator- (plane a,plane b) noexcept Plane subtraction. public plane KLN_VEC_CALL operator* (plane p,float s) noexcept Plane uniform scale. public plane KLN_VEC_CALL operator* (float s,plane p) noexcept Plane uniform scale. public plane KLN_VEC_CALL operator* (plane p,int s) noexcept Plane uniform scale. public plane KLN_VEC_CALL operator* (int s,plane p) noexcept Plane uniform scale. public plane KLN_VEC_CALL operator/ (plane p,float s) noexcept Plane uniform inverse scale. public plane KLN_VEC_CALL operator/ (plane p,int s) noexcept Plane uniform inverse scale. public plane KLN_VEC_CALL operator- (plane p) noexcept Unary minus (leaves displacement from origin untouched, changing orientation only) Members plane () = default plane (__m128 xmm) noexcept plane (float a,float b,float c,float d) noexcept The constructor performs the rearrangement so the plane can be specified in the familiar form: ax + by + cz + d explicit plane (float * data) noexcept Data should point to four floats with memory layout (d, a, b, c) where d occupies the lowest address in memory. void load (float * data) noexcept Unaligned load of data. The data argument should point to 4 floats corresponding to the (d, a, b, c) components of the plane multivector where d occupies the lowest address in memory. Tip This is a faster mechanism for setting data compared to setting components one at a time. void normalize () noexcept Normalize this plane \\(p\\) such that \\(p \\cdot p = 1\\) . In order to compute the cosine of the angle between planes via the inner product operator | , the planes must be normalized. Producing a normalized rotor between two planes with the geometric product * also requires that the planes are normalized. plane normalized () const noexcept Return a normalized copy of this plane. float norm () const noexcept Compute the plane norm, which is often used to compute distances between points and lines. Given a normalized point \\(P\\) and normalized line \\(\\ell\\) , the plane \\(P\\vee\\ell\\) containing both \\(\\ell\\) and \\(P\\) will have a norm equivalent to the distance between \\(P\\) and \\(\\ell\\) . void invert () noexcept plane inverse () const noexcept bool KLN_VEC_CALL operator== (plane other) const noexcept bool KLN_VEC_CALL approx_eq (plane other,float epsilon) const noexcept plane KLN_VEC_CALL operator() (plane const & p) const noexcept Reflect another plane \\(p_2\\) through this plane \\(p_1\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p_1 p_2 p_1\\) . line KLN_VEC_CALL operator() (line const & l) const noexcept Reflect line \\(\\ell\\) through this plane \\(p\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p \\ell p\\) . point KLN_VEC_CALL operator() (point const & p) const noexcept Reflect the point \\(P\\) through this plane \\(p\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p P p\\) . plane &KLN_VEC_CALL operator+= (plane b) noexcept Plane addition. plane &KLN_VEC_CALL operator-= (plane b) noexcept Plane subtraction. plane & operator*= (float s) noexcept Plane uniform scale. plane & operator*= (int s) noexcept Plane uniform scale. plane & operator/= (float s) noexcept Plane uniform inverse scale. plane & operator/= (int s) noexcept Plane uniform inverse scale. float x () const noexcept float e1 () const noexcept float y () const noexcept float e2 () const noexcept float z () const noexcept float e3 () const noexcept float d () const noexcept float e0 () const noexcept plane KLN_VEC_CALL operator+ (plane a,plane b) noexcept Plane addition. plane KLN_VEC_CALL operator- (plane a,plane b) noexcept Plane subtraction. plane KLN_VEC_CALL operator* (plane p,float s) noexcept Plane uniform scale. plane KLN_VEC_CALL operator* (float s,plane p) noexcept Plane uniform scale. plane KLN_VEC_CALL operator* (plane p,int s) noexcept Plane uniform scale. plane KLN_VEC_CALL operator* (int s,plane p) noexcept Plane uniform scale. plane KLN_VEC_CALL operator/ (plane p,float s) noexcept Plane uniform inverse scale. plane KLN_VEC_CALL operator/ (plane p,int s) noexcept Plane uniform inverse scale. plane KLN_VEC_CALL operator- (plane p) noexcept Unary minus (leaves displacement from origin untouched, changing orientation only)","title":"Plane"},{"location":"api/plane/#group__plane","text":"In projective geometry, planes are the fundamental element through which all other entities are constructed. Lines are the meet of two planes, and points are the meet of three planes (equivalently, a line and a plane). The plane multivector in PGA looks like \\(d\\mathbf{e}_0 + a\\mathbf{e}_1 + b\\mathbf{e}_2 + c\\mathbf{e}_3\\) . Points that reside on the plane satisfy the familiar equation \\(d + ax + by + cz = 0\\) .","title":"group plane"},{"location":"api/plane/#summary","text":"Members Descriptions public plane () = default public plane (__m128 xmm) noexcept public plane (float a,float b,float c,float d) noexcept The constructor performs the rearrangement so the plane can be specified in the familiar form: ax + by + cz + d public explicit plane (float * data) noexcept Data should point to four floats with memory layout (d, a, b, c) where d occupies the lowest address in memory. public void load (float * data) noexcept Unaligned load of data. The data argument should point to 4 floats corresponding to the (d, a, b, c) components of the plane multivector where d occupies the lowest address in memory. public void normalize () noexcept Normalize this plane \\(p\\) such that \\(p \\cdot p = 1\\) . public plane normalized () const noexcept Return a normalized copy of this plane. public float norm () const noexcept Compute the plane norm, which is often used to compute distances between points and lines. public void invert () noexcept public plane inverse () const noexcept public bool KLN_VEC_CALL operator== (plane other) const noexcept public bool KLN_VEC_CALL approx_eq (plane other,float epsilon) const noexcept public plane KLN_VEC_CALL operator() (plane const & p) const noexcept Reflect another plane \\(p_2\\) through this plane \\(p_1\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p_1 p_2 p_1\\) . public line KLN_VEC_CALL operator() (line const & l) const noexcept Reflect line \\(\\ell\\) through this plane \\(p\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p \\ell p\\) . public point KLN_VEC_CALL operator() (point const & p) const noexcept Reflect the point \\(P\\) through this plane \\(p\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p P p\\) . public plane &KLN_VEC_CALL operator+= (plane b) noexcept Plane addition. public plane &KLN_VEC_CALL operator-= (plane b) noexcept Plane subtraction. public plane & operator*= (float s) noexcept Plane uniform scale. public plane & operator*= (int s) noexcept Plane uniform scale. public plane & operator/= (float s) noexcept Plane uniform inverse scale. public plane & operator/= (int s) noexcept Plane uniform inverse scale. public float x () const noexcept public float e1 () const noexcept public float y () const noexcept public float e2 () const noexcept public float z () const noexcept public float e3 () const noexcept public float d () const noexcept public float e0 () const noexcept public plane KLN_VEC_CALL operator+ (plane a,plane b) noexcept Plane addition. public plane KLN_VEC_CALL operator- (plane a,plane b) noexcept Plane subtraction. public plane KLN_VEC_CALL operator* (plane p,float s) noexcept Plane uniform scale. public plane KLN_VEC_CALL operator* (float s,plane p) noexcept Plane uniform scale. public plane KLN_VEC_CALL operator* (plane p,int s) noexcept Plane uniform scale. public plane KLN_VEC_CALL operator* (int s,plane p) noexcept Plane uniform scale. public plane KLN_VEC_CALL operator/ (plane p,float s) noexcept Plane uniform inverse scale. public plane KLN_VEC_CALL operator/ (plane p,int s) noexcept Plane uniform inverse scale. public plane KLN_VEC_CALL operator- (plane p) noexcept Unary minus (leaves displacement from origin untouched, changing orientation only)","title":"Summary"},{"location":"api/plane/#members","text":"","title":"Members"},{"location":"api/plane/#group__plane_1ga06059c2dd2626f53f552d904060e3ff8","text":"","title":"plane() = default"},{"location":"api/plane/#group__plane_1gaf3f1f15a24e94cea2795dc5b978b69f2","text":"","title":"plane(__m128 xmm) noexcept"},{"location":"api/plane/#group__plane_1ga51933d8d8853797034621ce41ad34a8e","text":"The constructor performs the rearrangement so the plane can be specified in the familiar form: ax + by + cz + d","title":"plane(float a,float b,float c,float d) noexcept"},{"location":"api/plane/#group__plane_1ga29dbb1804fa3ec402f901ca8049d60bc","text":"Data should point to four floats with memory layout (d, a, b, c) where d occupies the lowest address in memory.","title":"explicit  plane(float * data) noexcept"},{"location":"api/plane/#group__plane_1ga5a00871dbe19d7658b7e8cda71b326f2","text":"Unaligned load of data. The data argument should point to 4 floats corresponding to the (d, a, b, c) components of the plane multivector where d occupies the lowest address in memory. Tip This is a faster mechanism for setting data compared to setting components one at a time.","title":"void  load(float * data) noexcept"},{"location":"api/plane/#group__plane_1gae5e1e0af05e84799d27d7b8782fe5f22","text":"Normalize this plane \\(p\\) such that \\(p \\cdot p = 1\\) . In order to compute the cosine of the angle between planes via the inner product operator | , the planes must be normalized. Producing a normalized rotor between two planes with the geometric product * also requires that the planes are normalized.","title":"void  normalize() noexcept"},{"location":"api/plane/#group__plane_1ga15ec918ecd05f7e9b21887afa590d405","text":"Return a normalized copy of this plane.","title":"plane  normalized() const noexcept"},{"location":"api/plane/#group__plane_1ga2f86598e6a327c72201e68615bd10384","text":"Compute the plane norm, which is often used to compute distances between points and lines. Given a normalized point \\(P\\) and normalized line \\(\\ell\\) , the plane \\(P\\vee\\ell\\) containing both \\(\\ell\\) and \\(P\\) will have a norm equivalent to the distance between \\(P\\) and \\(\\ell\\) .","title":"float  norm() const noexcept"},{"location":"api/plane/#group__plane_1ga8b2ee34f6cc0fd6992520835b13c10e6","text":"","title":"void  invert() noexcept"},{"location":"api/plane/#group__plane_1gab3e738eb24a1528e69a1a3ebd75c051e","text":"","title":"plane  inverse() const noexcept"},{"location":"api/plane/#group__plane_1ga1163a89d4d307d9f8812cd491d5e80e1","text":"","title":"bool KLN_VEC_CALL  operator==(plane other) const noexcept"},{"location":"api/plane/#group__plane_1ga4fecdce7f0b686851053d5edfe55aed8","text":"","title":"bool KLN_VEC_CALL  approx_eq(plane other,float epsilon) const noexcept"},{"location":"api/plane/#group__plane_1ga1c7a11e35d91c2aee88a4152b1799ca9","text":"Reflect another plane \\(p_2\\) through this plane \\(p_1\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p_1 p_2 p_1\\) .","title":"plane KLN_VEC_CALL  operator()(plane const &amp; p) const noexcept"},{"location":"api/plane/#group__plane_1ga782e4e0b1b93ab5bffb2c972f6d7acfa","text":"Reflect line \\(\\ell\\) through this plane \\(p\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p \\ell p\\) .","title":"line KLN_VEC_CALL  operator()(line const &amp; l) const noexcept"},{"location":"api/plane/#group__plane_1ga20b6577f6d1717e1ec086314d3ebd497","text":"Reflect the point \\(P\\) through this plane \\(p\\) . The operation performed via this call operator is an optimized routine equivalent to the expression \\(p P p\\) .","title":"point KLN_VEC_CALL  operator()(point const &amp; p) const noexcept"},{"location":"api/plane/#group__plane_1gaf80a42a5457dd6f4686501f46e22635c","text":"Plane addition.","title":"plane &amp;KLN_VEC_CALL  operator+=(plane b) noexcept"},{"location":"api/plane/#group__plane_1gac4f9a791dcfa8910218d843522fd5509","text":"Plane subtraction.","title":"plane &amp;KLN_VEC_CALL  operator-=(plane b) noexcept"},{"location":"api/plane/#group__plane_1ga9b9724a8d77be2b8cd68b86c1fde963c","text":"Plane uniform scale.","title":"plane &amp;  operator*=(float s) noexcept"},{"location":"api/plane/#group__plane_1ga65224cbcfae331161073e8d5829d870d","text":"Plane uniform scale.","title":"plane &amp;  operator*=(int s) noexcept"},{"location":"api/plane/#group__plane_1ga2ab699f0afa0a6d33dda86029167b429","text":"Plane uniform inverse scale.","title":"plane &amp;  operator/=(float s) noexcept"},{"location":"api/plane/#group__plane_1gae86c20070f4cea4f66d79265f495dec8","text":"Plane uniform inverse scale.","title":"plane &amp;  operator/=(int s) noexcept"},{"location":"api/plane/#group__plane_1gad2a57bafbd388d4ca9ca98d0074fee0a","text":"","title":"float  x() const noexcept"},{"location":"api/plane/#group__plane_1gaa80c303821219e07892d3cb2a46a548b","text":"","title":"float  e1() const noexcept"},{"location":"api/plane/#group__plane_1gadce64826f47e1a017fba8fefab69c174","text":"","title":"float  y() const noexcept"},{"location":"api/plane/#group__plane_1ga09f8041b7603bcbe9273933f88368f28","text":"","title":"float  e2() const noexcept"},{"location":"api/plane/#group__plane_1ga2a01bee79dfb0c11414dc5a936397987","text":"","title":"float  z() const noexcept"},{"location":"api/plane/#group__plane_1ga82e3a007a85af14bc9c4563f206d4c16","text":"","title":"float  e3() const noexcept"},{"location":"api/plane/#group__plane_1gab3aa088fdf83091809bb7e08ace460bb","text":"","title":"float  d() const noexcept"},{"location":"api/plane/#group__plane_1gadcaf9730f9c22581d196d74b3197769c","text":"","title":"float  e0() const noexcept"},{"location":"api/plane/#group__plane_1ga6d2534f1b282e146cdda7cd36dd4876f","text":"Plane addition.","title":"plane KLN_VEC_CALL  operator+(plane a,plane b) noexcept"},{"location":"api/plane/#group__plane_1ga2afbbeb64867bf4b3d68b56fc71c439a","text":"Plane subtraction.","title":"plane KLN_VEC_CALL  operator-(plane a,plane b) noexcept"},{"location":"api/plane/#group__plane_1ga0909ca0b8d5e499d81880382be07006c","text":"Plane uniform scale.","title":"plane KLN_VEC_CALL  operator*(plane p,float s) noexcept"},{"location":"api/plane/#group__plane_1ga94594aec80d6cda91582a3728a767ca0","text":"Plane uniform scale.","title":"plane KLN_VEC_CALL  operator*(float s,plane p) noexcept"},{"location":"api/plane/#group__plane_1ga13a4925eaf838675c23479343ee7e765","text":"Plane uniform scale.","title":"plane KLN_VEC_CALL  operator*(plane p,int s) noexcept"},{"location":"api/plane/#group__plane_1ga46d2c31f730f0760f0c22c6022bb0a3b","text":"Plane uniform scale.","title":"plane KLN_VEC_CALL  operator*(int s,plane p) noexcept"},{"location":"api/plane/#group__plane_1ga0f591eb9e778135613a1d5c4a3ac5d51","text":"Plane uniform inverse scale.","title":"plane KLN_VEC_CALL  operator/(plane p,float s) noexcept"},{"location":"api/plane/#group__plane_1gafa4b66325f423b360e28b5b5efffa75f","text":"Plane uniform inverse scale.","title":"plane KLN_VEC_CALL  operator/(plane p,int s) noexcept"},{"location":"api/plane/#group__plane_1gae018fc4984db372392abd5305b86a212","text":"Unary minus (leaves displacement from origin untouched, changing orientation only)","title":"plane KLN_VEC_CALL  operator-(plane p) noexcept"},{"location":"api/point/","text":"group point A point is represented as the multivector \\(x\\mathbf{e}_{032} + y\\mathbf{e}_{013} + z\\mathbf{e}_{021} + \\mathbf{e}_{123}\\) . The point has a trivector representation because it is the fixed point of 3 planar reflections (each of which is a grade-1 multivector). In practice, the coordinate mapping can be thought of as an implementation detail. Summary Members Descriptions public point () = default public point (__m128 xmm) noexcept public point (float x,float y,float z) noexcept Component-wise constructor (homogeneous coordinate is automatically initialized to 1) public void load (float * data) noexcept Fast load from a pointer to an array of four floats with layout (w, x, y, z) where w occupies the lowest address in memory. public void normalize () noexcept Normalize this point (division is done via rcpps with an additional Newton-Raphson refinement). public point normalized () const noexcept Return a normalized copy of this point. public void invert () noexcept public point inverse () const noexcept public float x () const noexcept public float e032 () const noexcept public float y () const noexcept public float e013 () const noexcept public float z () const noexcept public float e021 () const noexcept public float w () const noexcept The homogeneous coordinate w is exactly \\(1\\) when normalized. public float e123 () const noexcept public point &KLN_VEC_CALL operator+= (point b) noexcept Point addition. public point &KLN_VEC_CALL operator-= (point b) noexcept Point subtraction. public point & operator*= (float s) noexcept Point uniform scale. public point & operator*= (int s) noexcept Point uniform scale. public point & operator/= (float s) noexcept Point uniform inverse scale. public point & operator/= (int s) noexcept Point uniform inverse scale. public point KLN_VEC_CALL operator+ (point a,point b) noexcept Point addition. public point KLN_VEC_CALL operator- (point a,point b) noexcept Point subtraction. public point KLN_VEC_CALL operator* (point p,float s) noexcept Point uniform scale. public point KLN_VEC_CALL operator* (float s,point p) noexcept Point uniform scale. public point KLN_VEC_CALL operator* (point p,int s) noexcept Point uniform scale. public point KLN_VEC_CALL operator* (int s,point p) noexcept Point uniform scale. public point KLN_VEC_CALL operator/ (point p,float s) noexcept Point uniform inverse scale. public point KLN_VEC_CALL operator/ (point p,int s) noexcept Point uniform inverse scale. public point KLN_VEC_CALL operator- (point p) noexcept Unary minus (leaves homogeneous coordinate untouched) public point KLN_VEC_CALL operator~ (point p) noexcept Reversion operator. public operator point () const noexcept On its own, the origin occupies no memory, but it can be casted as an entity at any point, at which point it is represented as \\(\\mathbf{e}_{123}\\) . Members point () = default point (__m128 xmm) noexcept point (float x,float y,float z) noexcept Component-wise constructor (homogeneous coordinate is automatically initialized to 1) void load (float * data) noexcept Fast load from a pointer to an array of four floats with layout (w, x, y, z) where w occupies the lowest address in memory. Tip This load operation is more efficient that modifying individual components back-to-back. Danger Unlike the component-wise constructor, the load here requires the homogeneous coordinate w to be supplied as well in the lowest address pointed to by data . void normalize () noexcept Normalize this point (division is done via rcpps with an additional Newton-Raphson refinement). point normalized () const noexcept Return a normalized copy of this point. void invert () noexcept point inverse () const noexcept float x () const noexcept float e032 () const noexcept float y () const noexcept float e013 () const noexcept float z () const noexcept float e021 () const noexcept float w () const noexcept The homogeneous coordinate w is exactly \\(1\\) when normalized. float e123 () const noexcept point &KLN_VEC_CALL operator+= (point b) noexcept Point addition. point &KLN_VEC_CALL operator-= (point b) noexcept Point subtraction. point & operator*= (float s) noexcept Point uniform scale. point & operator*= (int s) noexcept Point uniform scale. point & operator/= (float s) noexcept Point uniform inverse scale. point & operator/= (int s) noexcept Point uniform inverse scale. point KLN_VEC_CALL operator+ (point a,point b) noexcept Point addition. point KLN_VEC_CALL operator- (point a,point b) noexcept Point subtraction. point KLN_VEC_CALL operator* (point p,float s) noexcept Point uniform scale. point KLN_VEC_CALL operator* (float s,point p) noexcept Point uniform scale. point KLN_VEC_CALL operator* (point p,int s) noexcept Point uniform scale. point KLN_VEC_CALL operator* (int s,point p) noexcept Point uniform scale. point KLN_VEC_CALL operator/ (point p,float s) noexcept Point uniform inverse scale. point KLN_VEC_CALL operator/ (point p,int s) noexcept Point uniform inverse scale. point KLN_VEC_CALL operator- (point p) noexcept Unary minus (leaves homogeneous coordinate untouched) point KLN_VEC_CALL operator~ (point p) noexcept Reversion operator. operator point () const noexcept On its own, the origin occupies no memory, but it can be casted as an entity at any point, at which point it is represented as \\(\\mathbf{e}_{123}\\) .","title":"Point"},{"location":"api/point/#group__point","text":"A point is represented as the multivector \\(x\\mathbf{e}_{032} + y\\mathbf{e}_{013} + z\\mathbf{e}_{021} + \\mathbf{e}_{123}\\) . The point has a trivector representation because it is the fixed point of 3 planar reflections (each of which is a grade-1 multivector). In practice, the coordinate mapping can be thought of as an implementation detail.","title":"group point"},{"location":"api/point/#summary","text":"Members Descriptions public point () = default public point (__m128 xmm) noexcept public point (float x,float y,float z) noexcept Component-wise constructor (homogeneous coordinate is automatically initialized to 1) public void load (float * data) noexcept Fast load from a pointer to an array of four floats with layout (w, x, y, z) where w occupies the lowest address in memory. public void normalize () noexcept Normalize this point (division is done via rcpps with an additional Newton-Raphson refinement). public point normalized () const noexcept Return a normalized copy of this point. public void invert () noexcept public point inverse () const noexcept public float x () const noexcept public float e032 () const noexcept public float y () const noexcept public float e013 () const noexcept public float z () const noexcept public float e021 () const noexcept public float w () const noexcept The homogeneous coordinate w is exactly \\(1\\) when normalized. public float e123 () const noexcept public point &KLN_VEC_CALL operator+= (point b) noexcept Point addition. public point &KLN_VEC_CALL operator-= (point b) noexcept Point subtraction. public point & operator*= (float s) noexcept Point uniform scale. public point & operator*= (int s) noexcept Point uniform scale. public point & operator/= (float s) noexcept Point uniform inverse scale. public point & operator/= (int s) noexcept Point uniform inverse scale. public point KLN_VEC_CALL operator+ (point a,point b) noexcept Point addition. public point KLN_VEC_CALL operator- (point a,point b) noexcept Point subtraction. public point KLN_VEC_CALL operator* (point p,float s) noexcept Point uniform scale. public point KLN_VEC_CALL operator* (float s,point p) noexcept Point uniform scale. public point KLN_VEC_CALL operator* (point p,int s) noexcept Point uniform scale. public point KLN_VEC_CALL operator* (int s,point p) noexcept Point uniform scale. public point KLN_VEC_CALL operator/ (point p,float s) noexcept Point uniform inverse scale. public point KLN_VEC_CALL operator/ (point p,int s) noexcept Point uniform inverse scale. public point KLN_VEC_CALL operator- (point p) noexcept Unary minus (leaves homogeneous coordinate untouched) public point KLN_VEC_CALL operator~ (point p) noexcept Reversion operator. public operator point () const noexcept On its own, the origin occupies no memory, but it can be casted as an entity at any point, at which point it is represented as \\(\\mathbf{e}_{123}\\) .","title":"Summary"},{"location":"api/point/#members","text":"","title":"Members"},{"location":"api/point/#group__point_1gaf5815698f91b6e3c0d1a4c6ee1584c2e","text":"","title":"point() = default"},{"location":"api/point/#group__point_1gac37d4cefd1d57c3a7686420aee94bc5a","text":"","title":"point(__m128 xmm) noexcept"},{"location":"api/point/#group__point_1gadc78c30fe71a140259dd7add02d36df8","text":"Component-wise constructor (homogeneous coordinate is automatically initialized to 1)","title":"point(float x,float y,float z) noexcept"},{"location":"api/point/#group__point_1ga805739dde6d772f5b228cce5b95ef13f","text":"Fast load from a pointer to an array of four floats with layout (w, x, y, z) where w occupies the lowest address in memory. Tip This load operation is more efficient that modifying individual components back-to-back. Danger Unlike the component-wise constructor, the load here requires the homogeneous coordinate w to be supplied as well in the lowest address pointed to by data .","title":"void  load(float * data) noexcept"},{"location":"api/point/#group__point_1ga3d1ba8e0c47d25c5b5d124d9b5ef8e04","text":"Normalize this point (division is done via rcpps with an additional Newton-Raphson refinement).","title":"void  normalize() noexcept"},{"location":"api/point/#group__point_1ga8f4c5fa5342ffda6c73695b2fbfa0f9b","text":"Return a normalized copy of this point.","title":"point  normalized() const noexcept"},{"location":"api/point/#group__point_1ga6ffcd424ab00bf033d241d55e901b209","text":"","title":"void  invert() noexcept"},{"location":"api/point/#group__point_1ga4abcf2a7bce6975617ada1a3be8bc47d","text":"","title":"point  inverse() const noexcept"},{"location":"api/point/#group__point_1ga0c100888d1b7edc3fdb81f8b7c22feb1","text":"","title":"float  x() const noexcept"},{"location":"api/point/#group__point_1ga1a733ef19316e24dc74867e91c27d126","text":"","title":"float  e032() const noexcept"},{"location":"api/point/#group__point_1gae413703952e1a6e15b401d2620f6ae93","text":"","title":"float  y() const noexcept"},{"location":"api/point/#group__point_1ga22e2cd89dd1cc905fa2836e9a4e3cde8","text":"","title":"float  e013() const noexcept"},{"location":"api/point/#group__point_1gaff266ae56b86d0598a0373ea222c2bee","text":"","title":"float  z() const noexcept"},{"location":"api/point/#group__point_1ga5512ddec0c7a73b1f6509b6cd97f1da4","text":"","title":"float  e021() const noexcept"},{"location":"api/point/#group__point_1gadfa0b3fa1bc85799e2a3916725b573c1","text":"The homogeneous coordinate w is exactly \\(1\\) when normalized.","title":"float  w() const noexcept"},{"location":"api/point/#group__point_1gaf2bb6211c7d2adaea7a128e8d2900bf3","text":"","title":"float  e123() const noexcept"},{"location":"api/point/#group__point_1ga5249e834b0b88dc9db4a95c340c790d7","text":"Point addition.","title":"point &amp;KLN_VEC_CALL  operator+=(point b) noexcept"},{"location":"api/point/#group__point_1gad19d2cb5801f3b5572487e85cda8a084","text":"Point subtraction.","title":"point &amp;KLN_VEC_CALL  operator-=(point b) noexcept"},{"location":"api/point/#group__point_1gac0d5012938591d0c765989fe0b100368","text":"Point uniform scale.","title":"point &amp;  operator*=(float s) noexcept"},{"location":"api/point/#group__point_1ga036f220b5f049ad496fcee0a98477380","text":"Point uniform scale.","title":"point &amp;  operator*=(int s) noexcept"},{"location":"api/point/#group__point_1ga1e02c8e04a37230a9f78c76c4390b199","text":"Point uniform inverse scale.","title":"point &amp;  operator/=(float s) noexcept"},{"location":"api/point/#group__point_1gad37f2b9901bf72e2b8fc4d62ba7f99af","text":"Point uniform inverse scale.","title":"point &amp;  operator/=(int s) noexcept"},{"location":"api/point/#group__point_1ga7c772c35c230f28573611c707ec46243","text":"Point addition.","title":"point KLN_VEC_CALL  operator+(point a,point b) noexcept"},{"location":"api/point/#group__point_1ga893da0547e267d631fe79526f1c3d274","text":"Point subtraction.","title":"point KLN_VEC_CALL  operator-(point a,point b) noexcept"},{"location":"api/point/#group__point_1gadd07ab21ac8bf227aa0b7b56effda3ed","text":"Point uniform scale.","title":"point KLN_VEC_CALL  operator*(point p,float s) noexcept"},{"location":"api/point/#group__point_1ga18b3a2d1e891f46f9a59a5b13ab30797","text":"Point uniform scale.","title":"point KLN_VEC_CALL  operator*(float s,point p) noexcept"},{"location":"api/point/#group__point_1ga1e1b44a57e524d8d6eb2acce6e859f1b","text":"Point uniform scale.","title":"point KLN_VEC_CALL  operator*(point p,int s) noexcept"},{"location":"api/point/#group__point_1ga7033b360b0bc9476403ebe099ba86ea3","text":"Point uniform scale.","title":"point KLN_VEC_CALL  operator*(int s,point p) noexcept"},{"location":"api/point/#group__point_1ga98d52f70be04ecd1936acb684a7dd3a3","text":"Point uniform inverse scale.","title":"point KLN_VEC_CALL  operator/(point p,float s) noexcept"},{"location":"api/point/#group__point_1ga0ecf62635012f01c124f9294b4dd4a2e","text":"Point uniform inverse scale.","title":"point KLN_VEC_CALL  operator/(point p,int s) noexcept"},{"location":"api/point/#group__point_1ga7b18bf2b94b9e7d2e013eb710dbe11ac","text":"Unary minus (leaves homogeneous coordinate untouched)","title":"point KLN_VEC_CALL  operator-(point p) noexcept"},{"location":"api/point/#group__point_1ga5b6009037927bd8a00156237756f7566","text":"Reversion operator.","title":"point KLN_VEC_CALL  operator~(point p) noexcept"},{"location":"api/point/#group__point_1gac078bf1318b763fe44d89abf77d3b3ef","text":"On its own, the origin occupies no memory, but it can be casted as an entity at any point, at which point it is represented as \\(\\mathbf{e}_{123}\\) .","title":"operator point() const noexcept"},{"location":"api/proj/","text":"group proj Projections in Geometric Algebra take on a particularly simple form. For two geometric entities \\(a\\) and \\(b\\) , there are two cases to consider. First, if the grade of \\(a\\) is greater than the grade of \\(b\\) , the projection of \\(a\\) on \\(b\\) is given by: \\[ \\textit{proj}_b a = (a \\cdot b) \\wedge b \\] The inner product can be thought of as the part of \\(b\\) least like \\(a\\) . Using the meet operator on this part produces the part of \\(b\\) most like \\(a\\) . A simple sanity check is to consider the grades of the result. If the grade of \\(b\\) is less than the grade of \\(a\\) , we end up with an entity with grade \\(a - b + b = a\\) as expected. In the second case (the grade of \\(a\\) is less than the grade of \\(b\\) ), the projection of \\(a\\) on \\(b\\) is given by: \\[ \\textit{proj}_b a = (a \\cdot b) \\cdot b \\] It can be verified that as in the first case, the grade of the result is the same as the grade of \\(a\\) . As this projection occurs in the opposite sense from what one may have seen before, additional clarification is provided below. Summary Members Descriptions public point KLN_VEC_CALL project (point a,line b) noexcept Project a point onto a line. public point KLN_VEC_CALL project (point a,plane b) noexcept Project a point onto a plane. public line KLN_VEC_CALL project (line a,plane b) noexcept Project a line onto a plane. public plane KLN_VEC_CALL project (plane a,point b) noexcept Project a plane onto a point. Given a plane \\(p\\) and point \\(P\\) , produces the plane through \\(P\\) that is parallel to \\(p\\) . public line KLN_VEC_CALL project (line a,point b) noexcept Project a line onto a point. Given a line \\(\\ell\\) and point \\(P\\) , produces the line through \\(P\\) that is parallel to \\(\\ell\\) . public plane KLN_VEC_CALL project (plane a,line b) noexcept Project a plane onto a line. Given a plane \\(p\\) and line \\(\\ell\\) , produces the plane through \\(\\ell\\) that is parallel to \\(p\\) if \\(p \\parallel \\ell\\) . Members point KLN_VEC_CALL project (point a,line b) noexcept Project a point onto a line. point KLN_VEC_CALL project (point a,plane b) noexcept Project a point onto a plane. line KLN_VEC_CALL project (line a,plane b) noexcept Project a line onto a plane. plane KLN_VEC_CALL project (plane a,point b) noexcept Project a plane onto a point. Given a plane \\(p\\) and point \\(P\\) , produces the plane through \\(P\\) that is parallel to \\(p\\) . Intuitively, the point is represented dually in terms of a pencil of planes that converge on the point itself. When we compute \\(p | P\\) , this selects the line perpendicular to \\(p\\) through \\(P\\) . Subsequently, taking the inner product with \\(P\\) again selects the plane from the plane pencil of \\(P\\) least like that line. line KLN_VEC_CALL project (line a,point b) noexcept Project a line onto a point. Given a line \\(\\ell\\) and point \\(P\\) , produces the line through \\(P\\) that is parallel to \\(\\ell\\) . plane KLN_VEC_CALL project (plane a,line b) noexcept Project a plane onto a line. Given a plane \\(p\\) and line \\(\\ell\\) , produces the plane through \\(\\ell\\) that is parallel to \\(p\\) if \\(p \\parallel \\ell\\) . If \\(p \\nparallel \\ell\\) , the result will be the plane \\(p'\\) containing \\(\\ell\\) that maximizes \\(p \\cdot p'\\) (that is, \\(p'\\) is as parallel to \\(p\\) as possible).","title":"Projections"},{"location":"api/proj/#group__proj","text":"Projections in Geometric Algebra take on a particularly simple form. For two geometric entities \\(a\\) and \\(b\\) , there are two cases to consider. First, if the grade of \\(a\\) is greater than the grade of \\(b\\) , the projection of \\(a\\) on \\(b\\) is given by: \\[ \\textit{proj}_b a = (a \\cdot b) \\wedge b \\] The inner product can be thought of as the part of \\(b\\) least like \\(a\\) . Using the meet operator on this part produces the part of \\(b\\) most like \\(a\\) . A simple sanity check is to consider the grades of the result. If the grade of \\(b\\) is less than the grade of \\(a\\) , we end up with an entity with grade \\(a - b + b = a\\) as expected. In the second case (the grade of \\(a\\) is less than the grade of \\(b\\) ), the projection of \\(a\\) on \\(b\\) is given by: \\[ \\textit{proj}_b a = (a \\cdot b) \\cdot b \\] It can be verified that as in the first case, the grade of the result is the same as the grade of \\(a\\) . As this projection occurs in the opposite sense from what one may have seen before, additional clarification is provided below.","title":"group proj"},{"location":"api/proj/#summary","text":"Members Descriptions public point KLN_VEC_CALL project (point a,line b) noexcept Project a point onto a line. public point KLN_VEC_CALL project (point a,plane b) noexcept Project a point onto a plane. public line KLN_VEC_CALL project (line a,plane b) noexcept Project a line onto a plane. public plane KLN_VEC_CALL project (plane a,point b) noexcept Project a plane onto a point. Given a plane \\(p\\) and point \\(P\\) , produces the plane through \\(P\\) that is parallel to \\(p\\) . public line KLN_VEC_CALL project (line a,point b) noexcept Project a line onto a point. Given a line \\(\\ell\\) and point \\(P\\) , produces the line through \\(P\\) that is parallel to \\(\\ell\\) . public plane KLN_VEC_CALL project (plane a,line b) noexcept Project a plane onto a line. Given a plane \\(p\\) and line \\(\\ell\\) , produces the plane through \\(\\ell\\) that is parallel to \\(p\\) if \\(p \\parallel \\ell\\) .","title":"Summary"},{"location":"api/proj/#members","text":"","title":"Members"},{"location":"api/proj/#group__proj_1gad3cddd86655de814988bb594b8df5ff7","text":"Project a point onto a line.","title":"point KLN_VEC_CALL  project(point a,line b) noexcept"},{"location":"api/proj/#group__proj_1ga6732017602bbd6cbb4326946720927f2","text":"Project a point onto a plane.","title":"point KLN_VEC_CALL  project(point a,plane b) noexcept"},{"location":"api/proj/#group__proj_1gad0ac38479bfb78b1ef9d0c06cb37a033","text":"Project a line onto a plane.","title":"line KLN_VEC_CALL  project(line a,plane b) noexcept"},{"location":"api/proj/#group__proj_1ga9ba81079e93afed456b56ae7273af189","text":"Project a plane onto a point. Given a plane \\(p\\) and point \\(P\\) , produces the plane through \\(P\\) that is parallel to \\(p\\) . Intuitively, the point is represented dually in terms of a pencil of planes that converge on the point itself. When we compute \\(p | P\\) , this selects the line perpendicular to \\(p\\) through \\(P\\) . Subsequently, taking the inner product with \\(P\\) again selects the plane from the plane pencil of \\(P\\) least like that line.","title":"plane KLN_VEC_CALL  project(plane a,point b) noexcept"},{"location":"api/proj/#group__proj_1ga1d875a5cc0de38ff17c3e4f298a116bd","text":"Project a line onto a point. Given a line \\(\\ell\\) and point \\(P\\) , produces the line through \\(P\\) that is parallel to \\(\\ell\\) .","title":"line KLN_VEC_CALL  project(line a,point b) noexcept"},{"location":"api/proj/#group__proj_1ga29fd7694ba97a90fc9ae4525ab609314","text":"Project a plane onto a line. Given a plane \\(p\\) and line \\(\\ell\\) , produces the plane through \\(\\ell\\) that is parallel to \\(p\\) if \\(p \\parallel \\ell\\) . If \\(p \\nparallel \\ell\\) , the result will be the plane \\(p'\\) containing \\(\\ell\\) that maximizes \\(p \\cdot p'\\) (that is, \\(p'\\) is as parallel to \\(p\\) as possible).","title":"plane KLN_VEC_CALL  project(plane a,line b) noexcept"},{"location":"api/reg/","text":"group reg The regressive product is implemented in terms of the exterior product. Given multivectors \\(\\mathbf{a}\\) and \\(\\mathbf{b}\\) , the regressive product \\(\\mathbf{a}\\vee\\mathbf{b}\\) is equivalent to \\(J(J(\\mathbf{a})\\wedge J(\\mathbf{b}))\\) . Thus, both meets and joins reside in the same algebraic structure. Joining two points kln :: point p1 { x1 , y1 , z1 }; kln :: point p2 { x2 , y2 , z2 }; // l contains both p1 and p2. kln :: line l = p1 & p2 ; Joining a line and a point kln :: point p1 { x , y , z }; kln :: line l2 { mx , my , mz , dx , dy , dz }; // p2 contains both p1 and l2. kln :: plane p2 = p1 & l2 ; Summary Members Descriptions public line KLN_VEC_CALL operator& (point a,point b) noexcept public plane KLN_VEC_CALL operator& (point a,line b) noexcept public plane KLN_VEC_CALL operator& (line b,point a) noexcept public plane KLN_VEC_CALL operator& (point a,branch b) noexcept public plane KLN_VEC_CALL operator& (branch b,point a) noexcept public plane KLN_VEC_CALL operator& (point a,ideal_line b) noexcept public plane KLN_VEC_CALL operator& (ideal_line b,point a) noexcept public dual KLN_VEC_CALL operator& (plane a,point b) noexcept public dual KLN_VEC_CALL operator& (point a,plane b) noexcept Members line KLN_VEC_CALL operator& (point a,point b) noexcept plane KLN_VEC_CALL operator& (point a,line b) noexcept plane KLN_VEC_CALL operator& (line b,point a) noexcept plane KLN_VEC_CALL operator& (point a,branch b) noexcept plane KLN_VEC_CALL operator& (branch b,point a) noexcept plane KLN_VEC_CALL operator& (point a,ideal_line b) noexcept plane KLN_VEC_CALL operator& (ideal_line b,point a) noexcept dual KLN_VEC_CALL operator& (plane a,point b) noexcept dual KLN_VEC_CALL operator& (point a,plane b) noexcept","title":"Regressive Product"},{"location":"api/reg/#group__reg","text":"The regressive product is implemented in terms of the exterior product. Given multivectors \\(\\mathbf{a}\\) and \\(\\mathbf{b}\\) , the regressive product \\(\\mathbf{a}\\vee\\mathbf{b}\\) is equivalent to \\(J(J(\\mathbf{a})\\wedge J(\\mathbf{b}))\\) . Thus, both meets and joins reside in the same algebraic structure. Joining two points kln :: point p1 { x1 , y1 , z1 }; kln :: point p2 { x2 , y2 , z2 }; // l contains both p1 and p2. kln :: line l = p1 & p2 ; Joining a line and a point kln :: point p1 { x , y , z }; kln :: line l2 { mx , my , mz , dx , dy , dz }; // p2 contains both p1 and l2. kln :: plane p2 = p1 & l2 ;","title":"group reg"},{"location":"api/reg/#summary","text":"Members Descriptions public line KLN_VEC_CALL operator& (point a,point b) noexcept public plane KLN_VEC_CALL operator& (point a,line b) noexcept public plane KLN_VEC_CALL operator& (line b,point a) noexcept public plane KLN_VEC_CALL operator& (point a,branch b) noexcept public plane KLN_VEC_CALL operator& (branch b,point a) noexcept public plane KLN_VEC_CALL operator& (point a,ideal_line b) noexcept public plane KLN_VEC_CALL operator& (ideal_line b,point a) noexcept public dual KLN_VEC_CALL operator& (plane a,point b) noexcept public dual KLN_VEC_CALL operator& (point a,plane b) noexcept","title":"Summary"},{"location":"api/reg/#members","text":"","title":"Members"},{"location":"api/reg/#group__reg_1ga63b0997f8119571d904e3c02673d8bbb","text":"","title":"line KLN_VEC_CALL  operator&amp;(point a,point b) noexcept"},{"location":"api/reg/#group__reg_1gad37eea7e6c630474cae21c6a6d76dfd1","text":"","title":"plane KLN_VEC_CALL  operator&amp;(point a,line b) noexcept"},{"location":"api/reg/#group__reg_1ga6be92308d719cd634211b5fc0909d00c","text":"","title":"plane KLN_VEC_CALL  operator&amp;(line b,point a) noexcept"},{"location":"api/reg/#group__reg_1ga9f3f5c16881afe59f2c77e2977653094","text":"","title":"plane KLN_VEC_CALL  operator&amp;(point a,branch b) noexcept"},{"location":"api/reg/#group__reg_1ga7b9ddcd88aa6a10b980b69de28aebeb3","text":"","title":"plane KLN_VEC_CALL  operator&amp;(branch b,point a) noexcept"},{"location":"api/reg/#group__reg_1ga05885edf19c3ef66e942390073922bd0","text":"","title":"plane KLN_VEC_CALL  operator&amp;(point a,ideal_line b) noexcept"},{"location":"api/reg/#group__reg_1ga2da1a859d4b8c745a77855eabc380980","text":"","title":"plane KLN_VEC_CALL  operator&amp;(ideal_line b,point a) noexcept"},{"location":"api/reg/#group__reg_1gaff23302987cbc2a0a33bae1420992e01","text":"","title":"dual KLN_VEC_CALL  operator&amp;(plane a,point b) noexcept"},{"location":"api/reg/#group__reg_1ga66d87e84a1c2618381cb696800164ecc","text":"","title":"dual KLN_VEC_CALL  operator&amp;(point a,plane b) noexcept"},{"location":"api/rotor/","text":"group rotor The rotor is an entity that represents a rigid rotation about an axis. To apply the rotor to a supported entity, the call operator is available. Example // Initialize a point at (1, 3, 2) kln :: point p { 1.f , 3.f , 2.f }; // Create a normalized rotor representing a pi/2 radian // rotation about the xz-axis. kln :: rotor r { M_PI * 0.5f , 1.f , 0.f , 1.f }; // Rotate our point using the created rotor kln :: point rotated = r ( p ); We can rotate lines and planes as well using the rotor's call operator. Rotors can be multiplied to one another with the * operator to create a new rotor equivalent to the application of each factor. Example // Create a normalized rotor representing a $\\frac{\\pi}{2}$ radian // rotation about the xz-axis. kln :: rotor r1 { M_PI * 0.5f , 1.f , 0.f , 1.f }; // Create a second rotor representing a $\\frac{\\pi}{3}$ radian // rotation about the yz-axis. kln :: rotor r2 { M_PI / 3.f , 0.f , 1.f , 1.f }; // Use the geometric product to create a rotor equivalent to first // applying r1, then applying r2. Note that the order of the // operands here is significant. kln :: rotor r3 = r2 * r1 ; The same * operator can be used to compose the rotor's action with other translators and motors. Summary Members Descriptions public rotor () = default public rotor (float ang_rad,float x,float y,float z) noexcept Convenience constructor. Computes transcendentals and normalizes rotation axis. public rotor (__m128 p1) noexcept public void load_normalized (float * data) noexcept Fast load operation for packed data that is already normalized. The argument data should point to a set of 4 float values with layout (a, b, c, d) corresponding to the multivector \\(a + b\\mathbf{e}_{23} + c\\mathbf{e}_{31} + d\\mathbf{e}_{12}\\) . public void normalize () noexcept Normalize a rotor such that \\(\\mathbf{r}\\widetilde{\\mathbf{r}} = 1\\) . public rotor normalized () const noexcept Return a normalized copy of this rotor. public void invert () noexcept public rotor inverse () const noexcept public void constrain () noexcept Constrains the rotor to traverse the shortest arc. public rotor constrained () const noexcept public bool KLN_VEC_CALL operator== (rotor other) const noexcept public bool KLN_VEC_CALL approx_eq (rotor other,float epsilon) const noexcept public mat3x4 as_mat3x4 () const noexcept Converts the rotor to a 3x4 column-major matrix. The results of this conversion are only defined if the rotor is normalized, and this conversion is preferable if so. public mat4x4 as_mat4x4 () const noexcept Converts the rotor to a 4x4 column-major matrix. public plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this rotor and returns the result \\(rp\\widetilde{r}\\) . public void KLN_VEC_CALL operator() (plane * in,plane * out,size_t count) const noexcept Conjugates an array of planes with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public branch KLN_VEC_CALL operator() (branch const & b) const noexcept public line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this rotor and returns the result \\(r\\ell \\widetilde{r}\\) . public void KLN_VEC_CALL operator() (line * in,line * out,size_t count) const noexcept Conjugates an array of lines with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). public point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this rotor and returns the result \\(rp\\widetilde{r}\\) . public void KLN_VEC_CALL operator() (point * in,point * out,size_t count) const noexcept Conjugates an array of points with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). public direction KLN_VEC_CALL operator() (direction const & d) const noexcept Conjugates a direction \\(d\\) with this rotor and returns the result \\(rd\\widetilde{r}\\) . public void KLN_VEC_CALL operator() (direction * in,direction * out,size_t count) const noexcept Conjugates an array of directions with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). public rotor &KLN_VEC_CALL operator+= (rotor b) noexcept Rotor addition. public rotor &KLN_VEC_CALL operator-= (rotor b) noexcept Rotor subtraction. public rotor & operator*= (float s) noexcept Rotor uniform scale. public rotor & operator*= (int s) noexcept Rotor uniform scale. public rotor & operator/= (float s) noexcept Rotor uniform inverse scale. public rotor & operator/= (int s) noexcept Rotor uniform inverse scale. public float scalar () const noexcept public float e12 () const noexcept public float e21 () const noexcept public float e31 () const noexcept public float e13 () const noexcept public float e23 () const noexcept public float e32 () const noexcept public rotor KLN_VEC_CALL operator+ (rotor a,rotor b) noexcept Rotor addition. public rotor KLN_VEC_CALL operator- (rotor a,rotor b) noexcept Rotor subtraction. public rotor KLN_VEC_CALL operator* (rotor r,float s) noexcept Rotor uniform scale. public rotor KLN_VEC_CALL operator* (rotor r,int s) noexcept Rotor uniform scale. public rotor KLN_VEC_CALL operator* (float s,rotor r) noexcept Rotor uniform scale. public rotor KLN_VEC_CALL operator* (int s,rotor r) noexcept Rotor uniform scale. public rotor KLN_VEC_CALL operator/ (rotor r,float s) noexcept Rotor uniform inverse scale. public rotor KLN_VEC_CALL operator/ (rotor r,int s) noexcept Rotor uniform inverse scale. public rotor KLN_VEC_CALL operator~ (rotor r) noexcept Reversion operator. public rotor KLN_VEC_CALL operator- (rotor r) noexcept Unary minus. Members rotor () = default rotor (float ang_rad,float x,float y,float z) noexcept Convenience constructor. Computes transcendentals and normalizes rotation axis. rotor (__m128 p1) noexcept void load_normalized (float * data) noexcept Fast load operation for packed data that is already normalized. The argument data should point to a set of 4 float values with layout (a, b, c, d) corresponding to the multivector \\(a + b\\mathbf{e}_{23} + c\\mathbf{e}_{31} + d\\mathbf{e}_{12}\\) . Danger The rotor data loaded this way must be normalized. That is, the rotor \\(r\\) must satisfy \\(r\\widetilde{r} = 1\\) . void normalize () noexcept Normalize a rotor such that \\(\\mathbf{r}\\widetilde{\\mathbf{r}} = 1\\) . rotor normalized () const noexcept Return a normalized copy of this rotor. void invert () noexcept rotor inverse () const noexcept void constrain () noexcept Constrains the rotor to traverse the shortest arc. rotor constrained () const noexcept bool KLN_VEC_CALL operator== (rotor other) const noexcept bool KLN_VEC_CALL approx_eq (rotor other,float epsilon) const noexcept mat3x4 as_mat3x4 () const noexcept Converts the rotor to a 3x4 column-major matrix. The results of this conversion are only defined if the rotor is normalized, and this conversion is preferable if so. mat4x4 as_mat4x4 () const noexcept Converts the rotor to a 4x4 column-major matrix. plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this rotor and returns the result \\(rp\\widetilde{r}\\) . void KLN_VEC_CALL operator() (plane * in,plane * out,size_t count) const noexcept Conjugates an array of planes with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). Tip When applying a rotor to a list of tightly packed planes, this routine will be significantly faster than applying the rotor to each plane individually. branch KLN_VEC_CALL operator() (branch const & b) const noexcept line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this rotor and returns the result \\(r\\ell \\widetilde{r}\\) . void KLN_VEC_CALL operator() (line * in,line * out,size_t count) const noexcept Conjugates an array of lines with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). Tip When applying a rotor to a list of tightly packed lines, this routine will be significantly faster than applying the rotor to each line individually. point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this rotor and returns the result \\(rp\\widetilde{r}\\) . void KLN_VEC_CALL operator() (point * in,point * out,size_t count) const noexcept Conjugates an array of points with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). Tip When applying a rotor to a list of tightly packed points, this routine will be significantly faster than applying the rotor to each point individually. direction KLN_VEC_CALL operator() (direction const & d) const noexcept Conjugates a direction \\(d\\) with this rotor and returns the result \\(rd\\widetilde{r}\\) . void KLN_VEC_CALL operator() (direction * in,direction * out,size_t count) const noexcept Conjugates an array of directions with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). Tip When applying a rotor to a list of tightly packed directions, this routine will be significantly faster than applying the rotor to each direction individually. rotor &KLN_VEC_CALL operator+= (rotor b) noexcept Rotor addition. rotor &KLN_VEC_CALL operator-= (rotor b) noexcept Rotor subtraction. rotor & operator*= (float s) noexcept Rotor uniform scale. rotor & operator*= (int s) noexcept Rotor uniform scale. rotor & operator/= (float s) noexcept Rotor uniform inverse scale. rotor & operator/= (int s) noexcept Rotor uniform inverse scale. float scalar () const noexcept float e12 () const noexcept float e21 () const noexcept float e31 () const noexcept float e13 () const noexcept float e23 () const noexcept float e32 () const noexcept rotor KLN_VEC_CALL operator+ (rotor a,rotor b) noexcept Rotor addition. rotor KLN_VEC_CALL operator- (rotor a,rotor b) noexcept Rotor subtraction. rotor KLN_VEC_CALL operator* (rotor r,float s) noexcept Rotor uniform scale. rotor KLN_VEC_CALL operator* (rotor r,int s) noexcept Rotor uniform scale. rotor KLN_VEC_CALL operator* (float s,rotor r) noexcept Rotor uniform scale. rotor KLN_VEC_CALL operator* (int s,rotor r) noexcept Rotor uniform scale. rotor KLN_VEC_CALL operator/ (rotor r,float s) noexcept Rotor uniform inverse scale. rotor KLN_VEC_CALL operator/ (rotor r,int s) noexcept Rotor uniform inverse scale. rotor KLN_VEC_CALL operator~ (rotor r) noexcept Reversion operator. rotor KLN_VEC_CALL operator- (rotor r) noexcept Unary minus.","title":"Rotor"},{"location":"api/rotor/#group__rotor","text":"The rotor is an entity that represents a rigid rotation about an axis. To apply the rotor to a supported entity, the call operator is available. Example // Initialize a point at (1, 3, 2) kln :: point p { 1.f , 3.f , 2.f }; // Create a normalized rotor representing a pi/2 radian // rotation about the xz-axis. kln :: rotor r { M_PI * 0.5f , 1.f , 0.f , 1.f }; // Rotate our point using the created rotor kln :: point rotated = r ( p ); We can rotate lines and planes as well using the rotor's call operator. Rotors can be multiplied to one another with the * operator to create a new rotor equivalent to the application of each factor. Example // Create a normalized rotor representing a $\\frac{\\pi}{2}$ radian // rotation about the xz-axis. kln :: rotor r1 { M_PI * 0.5f , 1.f , 0.f , 1.f }; // Create a second rotor representing a $\\frac{\\pi}{3}$ radian // rotation about the yz-axis. kln :: rotor r2 { M_PI / 3.f , 0.f , 1.f , 1.f }; // Use the geometric product to create a rotor equivalent to first // applying r1, then applying r2. Note that the order of the // operands here is significant. kln :: rotor r3 = r2 * r1 ; The same * operator can be used to compose the rotor's action with other translators and motors.","title":"group rotor"},{"location":"api/rotor/#summary","text":"Members Descriptions public rotor () = default public rotor (float ang_rad,float x,float y,float z) noexcept Convenience constructor. Computes transcendentals and normalizes rotation axis. public rotor (__m128 p1) noexcept public void load_normalized (float * data) noexcept Fast load operation for packed data that is already normalized. The argument data should point to a set of 4 float values with layout (a, b, c, d) corresponding to the multivector \\(a + b\\mathbf{e}_{23} + c\\mathbf{e}_{31} + d\\mathbf{e}_{12}\\) . public void normalize () noexcept Normalize a rotor such that \\(\\mathbf{r}\\widetilde{\\mathbf{r}} = 1\\) . public rotor normalized () const noexcept Return a normalized copy of this rotor. public void invert () noexcept public rotor inverse () const noexcept public void constrain () noexcept Constrains the rotor to traverse the shortest arc. public rotor constrained () const noexcept public bool KLN_VEC_CALL operator== (rotor other) const noexcept public bool KLN_VEC_CALL approx_eq (rotor other,float epsilon) const noexcept public mat3x4 as_mat3x4 () const noexcept Converts the rotor to a 3x4 column-major matrix. The results of this conversion are only defined if the rotor is normalized, and this conversion is preferable if so. public mat4x4 as_mat4x4 () const noexcept Converts the rotor to a 4x4 column-major matrix. public plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this rotor and returns the result \\(rp\\widetilde{r}\\) . public void KLN_VEC_CALL operator() (plane * in,plane * out,size_t count) const noexcept Conjugates an array of planes with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). public branch KLN_VEC_CALL operator() (branch const & b) const noexcept public line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this rotor and returns the result \\(r\\ell \\widetilde{r}\\) . public void KLN_VEC_CALL operator() (line * in,line * out,size_t count) const noexcept Conjugates an array of lines with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). public point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this rotor and returns the result \\(rp\\widetilde{r}\\) . public void KLN_VEC_CALL operator() (point * in,point * out,size_t count) const noexcept Conjugates an array of points with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). public direction KLN_VEC_CALL operator() (direction const & d) const noexcept Conjugates a direction \\(d\\) with this rotor and returns the result \\(rd\\widetilde{r}\\) . public void KLN_VEC_CALL operator() (direction * in,direction * out,size_t count) const noexcept Conjugates an array of directions with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). public rotor &KLN_VEC_CALL operator+= (rotor b) noexcept Rotor addition. public rotor &KLN_VEC_CALL operator-= (rotor b) noexcept Rotor subtraction. public rotor & operator*= (float s) noexcept Rotor uniform scale. public rotor & operator*= (int s) noexcept Rotor uniform scale. public rotor & operator/= (float s) noexcept Rotor uniform inverse scale. public rotor & operator/= (int s) noexcept Rotor uniform inverse scale. public float scalar () const noexcept public float e12 () const noexcept public float e21 () const noexcept public float e31 () const noexcept public float e13 () const noexcept public float e23 () const noexcept public float e32 () const noexcept public rotor KLN_VEC_CALL operator+ (rotor a,rotor b) noexcept Rotor addition. public rotor KLN_VEC_CALL operator- (rotor a,rotor b) noexcept Rotor subtraction. public rotor KLN_VEC_CALL operator* (rotor r,float s) noexcept Rotor uniform scale. public rotor KLN_VEC_CALL operator* (rotor r,int s) noexcept Rotor uniform scale. public rotor KLN_VEC_CALL operator* (float s,rotor r) noexcept Rotor uniform scale. public rotor KLN_VEC_CALL operator* (int s,rotor r) noexcept Rotor uniform scale. public rotor KLN_VEC_CALL operator/ (rotor r,float s) noexcept Rotor uniform inverse scale. public rotor KLN_VEC_CALL operator/ (rotor r,int s) noexcept Rotor uniform inverse scale. public rotor KLN_VEC_CALL operator~ (rotor r) noexcept Reversion operator. public rotor KLN_VEC_CALL operator- (rotor r) noexcept Unary minus.","title":"Summary"},{"location":"api/rotor/#members","text":"","title":"Members"},{"location":"api/rotor/#group__rotor_1gac31c726af9caf7e1de31bf02d9c9d8a5","text":"","title":"rotor() = default"},{"location":"api/rotor/#group__rotor_1gabd1532e0cd7e2c3cd88812cdccdd7dd4","text":"Convenience constructor. Computes transcendentals and normalizes rotation axis.","title":"rotor(float ang_rad,float x,float y,float z) noexcept"},{"location":"api/rotor/#group__rotor_1gaa01cee77a321c13eb1260afbbfd1dbe2","text":"","title":"rotor(__m128 p1) noexcept"},{"location":"api/rotor/#group__rotor_1gab063d72ca484de581a78ebd7b49e41da","text":"Fast load operation for packed data that is already normalized. The argument data should point to a set of 4 float values with layout (a, b, c, d) corresponding to the multivector \\(a + b\\mathbf{e}_{23} + c\\mathbf{e}_{31} + d\\mathbf{e}_{12}\\) . Danger The rotor data loaded this way must be normalized. That is, the rotor \\(r\\) must satisfy \\(r\\widetilde{r} = 1\\) .","title":"void  load_normalized(float * data) noexcept"},{"location":"api/rotor/#group__rotor_1ga4c9b04d0a4119e7d6b56b9e1478db5d4","text":"Normalize a rotor such that \\(\\mathbf{r}\\widetilde{\\mathbf{r}} = 1\\) .","title":"void  normalize() noexcept"},{"location":"api/rotor/#group__rotor_1ga26bfef944e4ae6879de054390d297bc7","text":"Return a normalized copy of this rotor.","title":"rotor  normalized() const noexcept"},{"location":"api/rotor/#group__rotor_1ga9203cbd66f7cc6f61e545e02657868d8","text":"","title":"void  invert() noexcept"},{"location":"api/rotor/#group__rotor_1gaaac6e3fe391fc452089f8742427f011a","text":"","title":"rotor  inverse() const noexcept"},{"location":"api/rotor/#group__rotor_1gad54377a528107dc4dea11e2235c7bcb4","text":"Constrains the rotor to traverse the shortest arc.","title":"void  constrain() noexcept"},{"location":"api/rotor/#group__rotor_1ga16106f423e64a1e83eb3e8c565185a4c","text":"","title":"rotor  constrained() const noexcept"},{"location":"api/rotor/#group__rotor_1gacde3f253079c87e7f14af37d1ecbb820","text":"","title":"bool KLN_VEC_CALL  operator==(rotor other) const noexcept"},{"location":"api/rotor/#group__rotor_1gae600982e491885c97654229bc86321a1","text":"","title":"bool KLN_VEC_CALL  approx_eq(rotor other,float epsilon) const noexcept"},{"location":"api/rotor/#group__rotor_1gad0e18686170db4038e5b7c287b3e8e7d","text":"Converts the rotor to a 3x4 column-major matrix. The results of this conversion are only defined if the rotor is normalized, and this conversion is preferable if so.","title":"mat3x4  as_mat3x4() const noexcept"},{"location":"api/rotor/#group__rotor_1ga2484fc74feb9a79cabd474005fd1c0d8","text":"Converts the rotor to a 4x4 column-major matrix.","title":"mat4x4  as_mat4x4() const noexcept"},{"location":"api/rotor/#group__rotor_1gae9e58f02352f5241dd94d22353a5e9ec","text":"Conjugates a plane \\(p\\) with this rotor and returns the result \\(rp\\widetilde{r}\\) .","title":"plane KLN_VEC_CALL  operator()(plane const &amp; p) const noexcept"},{"location":"api/rotor/#group__rotor_1ga491f6f2264c6ecf180664e75fc4a159b","text":"Conjugates an array of planes with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place motor application). Tip When applying a rotor to a list of tightly packed planes, this routine will be significantly faster than applying the rotor to each plane individually.","title":"void KLN_VEC_CALL  operator()(plane * in,plane * out,size_t count) const noexcept"},{"location":"api/rotor/#group__rotor_1ga4fb7861b9656f5cbc44484c1ba66ce74","text":"","title":"branch KLN_VEC_CALL  operator()(branch const &amp; b) const noexcept"},{"location":"api/rotor/#group__rotor_1gac4d044ea5b98ba540fc5da8d75f43ccc","text":"Conjugates a line \\(\\ell\\) with this rotor and returns the result \\(r\\ell \\widetilde{r}\\) .","title":"line KLN_VEC_CALL  operator()(line const &amp; l) const noexcept"},{"location":"api/rotor/#group__rotor_1gaad794881fa0c11fb05486986032a431a","text":"Conjugates an array of lines with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). Tip When applying a rotor to a list of tightly packed lines, this routine will be significantly faster than applying the rotor to each line individually.","title":"void KLN_VEC_CALL  operator()(line * in,line * out,size_t count) const noexcept"},{"location":"api/rotor/#group__rotor_1ga5aabb4caa402fb5793807fe1d8cec199","text":"Conjugates a point \\(p\\) with this rotor and returns the result \\(rp\\widetilde{r}\\) .","title":"point KLN_VEC_CALL  operator()(point const &amp; p) const noexcept"},{"location":"api/rotor/#group__rotor_1gaa91e4024d7368fbd14a93ead29905aad","text":"Conjugates an array of points with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). Tip When applying a rotor to a list of tightly packed points, this routine will be significantly faster than applying the rotor to each point individually.","title":"void KLN_VEC_CALL  operator()(point * in,point * out,size_t count) const noexcept"},{"location":"api/rotor/#group__rotor_1ga80935add9a99987a59879df1aa868b43","text":"Conjugates a direction \\(d\\) with this rotor and returns the result \\(rd\\widetilde{r}\\) .","title":"direction KLN_VEC_CALL  operator()(direction const &amp; d) const noexcept"},{"location":"api/rotor/#group__rotor_1ga185ca5be93f00396e5e0de9a05561999","text":"Conjugates an array of directions with this rotor in the input array and stores the result in the output array. Aliasing is only permitted when in == out (in place rotor application). Tip When applying a rotor to a list of tightly packed directions, this routine will be significantly faster than applying the rotor to each direction individually.","title":"void KLN_VEC_CALL  operator()(direction * in,direction * out,size_t count) const noexcept"},{"location":"api/rotor/#group__rotor_1ga45e39a62243e36e5e355ebd2b568f4e8","text":"Rotor addition.","title":"rotor &amp;KLN_VEC_CALL  operator+=(rotor b) noexcept"},{"location":"api/rotor/#group__rotor_1ga6c3e3d03a77a3e6912a6de71587eec6c","text":"Rotor subtraction.","title":"rotor &amp;KLN_VEC_CALL  operator-=(rotor b) noexcept"},{"location":"api/rotor/#group__rotor_1ga6dee3c43d98062a0d84c89c21f6e2eab","text":"Rotor uniform scale.","title":"rotor &amp;  operator*=(float s) noexcept"},{"location":"api/rotor/#group__rotor_1ga0192dadc8c52d7c8b0935498c79bac3c","text":"Rotor uniform scale.","title":"rotor &amp;  operator*=(int s) noexcept"},{"location":"api/rotor/#group__rotor_1ga471b8aca5f4b10e324d9da1261b96819","text":"Rotor uniform inverse scale.","title":"rotor &amp;  operator/=(float s) noexcept"},{"location":"api/rotor/#group__rotor_1gab9b4f34c5626f8f718d40f4244325627","text":"Rotor uniform inverse scale.","title":"rotor &amp;  operator/=(int s) noexcept"},{"location":"api/rotor/#group__rotor_1gad02dd43ba81281970b6c177897097bcb","text":"","title":"float  scalar() const noexcept"},{"location":"api/rotor/#group__rotor_1gaeca61f73a42e3e4e33c15ef429ecaeb5","text":"","title":"float  e12() const noexcept"},{"location":"api/rotor/#group__rotor_1gaa0b572c94d744b0cfc991fb6b4553e93","text":"","title":"float  e21() const noexcept"},{"location":"api/rotor/#group__rotor_1gac0fd6fb45a971064cbe9b77c8c6f96e6","text":"","title":"float  e31() const noexcept"},{"location":"api/rotor/#group__rotor_1ga54519295ac9dcef24687d0d60d0a4fb7","text":"","title":"float  e13() const noexcept"},{"location":"api/rotor/#group__rotor_1gaa1aee031886928dd7e62e65a2bc4c8c1","text":"","title":"float  e23() const noexcept"},{"location":"api/rotor/#group__rotor_1gac0aa82cab673eefc743c4bd7b9753440","text":"","title":"float  e32() const noexcept"},{"location":"api/rotor/#group__rotor_1gabd46b22dfdc4f00b1ee7d05f1570f071","text":"Rotor addition.","title":"rotor KLN_VEC_CALL  operator+(rotor a,rotor b) noexcept"},{"location":"api/rotor/#group__rotor_1ga1479b477d3a0e2ae643dbfce8b790e46","text":"Rotor subtraction.","title":"rotor KLN_VEC_CALL  operator-(rotor a,rotor b) noexcept"},{"location":"api/rotor/#group__rotor_1ga9a9b601b2fb07e3ad3984e1e92675903","text":"Rotor uniform scale.","title":"rotor KLN_VEC_CALL  operator*(rotor r,float s) noexcept"},{"location":"api/rotor/#group__rotor_1ga142d2a565a37e7646ed13d6461c193ec","text":"Rotor uniform scale.","title":"rotor KLN_VEC_CALL  operator*(rotor r,int s) noexcept"},{"location":"api/rotor/#group__rotor_1gade99d6f57e8b4014485ded5b0d749bfa","text":"Rotor uniform scale.","title":"rotor KLN_VEC_CALL  operator*(float s,rotor r) noexcept"},{"location":"api/rotor/#group__rotor_1ga57de1a4a27ca3515aea0ca8b5b4b69a0","text":"Rotor uniform scale.","title":"rotor KLN_VEC_CALL  operator*(int s,rotor r) noexcept"},{"location":"api/rotor/#group__rotor_1gaacf6f0f789dfae74dae83af785b69232","text":"Rotor uniform inverse scale.","title":"rotor KLN_VEC_CALL  operator/(rotor r,float s) noexcept"},{"location":"api/rotor/#group__rotor_1gaf87b76ceb327655df465f15b7e0dd96b","text":"Rotor uniform inverse scale.","title":"rotor KLN_VEC_CALL  operator/(rotor r,int s) noexcept"},{"location":"api/rotor/#group__rotor_1ga2c4b1d7565d89e7a6f6e6b838f838ed5","text":"Reversion operator.","title":"rotor KLN_VEC_CALL  operator~(rotor r) noexcept"},{"location":"api/rotor/#group__rotor_1ga2da1f112e6633bfefb1a15e5e2bdcd5b","text":"Unary minus.","title":"rotor KLN_VEC_CALL  operator-(rotor r) noexcept"},{"location":"api/translator/","text":"group translator A translator represents a rigid-body displacement along a normalized axis. To apply the translator to a supported entity, the call operator is available. Example // Initialize a point at (1, 3, 2) kln :: point p { 1.f , 3.f , 2.f }; // Create a normalized translator representing a 4-unit // displacement along the xz-axis. kln :: translator r { 4.f , 1.f , 0.f , 1.f }; // Displace our point using the created translator kln :: point translated = r ( p ); We can translate lines and planes as well using the translator's call operator. Translators can be multiplied to one another with the * operator to create a new translator equivalent to the application of each factor. Example // Suppose we have 3 translators t1, t2, and t3 // The translator t created here represents the combined action of // t1, t2, and t3. kln :: translator t = t3 * t2 * t1 ; The same * operator can be used to compose the translator's action with other rotors and motors. Summary Members Descriptions public translator () = default public translator (float delta,float x,float y,float z) noexcept public void load_normalized (float * data) noexcept Fast load operation for packed data that is already normalized. The argument data should point to a set of 4 float values with layout (0.f, a, b, c) corresponding to the multivector \\(a\\mathbf{e}_{01} + b\\mathbf{e}_{02} + c\\mathbf{e}_{03}\\) . public void invert () noexcept public translator inverse () const noexcept public plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this translator and returns the result \\(tp\\widetilde{t}\\) . public line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this translator and returns the result \\(t\\ell\\widetilde{t}\\) . public point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this translator and returns the result \\(tp\\widetilde{t}\\) . public translator &KLN_VEC_CALL operator+= (translator b) noexcept Translator addition. public translator &KLN_VEC_CALL operator-= (translator b) noexcept Translator subtraction. public translator & operator*= (float s) noexcept Translator uniform scale. public translator & operator*= (int s) noexcept Translator uniform scale. public translator & operator/= (float s) noexcept Translator uniform inverse scale. public translator & operator/= (int s) noexcept Translator uniform inverse scale. public constexpr float scalar () const noexcept public float e01 () const noexcept public float e10 () const noexcept public float e02 () const noexcept public float e20 () const noexcept public float e03 () const noexcept public float e30 () const noexcept public translator KLN_VEC_CALL operator+ (translator a,translator b) noexcept Translator addition. public translator KLN_VEC_CALL operator- (translator a,translator b) noexcept Translator subtraction. public translator KLN_VEC_CALL operator* (translator t,float s) noexcept Translator uniform scale. public translator KLN_VEC_CALL operator* (translator t,int s) noexcept Translator uniform scale. public translator KLN_VEC_CALL operator* (float s,translator t) noexcept Translator uniform scale. public translator KLN_VEC_CALL operator* (int s,translator t) noexcept Translator uniform scale. public translator KLN_VEC_CALL operator/ (translator t,float s) noexcept Translator uniform inverse scale. public translator KLN_VEC_CALL operator/ (translator t,int s) noexcept Translator uniform inverse scale. Members translator () = default translator (float delta,float x,float y,float z) noexcept void load_normalized (float * data) noexcept Fast load operation for packed data that is already normalized. The argument data should point to a set of 4 float values with layout (0.f, a, b, c) corresponding to the multivector \\(a\\mathbf{e}_{01} + b\\mathbf{e}_{02} + c\\mathbf{e}_{03}\\) . Danger The translator data loaded this way must be normalized. That is, the quantity \\(-\\sqrt{a^2 + b^2 + c^2}\\) must be half the desired displacement. void invert () noexcept translator inverse () const noexcept plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this translator and returns the result \\(tp\\widetilde{t}\\) . line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this translator and returns the result \\(t\\ell\\widetilde{t}\\) . point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this translator and returns the result \\(tp\\widetilde{t}\\) . translator &KLN_VEC_CALL operator+= (translator b) noexcept Translator addition. translator &KLN_VEC_CALL operator-= (translator b) noexcept Translator subtraction. translator & operator*= (float s) noexcept Translator uniform scale. translator & operator*= (int s) noexcept Translator uniform scale. translator & operator/= (float s) noexcept Translator uniform inverse scale. translator & operator/= (int s) noexcept Translator uniform inverse scale. float scalar () const noexcept float e01 () const noexcept float e10 () const noexcept float e02 () const noexcept float e20 () const noexcept float e03 () const noexcept float e30 () const noexcept translator KLN_VEC_CALL operator+ (translator a,translator b) noexcept Translator addition. translator KLN_VEC_CALL operator- (translator a,translator b) noexcept Translator subtraction. translator KLN_VEC_CALL operator* (translator t,float s) noexcept Translator uniform scale. translator KLN_VEC_CALL operator* (translator t,int s) noexcept Translator uniform scale. translator KLN_VEC_CALL operator* (float s,translator t) noexcept Translator uniform scale. translator KLN_VEC_CALL operator* (int s,translator t) noexcept Translator uniform scale. translator KLN_VEC_CALL operator/ (translator t,float s) noexcept Translator uniform inverse scale. translator KLN_VEC_CALL operator/ (translator t,int s) noexcept Translator uniform inverse scale.","title":"Translator"},{"location":"api/translator/#group__translator","text":"A translator represents a rigid-body displacement along a normalized axis. To apply the translator to a supported entity, the call operator is available. Example // Initialize a point at (1, 3, 2) kln :: point p { 1.f , 3.f , 2.f }; // Create a normalized translator representing a 4-unit // displacement along the xz-axis. kln :: translator r { 4.f , 1.f , 0.f , 1.f }; // Displace our point using the created translator kln :: point translated = r ( p ); We can translate lines and planes as well using the translator's call operator. Translators can be multiplied to one another with the * operator to create a new translator equivalent to the application of each factor. Example // Suppose we have 3 translators t1, t2, and t3 // The translator t created here represents the combined action of // t1, t2, and t3. kln :: translator t = t3 * t2 * t1 ; The same * operator can be used to compose the translator's action with other rotors and motors.","title":"group translator"},{"location":"api/translator/#summary","text":"Members Descriptions public translator () = default public translator (float delta,float x,float y,float z) noexcept public void load_normalized (float * data) noexcept Fast load operation for packed data that is already normalized. The argument data should point to a set of 4 float values with layout (0.f, a, b, c) corresponding to the multivector \\(a\\mathbf{e}_{01} + b\\mathbf{e}_{02} + c\\mathbf{e}_{03}\\) . public void invert () noexcept public translator inverse () const noexcept public plane KLN_VEC_CALL operator() (plane const & p) const noexcept Conjugates a plane \\(p\\) with this translator and returns the result \\(tp\\widetilde{t}\\) . public line KLN_VEC_CALL operator() (line const & l) const noexcept Conjugates a line \\(\\ell\\) with this translator and returns the result \\(t\\ell\\widetilde{t}\\) . public point KLN_VEC_CALL operator() (point const & p) const noexcept Conjugates a point \\(p\\) with this translator and returns the result \\(tp\\widetilde{t}\\) . public translator &KLN_VEC_CALL operator+= (translator b) noexcept Translator addition. public translator &KLN_VEC_CALL operator-= (translator b) noexcept Translator subtraction. public translator & operator*= (float s) noexcept Translator uniform scale. public translator & operator*= (int s) noexcept Translator uniform scale. public translator & operator/= (float s) noexcept Translator uniform inverse scale. public translator & operator/= (int s) noexcept Translator uniform inverse scale. public constexpr float scalar () const noexcept public float e01 () const noexcept public float e10 () const noexcept public float e02 () const noexcept public float e20 () const noexcept public float e03 () const noexcept public float e30 () const noexcept public translator KLN_VEC_CALL operator+ (translator a,translator b) noexcept Translator addition. public translator KLN_VEC_CALL operator- (translator a,translator b) noexcept Translator subtraction. public translator KLN_VEC_CALL operator* (translator t,float s) noexcept Translator uniform scale. public translator KLN_VEC_CALL operator* (translator t,int s) noexcept Translator uniform scale. public translator KLN_VEC_CALL operator* (float s,translator t) noexcept Translator uniform scale. public translator KLN_VEC_CALL operator* (int s,translator t) noexcept Translator uniform scale. public translator KLN_VEC_CALL operator/ (translator t,float s) noexcept Translator uniform inverse scale. public translator KLN_VEC_CALL operator/ (translator t,int s) noexcept Translator uniform inverse scale.","title":"Summary"},{"location":"api/translator/#members","text":"","title":"Members"},{"location":"api/translator/#group__translator_1ga874afec21015e89c7b5f6f2100b5d2e7","text":"","title":"translator() = default"},{"location":"api/translator/#group__translator_1ga0978aecd03c99d9f677ec606ccc2ace7","text":"","title":"translator(float delta,float x,float y,float z) noexcept"},{"location":"api/translator/#group__translator_1gaf41d16e554ed66e640671ca9065971b7","text":"Fast load operation for packed data that is already normalized. The argument data should point to a set of 4 float values with layout (0.f, a, b, c) corresponding to the multivector \\(a\\mathbf{e}_{01} + b\\mathbf{e}_{02} + c\\mathbf{e}_{03}\\) . Danger The translator data loaded this way must be normalized. That is, the quantity \\(-\\sqrt{a^2 + b^2 + c^2}\\) must be half the desired displacement.","title":"void  load_normalized(float * data) noexcept"},{"location":"api/translator/#group__translator_1gaeec4cf70b528e2d42197dd41988a54a5","text":"","title":"void  invert() noexcept"},{"location":"api/translator/#group__translator_1ga73c92c1080705f7ba48db4d3618099f8","text":"","title":"translator  inverse() const noexcept"},{"location":"api/translator/#group__translator_1ga0e313cc6d057b518bbc8b04ad6baec59","text":"Conjugates a plane \\(p\\) with this translator and returns the result \\(tp\\widetilde{t}\\) .","title":"plane KLN_VEC_CALL  operator()(plane const &amp; p) const noexcept"},{"location":"api/translator/#group__translator_1gaa0a9ea85643aa7661d52dd477abd76e7","text":"Conjugates a line \\(\\ell\\) with this translator and returns the result \\(t\\ell\\widetilde{t}\\) .","title":"line KLN_VEC_CALL  operator()(line const &amp; l) const noexcept"},{"location":"api/translator/#group__translator_1ga6d5ee3578eb48f36bf3e21d321899de5","text":"Conjugates a point \\(p\\) with this translator and returns the result \\(tp\\widetilde{t}\\) .","title":"point KLN_VEC_CALL  operator()(point const &amp; p) const noexcept"},{"location":"api/translator/#group__translator_1ga49752f41c5f97f0762539987d642a4d1","text":"Translator addition.","title":"translator &amp;KLN_VEC_CALL  operator+=(translator b) noexcept"},{"location":"api/translator/#group__translator_1gaaca2b5944e513109311d94db6f294602","text":"Translator subtraction.","title":"translator &amp;KLN_VEC_CALL  operator-=(translator b) noexcept"},{"location":"api/translator/#group__translator_1ga85db690441a3e6b08a011fc135c6143d","text":"Translator uniform scale.","title":"translator &amp;  operator*=(float s) noexcept"},{"location":"api/translator/#group__translator_1ga0fb9f7fec0d845c83f3c0562cb11d4bc","text":"Translator uniform scale.","title":"translator &amp;  operator*=(int s) noexcept"},{"location":"api/translator/#group__translator_1gabb5212f116d7a101f1b100a633a47f8a","text":"Translator uniform inverse scale.","title":"translator &amp;  operator/=(float s) noexcept"},{"location":"api/translator/#group__translator_1ga6a9907e06b825ceff92381a60f14570f","text":"Translator uniform inverse scale.","title":"translator &amp;  operator/=(int s) noexcept"},{"location":"api/translator/#group__translator_1gaa533f8460dc4d5dcc3b6b868312d89b2","text":"","title":"float  scalar() const noexcept"},{"location":"api/translator/#group__translator_1ga6c6997510798262d55159ad561e6d802","text":"","title":"float  e01() const noexcept"},{"location":"api/translator/#group__translator_1ga00ad9b79f9f69cfb673181cba78f2b2a","text":"","title":"float  e10() const noexcept"},{"location":"api/translator/#group__translator_1ga1e5679476ac84d9e955eed0acda3f59f","text":"","title":"float  e02() const noexcept"},{"location":"api/translator/#group__translator_1ga9a45e67aa72dd2a2e64018c88c2718c4","text":"","title":"float  e20() const noexcept"},{"location":"api/translator/#group__translator_1ga2cfdf0ad3c3d46577ad1fa35823cb269","text":"","title":"float  e03() const noexcept"},{"location":"api/translator/#group__translator_1ga368c9a79810d0e89dba2c2db60c1b64b","text":"","title":"float  e30() const noexcept"},{"location":"api/translator/#group__translator_1ga4d4537ac246252b4e8e74ac59da4de7a","text":"Translator addition.","title":"translator KLN_VEC_CALL  operator+(translator a,translator b) noexcept"},{"location":"api/translator/#group__translator_1gad9a822eb6bd4121692f793e8daf68ecf","text":"Translator subtraction.","title":"translator KLN_VEC_CALL  operator-(translator a,translator b) noexcept"},{"location":"api/translator/#group__translator_1gac8b7dc64bc66050e4ca2420f5e428afb","text":"Translator uniform scale.","title":"translator KLN_VEC_CALL  operator*(translator t,float s) noexcept"},{"location":"api/translator/#group__translator_1gaa866552f47bd7da0babfab1773b15ef9","text":"Translator uniform scale.","title":"translator KLN_VEC_CALL  operator*(translator t,int s) noexcept"},{"location":"api/translator/#group__translator_1ga624432a0049e9dde5e0212a8cea3947a","text":"Translator uniform scale.","title":"translator KLN_VEC_CALL  operator*(float s,translator t) noexcept"},{"location":"api/translator/#group__translator_1gae9e9a9834017da4ff56a7534f4fbfab2","text":"Translator uniform scale.","title":"translator KLN_VEC_CALL  operator*(int s,translator t) noexcept"},{"location":"api/translator/#group__translator_1ga37b49b10ff0308eb2ace0ddce0dc1f2c","text":"Translator uniform inverse scale.","title":"translator KLN_VEC_CALL  operator/(translator t,float s) noexcept"},{"location":"api/translator/#group__translator_1gacbb55db349bac24159d854b293df81c7","text":"Translator uniform inverse scale.","title":"translator KLN_VEC_CALL  operator/(translator t,int s) noexcept"},{"location":"case_studies/ga_skeletal_animation/","text":"Basic Skeletal Animation with Geometric Algebra Intro One of the most direct applications of Geometric Algebra is to model a hierarchy of kinematic chains, also referred to as a skeleton. Most tutorials and material you'll find in books and online for this subject matter will be expressed in terms of the quaternion and dual-quaternion algebra. So here, let's break down how we might model a skeleton and its animation data with Geometric Algebra with simple code snippets using Klein . Data Modeling First, let's model the data in a joint structure. A joint is an individually controllable set of degrees of freedom in our skeleton (your elbow or shoulder is a good example), and we'll assume for the moment that all joints in our skeleton can rotate the attached bone but not extend it or twist it in place (these are known as \"prismatic\" and \"cylindrical joints\" respectively). struct joint { kln :: motor inv_bind_pose ; uint8_t parent_offset ; uint8_t group_size ; }; Joints! Not Bones! Often in the industry, you may hear people say \"bones\" but this is honestly a misnomer. The transforms applied during animation act on joints, and the bones are just occupying the space between the joints as it were. Typically, when an animator rigs a character, it's done when the character is positioned in what is known as a \"bind pose\" or \"T-pose.\" After all, associating vertices of a skinned mesh with nearby joints isn't very practical if all the joints are collapsed to the origin. As a result, it's common to cache on the joint itself, a means to transform the joint out of the bind pose. In our case, we'll use a motor called the inv_bind_pose . A familiar face rocking the T-pose What are motors again? If you're used to working primarily with matrices, quaternions, and dual quaternions don't be too put off by the terminology. A motor is isomorphic to the dual quaternions but embedded in a \"fuller\" algebra with a richer structure. In practice, anywhere you would have needed a rotation plus a translation, or a dual quaternion, a motor is often a suitable choice. If you have rotation data and translation data from an external data source, you can easily convert it to a motor by constructing a rotor and a translator and taking the product to produce a motor . As we mentioned, joints are part of a skeletal hierarchy, so we need a way to reference the parent joint. The representation I prefer is to store a negative offset to the parent joint, so given a joint j , its parent would be *(&j - parent_offset) . We can easily identify the root bone as having an offset of zero when encoded this way. Another trick used here is to use the additional padding we have left in the structure to store the size of the joint's \"group\" which includes itself and all of its children. A joint that is a leaf of the skeletal hierarchy will have a group_size of 1. The joints themselves reside in a skeleton, so let's just use the simplest arrangement we can think of. struct skeleton { joint * joints ; char const ** joint_names ; uint16_t size ; }; Here, joints are stored on the skeleton as a single allocation with size elements. Its common to refer to joints by name for both debugging and authorship, but since the joint names aren't needed at runtime, we'll store them in a separately allocated array. Now, all we've done is established a nice representation of the skeletal hierarchy, but we haven't done any animation yet! To do this, we're going to need to store a sequence of poses (also known as an animation clip). Each pose will encode a transform for every joint in our skeleton. Then, by interpolating from pose to pose, we'll have our first rudimentary animation system. Here's what our pose structure could be modeled as: struct pose { kln :: motor * joint_poses ; // Array of poses for each joint // NOTE: some engines allow animators to include scale data with each joint // pose, but we'll ignore that for the time being. }; struct clip { pose * poses ; // Array of poses uint16_t size ; // Number of poses in the animation clip uint16_t timestamps ; // Array of timestamps for each skeletal pose uint32_t timestamp_us ; // Conversion from timestamp to microseconds }; Again, we use the kln::motor to model the position of a joint. Typically, the rotation/translation of each joint in a pose is encoded relative to the parent joint . Why? Because the relative encoding allows us to mix and match animations on different parts of the skeleton, or perturb various joint transforms depending on gameplay. For example, suppose we want to allow a character to play its reload animation, while adding an additional twist at the hip as the player turns the camera. This type of emergent pose is much easier to tackle when we can use the joint poses of the reload animation clip directly, and simply apply the additional transform of the hip rotation. Forward Kinematics Now that we have our clip containing an array of pose objects, we can now animate an instance of our skeleton! First, let's do this without any interpolation. At a given pose (keyframe), we start at the root joint, apply its transform to itself, then to all its children, and then we repeat this process for all the other joints. struct skeleton_instance { // All positions here are in world coordinate space kln :: point * joint_positions ; kln :: point world_location ; }; void animate_keyframe ( skeleton const & parent , skeleton_instance & instance , pose const & target ) { // We need to write out the final transforms to the instance of the parent // skeleton. The clip is the set of joint poses we need to apply. // First, initialize the position of every joint to the world location for ( uint16_t i = 0 ; i != parent . size ; ++ i ) { instance . joint_positions [ i ] = instance . world_location ; } // Locomoting the world location of the instance according to the animation // clip is known as \"root motion\" animation and is a relatively common // technique, although it does have some tradeoffs outside the scope of this // tutorial. // For each joint, apply its corresponding joint pose motor to every // position in its group. for ( uint16_t i = 0 ; i != parent . size ; ++ i ) { // To apply the joint pose motor, we use the call operator. Here, we // use the overload that is efficient when applying the same motor to // a set of different positions. target . joint_poses [ i ]( & instances . joint_positions [ i ], // Position input & instances . joint_positions [ i ], // Position output parent . joints [ i ]. group_size ); // Count } } And in just a few lines of code, we have a \"stepping\" version of our animation system. Of course, there's a big problem with what we have so far. To get smooth animations, we'd need more keyframes than is reasonable. Before getting to that though, let's consider why we opted to apply a joint pose motor \\(N\\) times across \\(N\\) joint positions in a single call as opposed to \\(N\\) separate calls. To see why, we'll need to look at the expanded motor conjugation operation \\(mP\\widetilde{m}\\) for some motor \\(m\\) and point \\(P\\) . Conjugation? Often, you may hear the term \"conjugate\" used as a noun. For example, the complex conjugate of \\(a + bi\\mkern1mu\\) is \\(a - bi\\mkern1mu\\) . However, the term is also used frequently to mean a \"sandwich multiplication\" such as \\(pq\\widetilde{p}\\) . Those familiar with quaternions will recognize this as the application of a quaternion \\(q\\) to a point \\(p\\) . Conjugation is used through Geometric Algebra because the fundamental action is reflection through a plane (produced by a conjugation with a vector quantity). Rotations and translations are modeled as two reflections, and so their action manifests itself as a conjugation by a bivector quantity. First, let's give variable names to all the coordinates of a point \\(P\\) : \\[P \\equiv a_0\\ee_{123} + a_1\\ee_{021} + a_2\\ee_{013} + a_3\\ee_{023}\\] and the motor \\(m\\) : \\[ \\begin{aligned} m \\equiv b_0 &+ b_1 \\ee_{12} + b_2 \\ee_{31} + b_3 \\ee_{23} \\\\ &+ c_1 \\ee_{01} + c_2 \\ee_{02} + c_3 \\ee_{03} + c_0 \\ee_{0123} \\end{aligned} \\] Here, we've labeled the coefficients with prefixes \\(b\\) and \\(c\\) to distinguish between elements that contain the degenerate \\(\\ee_0\\) from those that don't. With these definitions, the group action of the motor is performed via conjugation as follows: \\[ \\begin{aligned} mP\\widetilde{m} = &a_0 (b_0^2 + b_1^2 + b_2^2 + b_3^2) \\ee_{123} + \\\\ \\\\ + (2&a_0(b_3 c_2 - b_0 c_3 - b_2 c_1 - b_1 c_0) + \\\\ 2&a_2(b_1 b_2 - b_0 b_3) + \\\\ 2&a_3(b_0 b_2 + b_1 b_3) + \\\\ &a_1(b_0^2 + b_1^2 - b_2^2 - b_3^2)) \\ee_{021} + \\\\ \\\\ + (2&a_0(b_1 c_1 - b_0 c_2 - b_3 c_3 - b_2 c_0) + \\\\ 2&a_3(b_2 b_3 - b_0 b_1) + \\\\ 2&a_1(b_0 b_3 + b_1 b_2) + \\\\ &a_2(b_0^2 + b_2^2 - b_1^2 - b_3^2)) \\ee_{013} + \\\\ \\\\ + (2&a_0(b_2 c_3 - b_0 c_1 - b_1 c_2 - b_3 c_0) + \\\\ 2&a_1(b_1 b_3 - b_0 b_2) + \\\\ 2&a_2(b_0 b_1 + b_2 b_3) + \\\\ &a_3(b_0^2 + b_3^2 - b_1^2 - b_2^2)) \\ee_{032} \\end{aligned} \\] Now, this is admittedly a mouthful, but if you stare at it long enough, some patterns should emerge. First, note that the result could be factorized in such a way that \\(a_0\\) , \\(a_1\\) , \\(a_2\\) , and \\(a_3\\) don't need to participate in the computation until the very end. This is an optimization opportunity! All the arithmetic for the terms involving factors of \\(b\\) and \\(c\\) can be computed once and reused for each point \\(P\\) . Internally, Klein uses a template variable to determine if it should loop over an array of entities when applying the motor and this optimization is done automatically, provided the code is written as above. If the motor is applied to a single entity (as in m(p) ), that will be equivalent to the application of a dual-quaternion, so still not slow by any means, but still, the optimization mentioned above is often too good to pass up. To see the exact SSE code where this is optimization is made, feel free to refer to the Klein code here (search for the function sw312 which means \"sandwich partition 3 with partitions 1 and 2\"). Why did you label the motor coefficients with \\(b\\) s and \\(c\\) s The answer to this is that the \\(c\\) coefficients which were attached to basis elements with an ideal component \\(\\ee_0\\) produce a translational effect. If you look at the expanded motor conjugation above and set \\(c_0 = c_1 = c_2 = c_3 = 0\\) , a number of terms drop out and you'll be left with a purely rotational action. A rotor (aka a quaternion)! In fact, the code internally shares a bunch of code this way and the extraneous code when no translation is desired is optimized out at compile time. OK, now we have code that will apply compute the joint pose positions in a global coordinate space given a specified pose. In practice though, an arbitrary time sample in our animation clip could be requested. In particular, we may need to render a pose between two keyframes. How should we go about doing this? Normalized Interpolation What we need is a mechanism for interpolating between two motors, say, \\(m_1\\) and \\(m_2\\) . There are at least two ways of performing this interpolation, a fast and moderately accurate way, and a slower but truly accurate way. By \"accurate\" here, what we mean is that given a parameter \\(t \\in [0, 1]\\) that maps \\(m\\) to \\(m_1\\) when \\(t = 0\\) and maps \\(m\\) to \\(m_2\\) when \\(t = 1\\) , the speed of a particle moving along the path taken by \\(m\\) is constant. The reason why a simple linear interpolation such as \\(m = m_1 (1 - t) + m_2 t\\) doesn't work is because the norm of \\(m\\) must be \\(1\\) to represent a rigid-body transform. It's easy to prove that the norm of an \\(m\\) produced this way from two normalized motors isn't normalized in general. Let's compute the norm directly: \\[ \\begin{aligned} m &\\equiv m_1 (1 - t) + m_2 t \\\\ \\\\ m\\widetilde{m} &= \\left(m_1 (1 - t) + m_2 t\\right) \\left(\\widetilde{m}_1 (1 - t) + \\widetilde{m}_2 t\\right) \\\\ &= m_1\\widetilde{m}_1 (1-t)^2 + (m_2\\widetilde{m}_1 + m_1\\widetilde{m}_2)t(1-t) + m_2\\widetilde{m}_2t \\\\ &= 1 - t + t^2 + (m_2\\widetilde{m}_1 + m_1\\widetilde{m}_2)t(1-t) \\end{aligned} \\] If \\(t = 0\\) or \\(t = 1\\) , then no interpolation happened at all, and we can see that the expression above works out to \\(1\\) as we'd expect. Otherwise, we can see that the norm of a linearly interpolated motor is \\(1\\) if and only if \\(m_2\\widetilde{m}_1 + m_1\\widetilde{m}_2 = 1\\) which is not true in general. To correct for this, a \"fast and dirty\" approach is to just linearly interpolate anyways, but then normalize the result so that we at least we're guaranteed to end up with a rigid body transform. This is commonly referred to as nlerp , and a function that does this might look like the following: // NOTE: t is expected to be between 0 and 1 kln :: motor nlerp ( kln :: motor const & m1 , kln :: motor const & m2 , float t ) { return (( 1 - t ) * m1 + t * m2 ). normalize (); } Not much to it! The main benefit of something like nlerp is that it is fast and requires no transcendental functions except a single fast Newton-Raphson square root to normalize the result. The Exp and Log Map Math Alert The contents of this section are slightly more math heavy and less programming heavy. It's useful knowledge to know, but if its a bit much and you just want a smooth constant speed interpolation, you can safely skip to the next section where we simply apply the techniques learned here in a provided API. Don't be intimidated though! I, the author, sincerely wish that the material here is presented in a way that can be grasped even if unfamiliar given a little bit of patience. What if we wanted to maintain constant velocity around the curve? We can accomplish this by linearizing the transition motor. Let's step back for a second. Motors are the result of an exponential map, but to see why this might be plausible, let's look at complex numbers first as they are likely more familiar. Recall Euler's formula: \\[ e^{i\\mkern1mu \\theta} = \\cos \\theta + i\\mkern1mu \\sin \\theta \\] The reason this works is because if we Taylor expand the LHS: \\[ e^{i\\mkern1mu \\theta} = 1 + i\\mkern1mu\\theta - \\frac{\\theta^2}{2} - \\frac{i\\mkern1mu \\theta^3}{6} + \\dots = \\left(1 - \\frac{\\theta^2}{2} + \\dots\\right) + i\\mkern1mu\\left(\\theta - \\frac{\\theta^3}{6} + \\dots\\right) \\] we seemingly miraculously end up with a well defined rotation, recognized on the RHS of Euler's formula. The \\(i\\mkern1mu\\) is the key ingredient. Because the square of \\(i\\mkern1mu\\) is \\(-1\\) , repeated multiplication of \\(i\\mkern1mu\\) doesn't grow to infinity. Instead, it \"rotates\" with a well-defined periodicity. Suppose I had two rotations \\(r_1\\) and \\(r_2\\) as below: \\[ \\begin{aligned} r_1 &\\equiv \\cos{\\theta_1} + i\\mkern1mu \\sin{\\theta_1} \\\\ r_2 &\\equiv \\cos{\\theta_2} + i\\mkern1mu \\sin{\\theta_2} \\end{aligned} \\] and suppose I want a rotation that takes me halfway between \\(r_1\\) to \\(r_2\\) . How would we produce such a rotation? The answer is obvious. We simply produce a rotation that's the average of \\(\\theta_2\\) and \\(\\theta_1\\) (assuming that we bisect the shorter arc between them). Then, the desired rotation is simply given as \\[ \\cos{\\frac{\\theta_1 + \\theta_2}{2}} + i\\mkern1mu\\sin{\\frac{\\theta_1 + \\theta_2}{2}} \\] This was easy because of the form I expressed \\(r_1\\) and \\(r_2\\) to you. The angles we needed to blend between was in plain sight! What if the rotation was given as \\(\\alpha + i\\mkern1mu \\beta\\) instead? Well, in this case, we can retrieve the angle by taking the logarithm of the rotation. Let's do this precisely. Suppose now that the rotations are given as follows: \\[ \\begin{aligned} r_1 &\\equiv \\alpha_1 + i\\mkern1mu \\beta_1 \\\\ r_2 &\\equiv \\alpha_2 + i\\mkern1mu \\beta_2 \\end{aligned} \\] and again we are asked to find the rotation \\(r\\) halfway between \\(r_1\\) and \\(r_2\\) . The first thing we can realize is identify a new quantity I'm just going to call \\(r_\\delta\\) . Suppose that \\(r_\\delta\\) represents the rotation halfway between \\(r_1\\) and \\(r_2\\) . That is: \\[ r_\\delta^2 r_1 = r_2 \\] Then, we can multiply both sides by \\(r_1^\\dagger\\) (the complex conjugate of \\(r_1\\) ) to isolate \\(r_\\delta\\) on the LHS. Solving for \\(r_\\delta\\) can proceed as follows: \\[ \\begin{aligned} r_\\delta^2 r_1 &= r_2 \\\\ r_\\delta^2 r_1 r_1^\\dagger &= r_2 r_1^\\dagger \\\\ 2 \\ln\\left|r_\\delta\\right| &= \\ln\\left|r_2 r_1^\\dagger\\right| \\tag{1} \\\\ r_\\delta &= \\exp{\\left(\\frac{1}{2}\\ln\\left|r_2 r_1^\\dagger\\right|\\right)} \\end{aligned} \\] \\[ r_\\delta r_1 = \\exp{\\left(\\frac{1}{2}\\ln\\left|r_2 r_1^\\dagger\\right|\\right)} r_1 \\tag{2} \\] In the last step, we right multiplied by \\(r_1\\) (our starting rotation) since \\(r_\\delta\\) was the halfway rotation between \\(r_1\\) and \\(r_2\\) . Hopefully, taking the natural logarithm of a complex number isn't two scary. After all, we know that \\(r_1\\) and \\(r_2\\) have corresonding angles \\(\\theta_1\\) and \\(\\theta_2\\) (defined as the arctangents of their \\(\\alpha\\) and \\(\\beta\\) components) along with polar forms that make simplifying the RHS above easy. \\[ \\begin{aligned} r_\\delta r_1 &= \\exp{\\left(\\frac{1}{2}\\ln\\left|r_2 r_1^\\dagger\\right|\\right)} r_1 \\\\ &= \\exp{\\left(\\frac{1}{2}\\ln\\left|e^{i\\mkern1mu \\theta_2}\\right|\\ln\\left|e^{-i\\mkern1mu \\theta_1}\\right|\\right)} r_1 \\\\ &= \\exp{\\left(\\frac{i\\mkern1mu (\\theta_2 - \\theta_1)}{2}\\right)} \\exp{(i\\mkern1mu \\theta_1)} \\\\ &= \\cos{\\frac{\\theta_1 + \\theta_2}{2}} + i\\mkern1mu\\sin{\\frac{\\theta_1 + \\theta_2}{2}} \\end{aligned} \\] Different path but same result! Now, this might seem needlessly complicated to achieve what could have been done more easily by reading off the angles, but this is only because converting complex numbers to their polar representations is relatively easy. The angle can be determined by taking the arctangent of the ratio of the imaginary and real component. The most important step to appreciate in the second method we used above, is the part where we divide both sides by \\(2\\) (see the equation marked \\((1)\\) above). The exponent there was our desired subdivision (we wanted to split the arc in two, so the incremental rotation ended up being squared to take us from \\(r_1\\) to \\(r_2\\) ). If we wanted to subdivide the arc into \\(n\\) segments, we would have needed a power of \\(n\\) . By taking the logarithm of both sides, we linearized the rotation so that we could simply divide our arc in the correct number of subdivisions. For a motor in 3D projective geometric algebra, there is a closed-form solution for the logarithm which means we can apply the same trick as above! In fact, we technically also don't yet know how to exponentiate the logarithm of a motor, but Klein provides implementations of both the exp and log functions taking bivectors to motors and vice versa that we can use. The derivation for both is a bit involved to flesh out here, but code demonstrating how this is done can be referred to here (a fuller derivation will be the subject of a future post). Taking the journey above as inspiration, given two motors \\(m_1\\) and \\(m_2\\) , we have a recipe for blending between them smoothly. First, we multiply \\(m_2\\) by \\(\\widetilde{m}_1\\) (the reversion operator is the Geometric Algebra analogue of the complex conjugate). This gives us \\(m_2\\widetilde{m}_1\\) which is the motor that takes \\(m_1\\) to \\(m_2\\) . Next we take the logarithm of \\(m_2\\widetilde{m}_1\\) , divide the logarithm by the number of segments in our interpolation, re-exponentiate, and finally multiply by \\(m_1\\) to produce the interpolated result. If this was difficult to follow, feel free to refer again to the process we went through for complex numbers above. The RHS of equation \\((2)\\) is precisely what we want after substituting \\(r\\) s for \\(m\\) s. Huh? This doesn't look like the slerp I'm familiar with Chances are, you're used to seeing slerp in the following form (credit: wikipedia ): \\[\\frac{[\\sin{(1 - t)\\phi]}}{\\sin\\phi}p_1 + \\frac{\\sin{[t\\phi]}}{\\sin\\phi}p_2\\] The derivation used with exponentials and logarithms is completely equivalent but it might take some staring (or pencil and paper) to work out why that is so. The key lies in realizing that the formula given here uses \\(\\phi\\) which is angle of the arc subtended by the two points of the arc (computed by the inner product \\(p_1 \\cdot p_2\\) ). This angle already captures the information provided by the logarithm and the sine ratios after reconstitute the non-linearized map as opposed to exponentiation. The issue with this formula is that it doesn't generalize well to dual-quaternions or motors because the angle of the subtended arc isn't quite as easy to compute. Spherical Interpolation We can now implement our motor blend function as follows: // Blend between two motors with a parameter t in the range [0, 1] kln :: motor slerp ( kln :: motor const & a , kln :: motor const & b , float t ) { // Starting from a, the motor needed to get to b is b * ~a. // To perform this motion continuously, we can take the principal // branch of the logarithm of b * ~a, and subdivide it before // re-exponentiating it to produce a motor again. // In practice, this should be cached whenever possible. line motor_step = log ( b * ~ a ); // exp(log(m)) = exp(t*log(m) + (1 - t)*log(m)) // = exp(t*(log(m))) * exp((1 - t)*log(m)) motor_step *= t ; // The exponential of the step here can be cached if the blend occurs // with fixed steps toward the final motor. Compose the interpolated // result with the start motor to produce the intermediate blended // motor. return exp ( motor_step ) * a ; } Voil\u00e0. A motor slerp, also known as a \"dual quaternion slerp.\" Now, you may be thinking, isn't this slower? The answer is yes, log and exp both require transcendentals after all. However, the choice between slerp and nlerp isn't necessarily as cut and dry as you may think. First, higher quality interpolation can mean that fewer keyframes are needed to produce the desired result. Second, as is evident in the code snippet above, the logarithm (called motor_step ) can be cached if the motors do not change from frame to frame. This effectively cuts the cost of the slerp in half at the cost of some memory. With this blend function, we can now sample our animation clip at any time. // Given a skeleton, an instance of the skeleton, a clip, and a timestamp, // transform the instance to the correct pose sampled from the clip. void animate_sample ( skeleton const & parent , skeleton_instance & instance , clip const & active_clip , skeleton_instance const & instance , int32_t timestamp_ms , // scratch is a mutable pose with sufficient memory // to hold our interpolated joint poses. pose & scratch ) { pose * previous ; pose * next ; float * t ; // This function isn't provided, but it takes a clip and timestamp // and produces the poses that straddle the requested time and the // interpolation parameter. query_pose_endpoints ( clip , timestamp , & previous , & next , & t ); for ( uint16_t i = 0 ; i != parent . size ; ++ i ) { // This could use slerp or nlerp if we wanted. A possible // implementation of this slerp function was given above. scratch . joint_poses [ i ] = slerp ( previous -> joint_poses [ i ], next -> joint_poses [ i ], * t ); } // Reuse our keyframe forward kinematic routine from above animate_keyframe ( parent , instance , scratch ); } Of course, there are myriad optimizations that should jump out to us from the implementation given here, but as a starting point and considering how few lines of code we used, it's not bad in my opinion! Example optimizations include caching the logarithms from the previous frame, or reworking the code above so that all the temporary interpolated results do not need to reside in memory at once. The code provided here was written thusly in the interest of remaining terse. What about inv_bind_pose ?? We defined this kln::motor on our joint and never used it. \"What gives?\" you might ask. Well, we didn't use it because we didn't need to transform to the joint's local coordinate space. This will be needed for skinning which will be the subject of a future tutorial. I'm impressed you noticed this (if you did)! Conclusion We have developed from the ground up the barebones making of an animation library. To be anything close to resembly a production library, it would need animation blending, vertex skinning/morphing, animation retargeting, and a whole host of other features, but at the very least, it should have been illustrative in the basic underpinnings of modeling kinematic motion with Geometric Algebra and Klein. Of course, there's much more to geometry than rigid motion, so stay tuned for future write-ups on collision detection and a whole host of other topics! Feedback? Questions? Comments? Suggestions on what you'd like to see next? Feel free to drop by our discord and say hi!","title":"Basic Skeletal Animation"},{"location":"case_studies/ga_skeletal_animation/#basic-skeletal-animation-with-geometric-algebra","text":"","title":"Basic Skeletal Animation with Geometric Algebra"},{"location":"case_studies/ga_skeletal_animation/#intro","text":"One of the most direct applications of Geometric Algebra is to model a hierarchy of kinematic chains, also referred to as a skeleton. Most tutorials and material you'll find in books and online for this subject matter will be expressed in terms of the quaternion and dual-quaternion algebra. So here, let's break down how we might model a skeleton and its animation data with Geometric Algebra with simple code snippets using Klein .","title":"Intro"},{"location":"case_studies/ga_skeletal_animation/#data-modeling","text":"First, let's model the data in a joint structure. A joint is an individually controllable set of degrees of freedom in our skeleton (your elbow or shoulder is a good example), and we'll assume for the moment that all joints in our skeleton can rotate the attached bone but not extend it or twist it in place (these are known as \"prismatic\" and \"cylindrical joints\" respectively). struct joint { kln :: motor inv_bind_pose ; uint8_t parent_offset ; uint8_t group_size ; }; Joints! Not Bones! Often in the industry, you may hear people say \"bones\" but this is honestly a misnomer. The transforms applied during animation act on joints, and the bones are just occupying the space between the joints as it were. Typically, when an animator rigs a character, it's done when the character is positioned in what is known as a \"bind pose\" or \"T-pose.\" After all, associating vertices of a skinned mesh with nearby joints isn't very practical if all the joints are collapsed to the origin. As a result, it's common to cache on the joint itself, a means to transform the joint out of the bind pose. In our case, we'll use a motor called the inv_bind_pose . A familiar face rocking the T-pose What are motors again? If you're used to working primarily with matrices, quaternions, and dual quaternions don't be too put off by the terminology. A motor is isomorphic to the dual quaternions but embedded in a \"fuller\" algebra with a richer structure. In practice, anywhere you would have needed a rotation plus a translation, or a dual quaternion, a motor is often a suitable choice. If you have rotation data and translation data from an external data source, you can easily convert it to a motor by constructing a rotor and a translator and taking the product to produce a motor . As we mentioned, joints are part of a skeletal hierarchy, so we need a way to reference the parent joint. The representation I prefer is to store a negative offset to the parent joint, so given a joint j , its parent would be *(&j - parent_offset) . We can easily identify the root bone as having an offset of zero when encoded this way. Another trick used here is to use the additional padding we have left in the structure to store the size of the joint's \"group\" which includes itself and all of its children. A joint that is a leaf of the skeletal hierarchy will have a group_size of 1. The joints themselves reside in a skeleton, so let's just use the simplest arrangement we can think of. struct skeleton { joint * joints ; char const ** joint_names ; uint16_t size ; }; Here, joints are stored on the skeleton as a single allocation with size elements. Its common to refer to joints by name for both debugging and authorship, but since the joint names aren't needed at runtime, we'll store them in a separately allocated array. Now, all we've done is established a nice representation of the skeletal hierarchy, but we haven't done any animation yet! To do this, we're going to need to store a sequence of poses (also known as an animation clip). Each pose will encode a transform for every joint in our skeleton. Then, by interpolating from pose to pose, we'll have our first rudimentary animation system. Here's what our pose structure could be modeled as: struct pose { kln :: motor * joint_poses ; // Array of poses for each joint // NOTE: some engines allow animators to include scale data with each joint // pose, but we'll ignore that for the time being. }; struct clip { pose * poses ; // Array of poses uint16_t size ; // Number of poses in the animation clip uint16_t timestamps ; // Array of timestamps for each skeletal pose uint32_t timestamp_us ; // Conversion from timestamp to microseconds }; Again, we use the kln::motor to model the position of a joint. Typically, the rotation/translation of each joint in a pose is encoded relative to the parent joint . Why? Because the relative encoding allows us to mix and match animations on different parts of the skeleton, or perturb various joint transforms depending on gameplay. For example, suppose we want to allow a character to play its reload animation, while adding an additional twist at the hip as the player turns the camera. This type of emergent pose is much easier to tackle when we can use the joint poses of the reload animation clip directly, and simply apply the additional transform of the hip rotation.","title":"Data Modeling"},{"location":"case_studies/ga_skeletal_animation/#forward-kinematics","text":"Now that we have our clip containing an array of pose objects, we can now animate an instance of our skeleton! First, let's do this without any interpolation. At a given pose (keyframe), we start at the root joint, apply its transform to itself, then to all its children, and then we repeat this process for all the other joints. struct skeleton_instance { // All positions here are in world coordinate space kln :: point * joint_positions ; kln :: point world_location ; }; void animate_keyframe ( skeleton const & parent , skeleton_instance & instance , pose const & target ) { // We need to write out the final transforms to the instance of the parent // skeleton. The clip is the set of joint poses we need to apply. // First, initialize the position of every joint to the world location for ( uint16_t i = 0 ; i != parent . size ; ++ i ) { instance . joint_positions [ i ] = instance . world_location ; } // Locomoting the world location of the instance according to the animation // clip is known as \"root motion\" animation and is a relatively common // technique, although it does have some tradeoffs outside the scope of this // tutorial. // For each joint, apply its corresponding joint pose motor to every // position in its group. for ( uint16_t i = 0 ; i != parent . size ; ++ i ) { // To apply the joint pose motor, we use the call operator. Here, we // use the overload that is efficient when applying the same motor to // a set of different positions. target . joint_poses [ i ]( & instances . joint_positions [ i ], // Position input & instances . joint_positions [ i ], // Position output parent . joints [ i ]. group_size ); // Count } } And in just a few lines of code, we have a \"stepping\" version of our animation system. Of course, there's a big problem with what we have so far. To get smooth animations, we'd need more keyframes than is reasonable. Before getting to that though, let's consider why we opted to apply a joint pose motor \\(N\\) times across \\(N\\) joint positions in a single call as opposed to \\(N\\) separate calls. To see why, we'll need to look at the expanded motor conjugation operation \\(mP\\widetilde{m}\\) for some motor \\(m\\) and point \\(P\\) . Conjugation? Often, you may hear the term \"conjugate\" used as a noun. For example, the complex conjugate of \\(a + bi\\mkern1mu\\) is \\(a - bi\\mkern1mu\\) . However, the term is also used frequently to mean a \"sandwich multiplication\" such as \\(pq\\widetilde{p}\\) . Those familiar with quaternions will recognize this as the application of a quaternion \\(q\\) to a point \\(p\\) . Conjugation is used through Geometric Algebra because the fundamental action is reflection through a plane (produced by a conjugation with a vector quantity). Rotations and translations are modeled as two reflections, and so their action manifests itself as a conjugation by a bivector quantity. First, let's give variable names to all the coordinates of a point \\(P\\) : \\[P \\equiv a_0\\ee_{123} + a_1\\ee_{021} + a_2\\ee_{013} + a_3\\ee_{023}\\] and the motor \\(m\\) : \\[ \\begin{aligned} m \\equiv b_0 &+ b_1 \\ee_{12} + b_2 \\ee_{31} + b_3 \\ee_{23} \\\\ &+ c_1 \\ee_{01} + c_2 \\ee_{02} + c_3 \\ee_{03} + c_0 \\ee_{0123} \\end{aligned} \\] Here, we've labeled the coefficients with prefixes \\(b\\) and \\(c\\) to distinguish between elements that contain the degenerate \\(\\ee_0\\) from those that don't. With these definitions, the group action of the motor is performed via conjugation as follows: \\[ \\begin{aligned} mP\\widetilde{m} = &a_0 (b_0^2 + b_1^2 + b_2^2 + b_3^2) \\ee_{123} + \\\\ \\\\ + (2&a_0(b_3 c_2 - b_0 c_3 - b_2 c_1 - b_1 c_0) + \\\\ 2&a_2(b_1 b_2 - b_0 b_3) + \\\\ 2&a_3(b_0 b_2 + b_1 b_3) + \\\\ &a_1(b_0^2 + b_1^2 - b_2^2 - b_3^2)) \\ee_{021} + \\\\ \\\\ + (2&a_0(b_1 c_1 - b_0 c_2 - b_3 c_3 - b_2 c_0) + \\\\ 2&a_3(b_2 b_3 - b_0 b_1) + \\\\ 2&a_1(b_0 b_3 + b_1 b_2) + \\\\ &a_2(b_0^2 + b_2^2 - b_1^2 - b_3^2)) \\ee_{013} + \\\\ \\\\ + (2&a_0(b_2 c_3 - b_0 c_1 - b_1 c_2 - b_3 c_0) + \\\\ 2&a_1(b_1 b_3 - b_0 b_2) + \\\\ 2&a_2(b_0 b_1 + b_2 b_3) + \\\\ &a_3(b_0^2 + b_3^2 - b_1^2 - b_2^2)) \\ee_{032} \\end{aligned} \\] Now, this is admittedly a mouthful, but if you stare at it long enough, some patterns should emerge. First, note that the result could be factorized in such a way that \\(a_0\\) , \\(a_1\\) , \\(a_2\\) , and \\(a_3\\) don't need to participate in the computation until the very end. This is an optimization opportunity! All the arithmetic for the terms involving factors of \\(b\\) and \\(c\\) can be computed once and reused for each point \\(P\\) . Internally, Klein uses a template variable to determine if it should loop over an array of entities when applying the motor and this optimization is done automatically, provided the code is written as above. If the motor is applied to a single entity (as in m(p) ), that will be equivalent to the application of a dual-quaternion, so still not slow by any means, but still, the optimization mentioned above is often too good to pass up. To see the exact SSE code where this is optimization is made, feel free to refer to the Klein code here (search for the function sw312 which means \"sandwich partition 3 with partitions 1 and 2\"). Why did you label the motor coefficients with \\(b\\) s and \\(c\\) s The answer to this is that the \\(c\\) coefficients which were attached to basis elements with an ideal component \\(\\ee_0\\) produce a translational effect. If you look at the expanded motor conjugation above and set \\(c_0 = c_1 = c_2 = c_3 = 0\\) , a number of terms drop out and you'll be left with a purely rotational action. A rotor (aka a quaternion)! In fact, the code internally shares a bunch of code this way and the extraneous code when no translation is desired is optimized out at compile time. OK, now we have code that will apply compute the joint pose positions in a global coordinate space given a specified pose. In practice though, an arbitrary time sample in our animation clip could be requested. In particular, we may need to render a pose between two keyframes. How should we go about doing this?","title":"Forward Kinematics"},{"location":"case_studies/ga_skeletal_animation/#normalized-interpolation","text":"What we need is a mechanism for interpolating between two motors, say, \\(m_1\\) and \\(m_2\\) . There are at least two ways of performing this interpolation, a fast and moderately accurate way, and a slower but truly accurate way. By \"accurate\" here, what we mean is that given a parameter \\(t \\in [0, 1]\\) that maps \\(m\\) to \\(m_1\\) when \\(t = 0\\) and maps \\(m\\) to \\(m_2\\) when \\(t = 1\\) , the speed of a particle moving along the path taken by \\(m\\) is constant. The reason why a simple linear interpolation such as \\(m = m_1 (1 - t) + m_2 t\\) doesn't work is because the norm of \\(m\\) must be \\(1\\) to represent a rigid-body transform. It's easy to prove that the norm of an \\(m\\) produced this way from two normalized motors isn't normalized in general. Let's compute the norm directly: \\[ \\begin{aligned} m &\\equiv m_1 (1 - t) + m_2 t \\\\ \\\\ m\\widetilde{m} &= \\left(m_1 (1 - t) + m_2 t\\right) \\left(\\widetilde{m}_1 (1 - t) + \\widetilde{m}_2 t\\right) \\\\ &= m_1\\widetilde{m}_1 (1-t)^2 + (m_2\\widetilde{m}_1 + m_1\\widetilde{m}_2)t(1-t) + m_2\\widetilde{m}_2t \\\\ &= 1 - t + t^2 + (m_2\\widetilde{m}_1 + m_1\\widetilde{m}_2)t(1-t) \\end{aligned} \\] If \\(t = 0\\) or \\(t = 1\\) , then no interpolation happened at all, and we can see that the expression above works out to \\(1\\) as we'd expect. Otherwise, we can see that the norm of a linearly interpolated motor is \\(1\\) if and only if \\(m_2\\widetilde{m}_1 + m_1\\widetilde{m}_2 = 1\\) which is not true in general. To correct for this, a \"fast and dirty\" approach is to just linearly interpolate anyways, but then normalize the result so that we at least we're guaranteed to end up with a rigid body transform. This is commonly referred to as nlerp , and a function that does this might look like the following: // NOTE: t is expected to be between 0 and 1 kln :: motor nlerp ( kln :: motor const & m1 , kln :: motor const & m2 , float t ) { return (( 1 - t ) * m1 + t * m2 ). normalize (); } Not much to it! The main benefit of something like nlerp is that it is fast and requires no transcendental functions except a single fast Newton-Raphson square root to normalize the result.","title":"Normalized Interpolation"},{"location":"case_studies/ga_skeletal_animation/#the-exp-and-log-map","text":"Math Alert The contents of this section are slightly more math heavy and less programming heavy. It's useful knowledge to know, but if its a bit much and you just want a smooth constant speed interpolation, you can safely skip to the next section where we simply apply the techniques learned here in a provided API. Don't be intimidated though! I, the author, sincerely wish that the material here is presented in a way that can be grasped even if unfamiliar given a little bit of patience. What if we wanted to maintain constant velocity around the curve? We can accomplish this by linearizing the transition motor. Let's step back for a second. Motors are the result of an exponential map, but to see why this might be plausible, let's look at complex numbers first as they are likely more familiar. Recall Euler's formula: \\[ e^{i\\mkern1mu \\theta} = \\cos \\theta + i\\mkern1mu \\sin \\theta \\] The reason this works is because if we Taylor expand the LHS: \\[ e^{i\\mkern1mu \\theta} = 1 + i\\mkern1mu\\theta - \\frac{\\theta^2}{2} - \\frac{i\\mkern1mu \\theta^3}{6} + \\dots = \\left(1 - \\frac{\\theta^2}{2} + \\dots\\right) + i\\mkern1mu\\left(\\theta - \\frac{\\theta^3}{6} + \\dots\\right) \\] we seemingly miraculously end up with a well defined rotation, recognized on the RHS of Euler's formula. The \\(i\\mkern1mu\\) is the key ingredient. Because the square of \\(i\\mkern1mu\\) is \\(-1\\) , repeated multiplication of \\(i\\mkern1mu\\) doesn't grow to infinity. Instead, it \"rotates\" with a well-defined periodicity. Suppose I had two rotations \\(r_1\\) and \\(r_2\\) as below: \\[ \\begin{aligned} r_1 &\\equiv \\cos{\\theta_1} + i\\mkern1mu \\sin{\\theta_1} \\\\ r_2 &\\equiv \\cos{\\theta_2} + i\\mkern1mu \\sin{\\theta_2} \\end{aligned} \\] and suppose I want a rotation that takes me halfway between \\(r_1\\) to \\(r_2\\) . How would we produce such a rotation? The answer is obvious. We simply produce a rotation that's the average of \\(\\theta_2\\) and \\(\\theta_1\\) (assuming that we bisect the shorter arc between them). Then, the desired rotation is simply given as \\[ \\cos{\\frac{\\theta_1 + \\theta_2}{2}} + i\\mkern1mu\\sin{\\frac{\\theta_1 + \\theta_2}{2}} \\] This was easy because of the form I expressed \\(r_1\\) and \\(r_2\\) to you. The angles we needed to blend between was in plain sight! What if the rotation was given as \\(\\alpha + i\\mkern1mu \\beta\\) instead? Well, in this case, we can retrieve the angle by taking the logarithm of the rotation. Let's do this precisely. Suppose now that the rotations are given as follows: \\[ \\begin{aligned} r_1 &\\equiv \\alpha_1 + i\\mkern1mu \\beta_1 \\\\ r_2 &\\equiv \\alpha_2 + i\\mkern1mu \\beta_2 \\end{aligned} \\] and again we are asked to find the rotation \\(r\\) halfway between \\(r_1\\) and \\(r_2\\) . The first thing we can realize is identify a new quantity I'm just going to call \\(r_\\delta\\) . Suppose that \\(r_\\delta\\) represents the rotation halfway between \\(r_1\\) and \\(r_2\\) . That is: \\[ r_\\delta^2 r_1 = r_2 \\] Then, we can multiply both sides by \\(r_1^\\dagger\\) (the complex conjugate of \\(r_1\\) ) to isolate \\(r_\\delta\\) on the LHS. Solving for \\(r_\\delta\\) can proceed as follows: \\[ \\begin{aligned} r_\\delta^2 r_1 &= r_2 \\\\ r_\\delta^2 r_1 r_1^\\dagger &= r_2 r_1^\\dagger \\\\ 2 \\ln\\left|r_\\delta\\right| &= \\ln\\left|r_2 r_1^\\dagger\\right| \\tag{1} \\\\ r_\\delta &= \\exp{\\left(\\frac{1}{2}\\ln\\left|r_2 r_1^\\dagger\\right|\\right)} \\end{aligned} \\] \\[ r_\\delta r_1 = \\exp{\\left(\\frac{1}{2}\\ln\\left|r_2 r_1^\\dagger\\right|\\right)} r_1 \\tag{2} \\] In the last step, we right multiplied by \\(r_1\\) (our starting rotation) since \\(r_\\delta\\) was the halfway rotation between \\(r_1\\) and \\(r_2\\) . Hopefully, taking the natural logarithm of a complex number isn't two scary. After all, we know that \\(r_1\\) and \\(r_2\\) have corresonding angles \\(\\theta_1\\) and \\(\\theta_2\\) (defined as the arctangents of their \\(\\alpha\\) and \\(\\beta\\) components) along with polar forms that make simplifying the RHS above easy. \\[ \\begin{aligned} r_\\delta r_1 &= \\exp{\\left(\\frac{1}{2}\\ln\\left|r_2 r_1^\\dagger\\right|\\right)} r_1 \\\\ &= \\exp{\\left(\\frac{1}{2}\\ln\\left|e^{i\\mkern1mu \\theta_2}\\right|\\ln\\left|e^{-i\\mkern1mu \\theta_1}\\right|\\right)} r_1 \\\\ &= \\exp{\\left(\\frac{i\\mkern1mu (\\theta_2 - \\theta_1)}{2}\\right)} \\exp{(i\\mkern1mu \\theta_1)} \\\\ &= \\cos{\\frac{\\theta_1 + \\theta_2}{2}} + i\\mkern1mu\\sin{\\frac{\\theta_1 + \\theta_2}{2}} \\end{aligned} \\] Different path but same result! Now, this might seem needlessly complicated to achieve what could have been done more easily by reading off the angles, but this is only because converting complex numbers to their polar representations is relatively easy. The angle can be determined by taking the arctangent of the ratio of the imaginary and real component. The most important step to appreciate in the second method we used above, is the part where we divide both sides by \\(2\\) (see the equation marked \\((1)\\) above). The exponent there was our desired subdivision (we wanted to split the arc in two, so the incremental rotation ended up being squared to take us from \\(r_1\\) to \\(r_2\\) ). If we wanted to subdivide the arc into \\(n\\) segments, we would have needed a power of \\(n\\) . By taking the logarithm of both sides, we linearized the rotation so that we could simply divide our arc in the correct number of subdivisions. For a motor in 3D projective geometric algebra, there is a closed-form solution for the logarithm which means we can apply the same trick as above! In fact, we technically also don't yet know how to exponentiate the logarithm of a motor, but Klein provides implementations of both the exp and log functions taking bivectors to motors and vice versa that we can use. The derivation for both is a bit involved to flesh out here, but code demonstrating how this is done can be referred to here (a fuller derivation will be the subject of a future post). Taking the journey above as inspiration, given two motors \\(m_1\\) and \\(m_2\\) , we have a recipe for blending between them smoothly. First, we multiply \\(m_2\\) by \\(\\widetilde{m}_1\\) (the reversion operator is the Geometric Algebra analogue of the complex conjugate). This gives us \\(m_2\\widetilde{m}_1\\) which is the motor that takes \\(m_1\\) to \\(m_2\\) . Next we take the logarithm of \\(m_2\\widetilde{m}_1\\) , divide the logarithm by the number of segments in our interpolation, re-exponentiate, and finally multiply by \\(m_1\\) to produce the interpolated result. If this was difficult to follow, feel free to refer again to the process we went through for complex numbers above. The RHS of equation \\((2)\\) is precisely what we want after substituting \\(r\\) s for \\(m\\) s. Huh? This doesn't look like the slerp I'm familiar with Chances are, you're used to seeing slerp in the following form (credit: wikipedia ): \\[\\frac{[\\sin{(1 - t)\\phi]}}{\\sin\\phi}p_1 + \\frac{\\sin{[t\\phi]}}{\\sin\\phi}p_2\\] The derivation used with exponentials and logarithms is completely equivalent but it might take some staring (or pencil and paper) to work out why that is so. The key lies in realizing that the formula given here uses \\(\\phi\\) which is angle of the arc subtended by the two points of the arc (computed by the inner product \\(p_1 \\cdot p_2\\) ). This angle already captures the information provided by the logarithm and the sine ratios after reconstitute the non-linearized map as opposed to exponentiation. The issue with this formula is that it doesn't generalize well to dual-quaternions or motors because the angle of the subtended arc isn't quite as easy to compute.","title":"The Exp and Log Map"},{"location":"case_studies/ga_skeletal_animation/#spherical-interpolation","text":"We can now implement our motor blend function as follows: // Blend between two motors with a parameter t in the range [0, 1] kln :: motor slerp ( kln :: motor const & a , kln :: motor const & b , float t ) { // Starting from a, the motor needed to get to b is b * ~a. // To perform this motion continuously, we can take the principal // branch of the logarithm of b * ~a, and subdivide it before // re-exponentiating it to produce a motor again. // In practice, this should be cached whenever possible. line motor_step = log ( b * ~ a ); // exp(log(m)) = exp(t*log(m) + (1 - t)*log(m)) // = exp(t*(log(m))) * exp((1 - t)*log(m)) motor_step *= t ; // The exponential of the step here can be cached if the blend occurs // with fixed steps toward the final motor. Compose the interpolated // result with the start motor to produce the intermediate blended // motor. return exp ( motor_step ) * a ; } Voil\u00e0. A motor slerp, also known as a \"dual quaternion slerp.\" Now, you may be thinking, isn't this slower? The answer is yes, log and exp both require transcendentals after all. However, the choice between slerp and nlerp isn't necessarily as cut and dry as you may think. First, higher quality interpolation can mean that fewer keyframes are needed to produce the desired result. Second, as is evident in the code snippet above, the logarithm (called motor_step ) can be cached if the motors do not change from frame to frame. This effectively cuts the cost of the slerp in half at the cost of some memory. With this blend function, we can now sample our animation clip at any time. // Given a skeleton, an instance of the skeleton, a clip, and a timestamp, // transform the instance to the correct pose sampled from the clip. void animate_sample ( skeleton const & parent , skeleton_instance & instance , clip const & active_clip , skeleton_instance const & instance , int32_t timestamp_ms , // scratch is a mutable pose with sufficient memory // to hold our interpolated joint poses. pose & scratch ) { pose * previous ; pose * next ; float * t ; // This function isn't provided, but it takes a clip and timestamp // and produces the poses that straddle the requested time and the // interpolation parameter. query_pose_endpoints ( clip , timestamp , & previous , & next , & t ); for ( uint16_t i = 0 ; i != parent . size ; ++ i ) { // This could use slerp or nlerp if we wanted. A possible // implementation of this slerp function was given above. scratch . joint_poses [ i ] = slerp ( previous -> joint_poses [ i ], next -> joint_poses [ i ], * t ); } // Reuse our keyframe forward kinematic routine from above animate_keyframe ( parent , instance , scratch ); } Of course, there are myriad optimizations that should jump out to us from the implementation given here, but as a starting point and considering how few lines of code we used, it's not bad in my opinion! Example optimizations include caching the logarithms from the previous frame, or reworking the code above so that all the temporary interpolated results do not need to reside in memory at once. The code provided here was written thusly in the interest of remaining terse. What about inv_bind_pose ?? We defined this kln::motor on our joint and never used it. \"What gives?\" you might ask. Well, we didn't use it because we didn't need to transform to the joint's local coordinate space. This will be needed for skinning which will be the subject of a future tutorial. I'm impressed you noticed this (if you did)!","title":"Spherical Interpolation"},{"location":"case_studies/ga_skeletal_animation/#conclusion","text":"We have developed from the ground up the barebones making of an animation library. To be anything close to resembly a production library, it would need animation blending, vertex skinning/morphing, animation retargeting, and a whole host of other features, but at the very least, it should have been illustrative in the basic underpinnings of modeling kinematic motion with Geometric Algebra and Klein. Of course, there's much more to geometry than rigid motion, so stay tuned for future write-ups on collision detection and a whole host of other topics! Feedback? Questions? Comments? Suggestions on what you'd like to see next? Feel free to drop by our discord and say hi!","title":"Conclusion"},{"location":"tutorial/exterior_algebra/","text":"Danger You are currently reading a DRAFT that is available publicly to facilitate collaboration In the introduction , we considered a set of three basis vectors \\(\\ee_1\\) , \\(\\ee_2\\) , and \\(\\ee_3\\) . In addition, we pontificated a bit on why restricting ourselves to vectors can cause issues, and argued for the need for a richer structure to match the richness of the geometry. But how should we go about doing this? In 3-dimensions, it seems a bit unfair that only \"arrows\" can be represented. After all, our world is filled with objects that have area and volume too. Suppose we wanted to represent a unit area in the x-y plane. Let's give it a name, say \\(\\ee_{12}\\) . It seems reasonable that the areas \\(\\ee_{13}\\) and \\(\\ee_{23}\\) . But wait! Our choice of of index order seems a bit arbitrary. What about \\(\\ee_{21}\\) , \\(\\ee_{31}\\) and \\(\\ee_{32}\\) . If we follow our nose a bit, it seems reasonable that the area represented by \\(\\ee_{12}\\) should equal \\(-\\ee_{21}\\) . After all, they possess opposite orientations from one another. /* window.addEventListener('load',()=>{ Algebra(3,0,1,()=>{ // rotation helper and Lathe function. var rot = (a,P)=>Math.cos(a)+Math.sin(a)*P.Normalized, lathe=(X,n,P,m)=>[...Array(n+1)].map((x,i)=>rot(i/n*Math.PI*(m||1),P)>>>X), // wrap takes X, a double array of points, and generates triangles. wrap=(X)=>{ var u=X.length-1,v=X[0].length-1; X=[].concat.apply([],X); var P=[],vp=v+1; for(var i=0;i<u*vp;i+=vp)for(var j=0;j<v;j++)P.push([i+j,i+j+1,vp+i+j],[i+j+1,vp+i+j,vp+i+j+1]); return P.map(x=>x.map(x=>X[x])); }, // Basic primitives constructed by Lathing points, line segments, etc. cylinder = (r=1,h=1,x=32)=>wrap(lathe([!1e0,!(1e0+r*1e3),!(1e0+r*1e3+h*1e1),!(1e0+h*1e1)],x,1e23)), torus = (r=.3,r2=.25,x=32,y=16)=>wrap(lathe((1+r*.5e03)>>>lathe(!(1e0+r2*(1e1+1e3)/2**.5),y,1e13),x,1e23)), sphere = (r=1,x=32,y=16)=>wrap(lathe(lathe(!(1e0+r*1e1),y,1e13,.5),x,1e23)), cone = (r=1,h=1,x=64)=>wrap(lathe([!1e0,!(1e0+r*1e3),!(1e0+h*1e1)],x,1e23)), arrow = ()=>[/*...cone(.075,0),*/...cone(.075,.2),...cylinder(.03,-1)], // A selection of these objects. objs=[arrow(),arrow()].map(x=>({data:x})); // Render and rotate them using the webGL2 previewer. var c=document.getElementById('bivector').appendChild( this.graph(()=>{ var time = Math.PI/2+-.5*Math.sin(performance.now()/1000); var time2 = Math.PI/2+-.5*Math.sin(performance.now()/2134); var t1 = objs[0].transform = rot(time,1e13)*rot(-0.1,1e12)*(1-.5e01); var t2 = objs[1].transform = rot(time2,1e12+.5e23)*rot(-0.1,1e12)*(1-.5e01); return [0xbbaaffaa,...objs, 0xff0000, [1e123,t1>>>1e123,t2>>>1e123]] },{gl:1,alpha:1,animate:1,camera:(1-.7e03)*Math.E**(Math.PI/4*1e13),grid:1})); c.style.width='100%'; c.style.height='250px'; c.style.background='transparent'; }); }); \\*/ What about elements with two repeated indices? Like \\(\\ee_{11}\\) or \\(\\ee_{33}\\) ? Well, such elements can't reasonably span any area, so let's get back to how we should handle those in a moment. Like the unit vectors, it seems sensible to allow us to scale these area-elements with a weight (like \\(3\\ee_{12}\\) ) and add them together to create areas of arbitrary weight and orientation. So, for example, let's try to add \\(\\ee_{12} + 2\\ee_{23}\\) . What should its orientation be? TODO! For volumes, we have one choice that spans a non-zero volume which is \\(\\ee_{123}\\) . We could have also chosen a different basis ordering, which again we'll get back to later. Let's call our single-index elements vectors as before, the two-index elements bivectors , and the three-index elements trivectors . TODO!","title":"Exterior Algebra"},{"location":"tutorial/intro/","text":"Danger You are currently reading a DRAFT that is available publicly to facilitate collaboration This guide is meant to be a gentle intro to Projective Geometric Algebra, also referred to as \\(\\mathbf{P}(\\mathbb{R}^*_{3, 0, 1})\\) . It assumes no knowledge of quaternions and dual-quaternions, but if you have some familiarity with either, you may find yourself armed with new insights and appreciation. Also not assumed is any knowledge of abstract algebra, or any specific algebra closely related to Geometric Algebra (e.g. exterior algebra, Clifford Algebra, etc.). The emphasis first is on just getting familiar with the notation, the various operations and what they do. The references page on the left contains some excellent material if you prefer a bottom up approach. Here though, the goal will be to build your intuition primarily through examples, and then introduce the formalism afterwards. Tip Grab a pen and paper! You are expected to work out a number of expressions by hand and see for yourself that the formulae behave as advertised. Further, drawing pictures is very important to maintain the linkage between the algebra and the geometry. We're going to go straight to 3D, so hang on tight. Let's start with three perfectly ordinary basis vectors, \\(\\ee_1\\) , \\(\\ee_2\\) and \\(\\ee_3\\) . Now, normally when we think about vectors, we imagine that they have some length and direction. In this case, let's have \\(\\ee_1\\) point in the x-direction, \\(\\ee_2\\) point in the y-direction, \\(\\ee_3\\) point in the z-direction, and give all of them unit length. Each one of these basis vectors can be scaled by a weight, and we can take linear combinations of them to create any vector in our 3D space. So far, everything behaves just like your good ol' 3D vector space. /* window.addEventListener('load',()=>{ Algebra(3,0,1,()=>{ // rotation helper and Lathe function. var rot = (a,P)=>Math.cos(a)+Math.sin(a)*P.Normalized, lathe=(X,n,P,m)=>[...Array(n+1)].map((x,i)=>rot(i/n*Math.PI*(m||1),P)>>>X), // wrap takes X, a double array of points, and generates triangles. wrap=(X)=>{ var u=X.length-1,v=X[0].length-1; X=[].concat.apply([],X); var P=[],vp=v+1; for(var i=0;i<u*vp;i+=vp)for(var j=0;j<v;j++)P.push([i+j,i+j+1,vp+i+j],[i+j+1,vp+i+j,vp+i+j+1]); return P.map(x=>x.map(x=>X[x])); }, // Basic primitives constructed by Lathing points, line segments, etc. cylinder = (r=1,h=1,x=32)=>wrap(lathe([!1e0,!(1e0+r*1e3),!(1e0+r*1e3+h*1e1),!(1e0+h*1e1)],x,1e23)), torus = (r=.3,r2=.25,x=32,y=16)=>wrap(lathe((1+r*.5e03)>>>lathe(!(1e0+r2*(1e1+1e3)/2**.5),y,1e13),x,1e23)), sphere = (r=1,x=32,y=16)=>wrap(lathe(lathe(!(1e0+r*1e1),y,1e13,.5),x,1e23)), cone = (r=1,h=1,x=64)=>wrap(lathe([!1e0,!(1e0+r*1e3),!(1e0+h*1e1)],x,1e23)), arrow = ()=>[...cone(.075,.2),...cone(.075,0),...cylinder(.03,-1)], // A selection of these objects. objs=[arrow()].map(x=>({data:x})); // Render and rotate them using the webGL2 previewer. var c=document.getElementById('vector').appendChild( this.graph(()=>{ var time = Math.PI/2+-.5*Math.sin(performance.now()/1000); objs.forEach((obj,i)=>obj.transform = rot(time,1e13)*rot(-0.1,1e12)*(1-.5e01)); return [0x00ff88,...objs] },{gl:1,alpha:1,animate:1,camera:(1-.7e03)*Math.E**(Math.PI/4*1e13),grid:1})); c.style.width='100%'; c.style.height='250px'; c.style.background='transparent'; }); }); \\*/ Now, let's pause and consider for a moment what our vector space might be lacking. With vectors alone, we can certainly come up with ways to represent all sorts of things. Sometimes, vectors are arrows from the origin. Other times, we use vectors to mean the point terminated at by that arrow. Still other times, a vector is used to represent a plane through the origin by encoding the normal to the plane. In a way, vectors are somewhat encumbered due to the need to represent all the various entities in geometry one way or another. But even if we try, we'll find that there are still aspects of geometry that we can't reasonably or easily represent with vectors. For example, what if the plane didn't go through the origin? I suppose we could use two vectors, one for the normal, and one to describe a point in the plane. What about a rotation? Maybe we use a vector for the axis, and the length includes the angle. Translations? Maybe the vector points in the direction of the translation and the length encodes the displacement. Do you see an issue with the way things are going with this thought exercise? All of these interpretations of what a \"vector\" is are not mutually compatible with one another! We certainly can't add a vector intended to be used as a rotation axis and a vector intended to be used as a plane normal and expect to have a consistent interpretation of the result. All of them need to be treated distinctly and live \"in their own space\" as it were, with very delicate code to keep the invisible boundaries between them uncrossed. Needless to say, mathematically, the situation described above leaves much to be desired. What we'd like is an algebra (aka the Geometric Algebra) that could describe all the entities we need (points, lines, planes, rotations, translations, to name a few) in a unifying framework glued by an operation which has a sensible meaning when its operands are any of the listed entities (aka the geometric product). To make this a reality though, we're going to need to move past our vector space and limited set of operations to an algebra that is much richer. This algebra (the Geometric Algebra) will have more operations than you're used to, and more \"things\" than you're used to, but that's to be expected. After all, geometry is far richer than just arrows emanating from the origin. Embracing the additional structure is in some sense, akin to embracing the reality that is geometry itself, and acknowledge that the algebra is going to need to play some catch up to describe the geometry more aptly. So, then, aside from vectors, what else do we need? In the next section, we'll describe the exterior algebra as a stepping stone to geometric algebra, so see you there!","title":"Introduction"}]}